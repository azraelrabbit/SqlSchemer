//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from grammars/plsql.g4 by ANTLR 4.5.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
[System.CLSCompliant(false)]
public partial class plsqlParser : Parser {
	public const int
		T__0=1, A_LETTER=2, ADD=3, AFTER=4, AGENT=5, AGGREGATE=6, ALL=7, ALTER=8, 
		ANALYZE=9, AND=10, ANY=11, ARRAY=12, AS=13, ASC=14, ASSOCIATE=15, AT=16, 
		ATTRIBUTE=17, AUDIT=18, AUTHID=19, AUTO=20, AUTOMATIC=21, AUTONOMOUS_TRANSACTION=22, 
		BATCH=23, BEFORE=24, BEGIN=25, BETWEEN=26, BFILE=27, BINARY_DOUBLE=28, 
		BINARY_FLOAT=29, BINARY_INTEGER=30, BLOB=31, BLOCK=32, BODY=33, BOOLEAN=34, 
		BOTH=35, BREADTH=36, BULK=37, BY=38, BYTE=39, C_LETTER=40, CACHE=41, CALL=42, 
		CANONICAL=43, CASCADE=44, CASE=45, CAST=46, CHAR=47, CHAR_CS=48, CHARACTER=49, 
		CHECK=50, CHR=51, CLOB=52, CLOSE=53, CLUSTER=54, COLLECT=55, COLUMNS=56, 
		COMMENT=57, COMMIT=58, COMMITTED=59, COMPATIBILITY=60, COMPILE=61, COMPOUND=62, 
		CONNECT=63, CONNECT_BY_ROOT=64, CONSTANT=65, CONSTRAINT=66, CONSTRAINTS=67, 
		CONSTRUCTOR=68, CONTENT=69, CONTEXT=70, CONTINUE=71, CONVERT=72, CORRUPT_XID=73, 
		CORRUPT_XID_ALL=74, COST=75, COUNT=76, CREATE=77, CROSS=78, CUBE=79, CURRENT=80, 
		CURRENT_USER=81, CURSOR=82, CUSTOMDATUM=83, CYCLE=84, DATA=85, DATABASE=86, 
		DATE=87, DAY=88, DB_ROLE_CHANGE=89, DBTIMEZONE=90, DDL=91, DEBUG=92, DEC=93, 
		DECIMAL=94, DECLARE=95, DECOMPOSE=96, DECREMENT=97, DEFAULT=98, DEFAULTS=99, 
		DEFERRED=100, DEFINER=101, DELETE=102, DEPTH=103, DESC=104, DETERMINISTIC=105, 
		DIMENSION=106, DISABLE=107, DISASSOCIATE=108, DISTINCT=109, DOCUMENT=110, 
		DOUBLE=111, DROP=112, DSINTERVAL_UNCONSTRAINED=113, EACH=114, ELEMENT=115, 
		ELSE=116, ELSIF=117, EMPTY=118, ENABLE=119, ENCODING=120, END=121, ENTITYESCAPING=122, 
		ERR=123, ERRORS=124, ESCAPE=125, EVALNAME=126, EXCEPTION=127, EXCEPTION_INIT=128, 
		EXCEPTIONS=129, EXCLUDE=130, EXCLUSIVE=131, EXECUTE=132, EXISTS=133, EXIT=134, 
		EXPLAIN=135, EXTERNAL=136, EXTRACT=137, FAILURE=138, FALSE=139, FETCH=140, 
		FINAL=141, FIRST=142, FIRST_VALUE=143, FLOAT=144, FOLLOWING=145, FOLLOWS=146, 
		FOR=147, FORALL=148, FORCE=149, FROM=150, FULL=151, FUNCTION=152, GOTO=153, 
		GRANT=154, GROUP=155, GROUPING=156, HASH=157, HAVING=158, HIDE=159, HOUR=160, 
		IF=161, IGNORE=162, IMMEDIATE=163, IN=164, INCLUDE=165, INCLUDING=166, 
		INCREMENT=167, INDENT=168, INDEX=169, INDEXED=170, INDICATOR=171, INDICES=172, 
		INFINITE=173, INLINE=174, INNER=175, INOUT=176, INSERT=177, INSTANTIABLE=178, 
		INSTEAD=179, INT=180, INTEGER=181, INTERSECT=182, INTERVAL=183, INTO=184, 
		INVALIDATE=185, IS=186, ISOLATION=187, ITERATE=188, JAVA=189, JOIN=190, 
		KEEP=191, LANGUAGE=192, LAST=193, LAST_VALUE=194, LEADING=195, LEFT=196, 
		LEVEL=197, LIBRARY=198, LIKE=199, LIKE2=200, LIKE4=201, LIKEC=202, LIMIT=203, 
		LOCAL=204, LOCK=205, LOCKED=206, LOG=207, LOGOFF=208, LOGON=209, LONG=210, 
		LOOP=211, MAIN=212, MAP=213, MATCHED=214, MAXVALUE=215, MEASURES=216, 
		MEMBER=217, MERGE=218, MINUS=219, MINUTE=220, MINVALUE=221, MLSLABEL=222, 
		MODE=223, MODEL=224, MODIFY=225, MONTH=226, MULTISET=227, NAME=228, NAN=229, 
		NATURAL=230, NATURALN=231, NAV=232, NCHAR=233, NCHAR_CS=234, NCLOB=235, 
		NESTED=236, NEW=237, NO=238, NOAUDIT=239, NOCACHE=240, NOCOPY=241, NOCYCLE=242, 
		NOENTITYESCAPING=243, NOMAXVALUE=244, NOMINVALUE=245, NONE=246, NOORDER=247, 
		NOSCHEMACHECK=248, NOT=249, NOWAIT=250, NULL=251, NULLS=252, NUMBER=253, 
		NUMERIC=254, NVARCHAR2=255, OBJECT=256, OF=257, OFF=258, OID=259, OLD=260, 
		ON=261, ONLY=262, OPEN=263, OPTION=264, OR=265, ORADATA=266, ORDER=267, 
		ORDINALITY=268, OSERROR=269, OUT=270, OUTER=271, OVER=272, OVERRIDING=273, 
		PACKAGE=274, PARALLEL_ENABLE=275, PARAMETERS=276, PARENT=277, PARTITION=278, 
		PASSING=279, PATH=280, PERCENT_ROWTYPE=281, PERCENT_TYPE=282, PIPELINED=283, 
		PIVOT=284, PLAN=285, PLS_INTEGER=286, POSITIVE=287, POSITIVEN=288, PRAGMA=289, 
		PRECEDING=290, PRECISION=291, PRESENT=292, PRIOR=293, PROCEDURE=294, RAISE=295, 
		RANGE=296, RAW=297, READ=298, REAL=299, RECORD=300, REF=301, REFERENCE=302, 
		REFERENCING=303, REJECT=304, RELIES_ON=305, RENAME=306, REPLACE=307, RESPECT=308, 
		RESTRICT_REFERENCES=309, RESULT=310, RESULT_CACHE=311, RETURN=312, RETURNING=313, 
		REUSE=314, REVERSE=315, REVOKE=316, RIGHT=317, ROLLBACK=318, ROLLUP=319, 
		ROW=320, ROWID=321, ROWS=322, RULES=323, SAMPLE=324, SAVE=325, SAVEPOINT=326, 
		SCHEMA=327, SCHEMACHECK=328, SCN=329, SEARCH=330, SECOND=331, SEED=332, 
		SEGMENT=333, SELECT=334, SELF=335, SEQUENCE=336, SEQUENTIAL=337, SERIALIZABLE=338, 
		SERIALLY_REUSABLE=339, SERVERERROR=340, SESSIONTIMEZONE=341, SET=342, 
		SETS=343, SETTINGS=344, SHARE=345, SHOW=346, SHUTDOWN=347, SIBLINGS=348, 
		SIGNTYPE=349, SIMPLE_INTEGER=350, SINGLE=351, SIZE=352, SKIP_=353, SMALLINT=354, 
		SNAPSHOT=355, SOME=356, SPECIFICATION=357, SQLDATA=358, SQLERROR=359, 
		STANDALONE=360, START=361, STARTUP=362, STATEMENT=363, STATEMENT_ID=364, 
		STATIC=365, STATISTICS=366, STRING=367, SUBMULTISET=368, SUBPARTITION=369, 
		SUBSTITUTABLE=370, SUBTYPE=371, SUCCESS=372, SUSPEND=373, TABLE=374, THE=375, 
		THEN=376, TIME=377, TIMESTAMP=378, TIMESTAMP_LTZ_UNCONSTRAINED=379, TIMESTAMP_TZ_UNCONSTRAINED=380, 
		TIMESTAMP_UNCONSTRAINED=381, TIMEZONE_ABBR=382, TIMEZONE_HOUR=383, TIMEZONE_MINUTE=384, 
		TIMEZONE_REGION=385, TO=386, TRAILING=387, TRANSACTION=388, TRANSLATE=389, 
		TREAT=390, TRIGGER=391, TRIM=392, TRUE=393, TRUNCATE=394, TYPE=395, UNBOUNDED=396, 
		UNDER=397, UNION=398, UNIQUE=399, UNLIMITED=400, UNPIVOT=401, UNTIL=402, 
		UPDATE=403, UPDATED=404, UPSERT=405, UROWID=406, USE=407, USING=408, VALIDATE=409, 
		VALUE=410, VALUES=411, VARCHAR=412, VARCHAR2=413, VARIABLE=414, VARRAY=415, 
		VARYING=416, VERSION=417, VERSIONS=418, WAIT=419, WARNING=420, WELLFORMED=421, 
		WHEN=422, WHENEVER=423, WHERE=424, WHILE=425, WITH=426, WITHIN=427, WORK=428, 
		WRITE=429, XML=430, XMLAGG=431, XMLATTRIBUTES=432, XMLCAST=433, XMLCOLATTVAL=434, 
		XMLELEMENT=435, XMLEXISTS=436, XMLFOREST=437, XMLNAMESPACES=438, XMLPARSE=439, 
		XMLPI=440, XMLQUERY=441, XMLROOT=442, XMLSERIALIZE=443, XMLTABLE=444, 
		YEAR=445, YES=446, YMINTERVAL_UNCONSTRAINED=447, ZONE=448, PREDICTION=449, 
		PREDICTION_BOUNDS=450, PREDICTION_COST=451, PREDICTION_DETAILS=452, PREDICTION_PROBABILITY=453, 
		PREDICTION_SET=454, CUME_DIST=455, DENSE_RANK=456, LISTAGG=457, PERCENT_RANK=458, 
		PERCENTILE_CONT=459, PERCENTILE_DISC=460, RANK=461, AVG=462, CORR=463, 
		LAG=464, LEAD=465, MAX=466, MEDIAN=467, MIN=468, NTILE=469, RATIO_TO_REPORT=470, 
		ROW_NUMBER=471, SUM=472, VARIANCE=473, REGR_=474, STDDEV=475, VAR_=476, 
		COVAR_=477, NATIONAL_CHAR_STRING_LIT=478, BIT_STRING_LIT=479, HEX_STRING_LIT=480, 
		DOUBLE_PERIOD=481, PERIOD=482, UNSIGNED_INTEGER=483, APPROXIMATE_NUM_LIT=484, 
		CHAR_STRING=485, DELIMITED_ID=486, PERCENT=487, AMPERSAND=488, LEFT_PAREN=489, 
		RIGHT_PAREN=490, DOUBLE_ASTERISK=491, ASTERISK=492, PLUS_SIGN=493, MINUS_SIGN=494, 
		COMMA=495, SOLIDUS=496, AT_SIGN=497, ASSIGN_OP=498, BINDVAR=499, COLON=500, 
		SEMICOLON=501, LESS_THAN_OR_EQUALS_OP=502, LESS_THAN_OP=503, GREATER_THAN_OR_EQUALS_OP=504, 
		NOT_EQUAL_OP=505, CARRET_OPERATOR_PART=506, TILDE_OPERATOR_PART=507, EXCLAMATION_OPERATOR_PART=508, 
		GREATER_THAN_OP=509, CONCATENATION_OP=510, VERTICAL_BAR=511, EQUALS_OP=512, 
		LEFT_BRACKET=513, RIGHT_BRACKET=514, INTRODUCER=515, SPACES=516, SINGLE_LINE_COMMENT=517, 
		MULTI_LINE_COMMENT=518, PROMPT=519, SQL92_RESERVED_ALL=520, SQL92_RESERVED_ALTER=521, 
		SQL92_RESERVED_AND=522, SQL92_RESERVED_ANY=523, SQL92_RESERVED_AS=524, 
		SQL92_RESERVED_ASC=525, SQL92_RESERVED_BEGIN=526, SQL92_RESERVED_BETWEEN=527, 
		SQL92_RESERVED_BY=528, SQL92_RESERVED_CASE=529, SQL92_RESERVED_CHECK=530, 
		PLSQL_RESERVED_CLUSTERS=531, PLSQL_RESERVED_COLAUTH=532, PLSQL_RESERVED_COMPRESS=533, 
		SQL92_RESERVED_CONNECT=534, PLSQL_NON_RESERVED_CONNECT_BY_ROOT=535, PLSQL_RESERVED_CRASH=536, 
		SQL92_RESERVED_CREATE=537, SQL92_RESERVED_CURRENT=538, SQL92_RESERVED_CURSOR=539, 
		SQL92_RESERVED_DATE=540, SQL92_RESERVED_DECLARE=541, SQL92_RESERVED_DEFAULT=542, 
		SQL92_RESERVED_DELETE=543, SQL92_RESERVED_DESC=544, SQL92_RESERVED_DISTINCT=545, 
		SQL92_RESERVED_DROP=546, SQL92_RESERVED_ELSE=547, SQL92_RESERVED_END=548, 
		SQL92_RESERVED_EXCEPTION=549, PLSQL_RESERVED_EXCLUSIVE=550, SQL92_RESERVED_EXISTS=551, 
		SQL92_RESERVED_FALSE=552, SQL92_RESERVED_FETCH=553, SQL92_RESERVED_FOR=554, 
		SQL92_RESERVED_FROM=555, SQL92_RESERVED_GOTO=556, SQL92_RESERVED_GRANT=557, 
		SQL92_RESERVED_GROUP=558, SQL92_RESERVED_HAVING=559, PLSQL_RESERVED_IDENTIFIED=560, 
		PLSQL_RESERVED_IF=561, SQL92_RESERVED_IN=562, PLSQL_RESERVED_INDEX=563, 
		PLSQL_RESERVED_INDEXES=564, SQL92_RESERVED_INSERT=565, SQL92_RESERVED_INTERSECT=566, 
		SQL92_RESERVED_INTO=567, SQL92_RESERVED_IS=568, SQL92_RESERVED_LIKE=569, 
		PLSQL_RESERVED_LOCK=570, PLSQL_RESERVED_MINUS=571, PLSQL_RESERVED_MODE=572, 
		PLSQL_RESERVED_NOCOMPRESS=573, SQL92_RESERVED_NOT=574, PLSQL_RESERVED_NOWAIT=575, 
		SQL92_RESERVED_NULL=576, SQL92_RESERVED_OF=577, SQL92_RESERVED_ON=578, 
		SQL92_RESERVED_OPTION=579, SQL92_RESERVED_OR=580, SQL92_RESERVED_ORDER=581, 
		SQL92_RESERVED_OVERLAPS=582, SQL92_RESERVED_PRIOR=583, SQL92_RESERVED_PROCEDURE=584, 
		SQL92_RESERVED_PUBLIC=585, PLSQL_RESERVED_RESOURCE=586, SQL92_RESERVED_REVOKE=587, 
		SQL92_RESERVED_SELECT=588, PLSQL_RESERVED_SHARE=589, SQL92_RESERVED_SIZE=590, 
		PLSQL_RESERVED_START=591, PLSQL_RESERVED_TABAUTH=592, SQL92_RESERVED_TABLE=593, 
		SQL92_RESERVED_THE=594, SQL92_RESERVED_THEN=595, SQL92_RESERVED_TO=596, 
		SQL92_RESERVED_TRUE=597, SQL92_RESERVED_UNION=598, SQL92_RESERVED_UNIQUE=599, 
		SQL92_RESERVED_UPDATE=600, SQL92_RESERVED_VALUES=601, SQL92_RESERVED_VIEW=602, 
		PLSQL_RESERVED_VIEWS=603, SQL92_RESERVED_WHEN=604, SQL92_RESERVED_WHERE=605, 
		SQL92_RESERVED_WITH=606, PLSQL_NON_RESERVED_USING=607, PLSQL_NON_RESERVED_MODEL=608, 
		PLSQL_NON_RESERVED_ELSIF=609, PLSQL_NON_RESERVED_PIVOT=610, PLSQL_NON_RESERVED_UNPIVOT=611, 
		REGULAR_ID=612, ZV=613;
	public const int
		RULE_swallow_to_semi = 0, RULE_compilation_unit = 1, RULE_sql_script = 2, 
		RULE_unit_statement = 3, RULE_drop_function = 4, RULE_alter_function = 5, 
		RULE_create_function_body = 6, RULE_parallel_enable_clause = 7, RULE_partition_by_clause = 8, 
		RULE_result_cache_clause = 9, RULE_relies_on_part = 10, RULE_streaming_clause = 11, 
		RULE_drop_package = 12, RULE_alter_package = 13, RULE_create_package = 14, 
		RULE_package_body = 15, RULE_package_spec = 16, RULE_package_obj_spec = 17, 
		RULE_procedure_spec = 18, RULE_function_spec = 19, RULE_package_obj_body = 20, 
		RULE_drop_procedure = 21, RULE_alter_procedure = 22, RULE_create_procedure_body = 23, 
		RULE_drop_trigger = 24, RULE_alter_trigger = 25, RULE_create_trigger = 26, 
		RULE_trigger_follows_clause = 27, RULE_trigger_when_clause = 28, RULE_simple_dml_trigger = 29, 
		RULE_for_each_row = 30, RULE_compound_dml_trigger = 31, RULE_non_dml_trigger = 32, 
		RULE_trigger_body = 33, RULE_routine_clause = 34, RULE_compound_trigger_block = 35, 
		RULE_timing_point_section = 36, RULE_non_dml_event = 37, RULE_dml_event_clause = 38, 
		RULE_dml_event_element = 39, RULE_dml_event_nested_clause = 40, RULE_referencing_clause = 41, 
		RULE_referencing_element = 42, RULE_drop_type = 43, RULE_alter_type = 44, 
		RULE_compile_type_clause = 45, RULE_replace_type_clause = 46, RULE_alter_method_spec = 47, 
		RULE_alter_method_element = 48, RULE_alter_attribute_definition = 49, 
		RULE_attribute_definition = 50, RULE_alter_collection_clauses = 51, RULE_dependent_handling_clause = 52, 
		RULE_dependent_exceptions_part = 53, RULE_create_type = 54, RULE_type_definition = 55, 
		RULE_object_type_def = 56, RULE_object_as_part = 57, RULE_object_under_part = 58, 
		RULE_nested_table_type_def = 59, RULE_sqlj_object_type = 60, RULE_type_body = 61, 
		RULE_type_body_elements = 62, RULE_map_order_func_declaration = 63, RULE_subprog_decl_in_type = 64, 
		RULE_proc_decl_in_type = 65, RULE_func_decl_in_type = 66, RULE_constructor_declaration = 67, 
		RULE_modifier_clause = 68, RULE_object_member_spec = 69, RULE_sqlj_object_type_attr = 70, 
		RULE_element_spec = 71, RULE_element_spec_options = 72, RULE_subprogram_spec = 73, 
		RULE_type_procedure_spec = 74, RULE_type_function_spec = 75, RULE_constructor_spec = 76, 
		RULE_map_order_function_spec = 77, RULE_pragma_clause = 78, RULE_pragma_elements = 79, 
		RULE_type_elements_parameter = 80, RULE_drop_sequence = 81, RULE_alter_sequence = 82, 
		RULE_create_sequence = 83, RULE_sequence_spec = 84, RULE_sequence_start_clause = 85, 
		RULE_invoker_rights_clause = 86, RULE_compiler_parameters_clause = 87, 
		RULE_call_spec = 88, RULE_java_spec = 89, RULE_c_spec = 90, RULE_c_agent_in_clause = 91, 
		RULE_c_parameters_clause = 92, RULE_parameter = 93, RULE_default_value_part = 94, 
		RULE_declare_spec = 95, RULE_variable_declaration = 96, RULE_subtype_declaration = 97, 
		RULE_cursor_declaration = 98, RULE_parameter_spec = 99, RULE_exception_declaration = 100, 
		RULE_pragma_declaration = 101, RULE_record_declaration = 102, RULE_record_type_dec = 103, 
		RULE_field_spec = 104, RULE_record_var_dec = 105, RULE_table_declaration = 106, 
		RULE_table_type_dec = 107, RULE_table_indexed_by_part = 108, RULE_varray_type_def = 109, 
		RULE_table_var_dec = 110, RULE_seq_of_statements = 111, RULE_label_declaration = 112, 
		RULE_statement = 113, RULE_assignment_statement = 114, RULE_continue_statement = 115, 
		RULE_exit_statement = 116, RULE_goto_statement = 117, RULE_if_statement = 118, 
		RULE_elsif_part = 119, RULE_else_part = 120, RULE_loop_statement = 121, 
		RULE_cursor_loop_param = 122, RULE_forall_statement = 123, RULE_bounds_clause = 124, 
		RULE_between_bound = 125, RULE_lower_bound = 126, RULE_upper_bound = 127, 
		RULE_null_statement = 128, RULE_raise_statement = 129, RULE_return_statement = 130, 
		RULE_function_call = 131, RULE_body = 132, RULE_exception_clause = 133, 
		RULE_exception_handler = 134, RULE_trigger_block = 135, RULE_block = 136, 
		RULE_sql_statement = 137, RULE_execute_immediate = 138, RULE_dynamic_returning_clause = 139, 
		RULE_data_manipulation_language_statements = 140, RULE_cursor_manipulation_statements = 141, 
		RULE_close_statement = 142, RULE_open_statement = 143, RULE_fetch_statement = 144, 
		RULE_open_for_statement = 145, RULE_transaction_control_statements = 146, 
		RULE_set_transaction_command = 147, RULE_set_constraint_command = 148, 
		RULE_commit_statement = 149, RULE_write_clause = 150, RULE_rollback_statement = 151, 
		RULE_savepoint_statement = 152, RULE_explain_statement = 153, RULE_select_statement = 154, 
		RULE_subquery_factoring_clause = 155, RULE_factoring_element = 156, RULE_search_clause = 157, 
		RULE_cycle_clause = 158, RULE_subquery = 159, RULE_subquery_operation_part = 160, 
		RULE_subquery_basic_elements = 161, RULE_query_block = 162, RULE_selected_element = 163, 
		RULE_from_clause = 164, RULE_select_list_elements = 165, RULE_table_ref_list = 166, 
		RULE_table_ref = 167, RULE_table_ref_aux = 168, RULE_join_clause = 169, 
		RULE_join_on_part = 170, RULE_join_using_part = 171, RULE_outer_join_type = 172, 
		RULE_query_partition_clause = 173, RULE_flashback_query_clause = 174, 
		RULE_pivot_clause = 175, RULE_pivot_element = 176, RULE_pivot_for_clause = 177, 
		RULE_pivot_in_clause = 178, RULE_pivot_in_clause_element = 179, RULE_pivot_in_clause_elements = 180, 
		RULE_unpivot_clause = 181, RULE_unpivot_in_clause = 182, RULE_unpivot_in_elements = 183, 
		RULE_hierarchical_query_clause = 184, RULE_start_part = 185, RULE_group_by_clause = 186, 
		RULE_group_by_elements = 187, RULE_rollup_cube_clause = 188, RULE_grouping_sets_clause = 189, 
		RULE_grouping_sets_elements = 190, RULE_having_clause = 191, RULE_model_clause = 192, 
		RULE_cell_reference_options = 193, RULE_return_rows_clause = 194, RULE_reference_model = 195, 
		RULE_main_model = 196, RULE_model_column_clauses = 197, RULE_model_column_partition_part = 198, 
		RULE_model_column_list = 199, RULE_model_column = 200, RULE_model_rules_clause = 201, 
		RULE_model_rules_part = 202, RULE_model_rules_element = 203, RULE_cell_assignment = 204, 
		RULE_model_iterate_clause = 205, RULE_until_part = 206, RULE_order_by_clause = 207, 
		RULE_order_by_elements = 208, RULE_for_update_clause = 209, RULE_for_update_of_part = 210, 
		RULE_for_update_options = 211, RULE_update_statement = 212, RULE_update_set_clause = 213, 
		RULE_column_based_update_set_clause = 214, RULE_delete_statement = 215, 
		RULE_insert_statement = 216, RULE_single_table_insert = 217, RULE_multi_table_insert = 218, 
		RULE_multi_table_element = 219, RULE_conditional_insert_clause = 220, 
		RULE_conditional_insert_when_part = 221, RULE_conditional_insert_else_part = 222, 
		RULE_insert_into_clause = 223, RULE_values_clause = 224, RULE_merge_statement = 225, 
		RULE_merge_update_clause = 226, RULE_merge_element = 227, RULE_merge_update_delete_part = 228, 
		RULE_merge_insert_clause = 229, RULE_selected_tableview = 230, RULE_lock_table_statement = 231, 
		RULE_wait_nowait_part = 232, RULE_lock_table_element = 233, RULE_lock_mode = 234, 
		RULE_general_table_ref = 235, RULE_static_returning_clause = 236, RULE_error_logging_clause = 237, 
		RULE_error_logging_into_part = 238, RULE_error_logging_reject_part = 239, 
		RULE_dml_table_expression_clause = 240, RULE_table_collection_expression = 241, 
		RULE_subquery_restriction_clause = 242, RULE_sample_clause = 243, RULE_seed_part = 244, 
		RULE_cursor_expression = 245, RULE_expression_list = 246, RULE_condition = 247, 
		RULE_condition_wrapper = 248, RULE_expression = 249, RULE_expression_wrapper = 250, 
		RULE_logical_and_expression = 251, RULE_negated_expression = 252, RULE_equality_expression = 253, 
		RULE_multiset_expression = 254, RULE_multiset_type = 255, RULE_relational_expression = 256, 
		RULE_compound_expression = 257, RULE_like_type = 258, RULE_like_escape_part = 259, 
		RULE_in_elements = 260, RULE_between_elements = 261, RULE_concatenation = 262, 
		RULE_concatenation_wrapper = 263, RULE_additive_expression = 264, RULE_multiply_expression = 265, 
		RULE_datetime_expression = 266, RULE_interval_expression = 267, RULE_model_expression = 268, 
		RULE_model_expression_element = 269, RULE_single_column_for_loop = 270, 
		RULE_for_like_part = 271, RULE_for_increment_decrement_type = 272, RULE_multi_column_for_loop = 273, 
		RULE_unary_expression = 274, RULE_case_statement = 275, RULE_simple_case_statement = 276, 
		RULE_simple_case_when_part = 277, RULE_searched_case_statement = 278, 
		RULE_searched_case_when_part = 279, RULE_case_else_part = 280, RULE_atom = 281, 
		RULE_expression_or_vector = 282, RULE_vector_expr = 283, RULE_quantified_expression = 284, 
		RULE_standard_function = 285, RULE_over_clause_keyword = 286, RULE_within_or_over_clause_keyword = 287, 
		RULE_standard_prediction_function_keyword = 288, RULE_over_clause = 289, 
		RULE_windowing_clause = 290, RULE_windowing_type = 291, RULE_windowing_elements = 292, 
		RULE_using_clause = 293, RULE_using_element = 294, RULE_collect_order_by_part = 295, 
		RULE_within_or_over_part = 296, RULE_cost_matrix_clause = 297, RULE_xml_passing_clause = 298, 
		RULE_xml_attributes_clause = 299, RULE_xml_namespaces_clause = 300, RULE_xml_table_column = 301, 
		RULE_xml_general_default_part = 302, RULE_xml_multiuse_expression_element = 303, 
		RULE_xmlroot_param_version_part = 304, RULE_xmlroot_param_standalone_part = 305, 
		RULE_xmlserialize_param_enconding_part = 306, RULE_xmlserialize_param_version_part = 307, 
		RULE_xmlserialize_param_ident_part = 308, RULE_sql_plus_command = 309, 
		RULE_whenever_command = 310, RULE_set_command = 311, RULE_exit_command = 312, 
		RULE_prompt_command = 313, RULE_show_errors_command = 314, RULE_partition_extension_clause = 315, 
		RULE_column_alias = 316, RULE_table_alias = 317, RULE_alias_quoted_string = 318, 
		RULE_where_clause = 319, RULE_current_of_clause = 320, RULE_into_clause = 321, 
		RULE_xml_column_name = 322, RULE_cost_class_name = 323, RULE_attribute_name = 324, 
		RULE_savepoint_name = 325, RULE_rollback_segment_name = 326, RULE_table_var_name = 327, 
		RULE_schema_name = 328, RULE_routine_name = 329, RULE_package_name = 330, 
		RULE_implementation_type_name = 331, RULE_parameter_name = 332, RULE_reference_model_name = 333, 
		RULE_main_model_name = 334, RULE_aggregate_function_name = 335, RULE_query_name = 336, 
		RULE_constraint_name = 337, RULE_label_name = 338, RULE_type_name = 339, 
		RULE_sequence_name = 340, RULE_exception_name = 341, RULE_function_name = 342, 
		RULE_procedure_name = 343, RULE_trigger_name = 344, RULE_variable_name = 345, 
		RULE_index_name = 346, RULE_cursor_name = 347, RULE_record_name = 348, 
		RULE_collection_name = 349, RULE_link_name = 350, RULE_column_name = 351, 
		RULE_tableview_name = 352, RULE_char_set_name = 353, RULE_keep_clause = 354, 
		RULE_function_argument = 355, RULE_function_argument_analytic = 356, RULE_function_argument_modeling = 357, 
		RULE_respect_or_ignore_nulls = 358, RULE_argument = 359, RULE_type_spec = 360, 
		RULE_datatype = 361, RULE_precision_part = 362, RULE_native_datatype_element = 363, 
		RULE_bind_variable = 364, RULE_general_element = 365, RULE_general_element_part = 366, 
		RULE_table_element = 367, RULE_constant = 368, RULE_numeric = 369, RULE_numeric_negative = 370, 
		RULE_quoted_string = 371, RULE_id = 372, RULE_id_expression = 373, RULE_not_equal_op = 374, 
		RULE_greater_than_or_equals_op = 375, RULE_less_than_or_equals_op = 376, 
		RULE_concatenation_op = 377, RULE_outer_join_sign = 378, RULE_regular_id = 379;
	public static readonly string[] ruleNames = {
		"swallow_to_semi", "compilation_unit", "sql_script", "unit_statement", 
		"drop_function", "alter_function", "create_function_body", "parallel_enable_clause", 
		"partition_by_clause", "result_cache_clause", "relies_on_part", "streaming_clause", 
		"drop_package", "alter_package", "create_package", "package_body", "package_spec", 
		"package_obj_spec", "procedure_spec", "function_spec", "package_obj_body", 
		"drop_procedure", "alter_procedure", "create_procedure_body", "drop_trigger", 
		"alter_trigger", "create_trigger", "trigger_follows_clause", "trigger_when_clause", 
		"simple_dml_trigger", "for_each_row", "compound_dml_trigger", "non_dml_trigger", 
		"trigger_body", "routine_clause", "compound_trigger_block", "timing_point_section", 
		"non_dml_event", "dml_event_clause", "dml_event_element", "dml_event_nested_clause", 
		"referencing_clause", "referencing_element", "drop_type", "alter_type", 
		"compile_type_clause", "replace_type_clause", "alter_method_spec", "alter_method_element", 
		"alter_attribute_definition", "attribute_definition", "alter_collection_clauses", 
		"dependent_handling_clause", "dependent_exceptions_part", "create_type", 
		"type_definition", "object_type_def", "object_as_part", "object_under_part", 
		"nested_table_type_def", "sqlj_object_type", "type_body", "type_body_elements", 
		"map_order_func_declaration", "subprog_decl_in_type", "proc_decl_in_type", 
		"func_decl_in_type", "constructor_declaration", "modifier_clause", "object_member_spec", 
		"sqlj_object_type_attr", "element_spec", "element_spec_options", "subprogram_spec", 
		"type_procedure_spec", "type_function_spec", "constructor_spec", "map_order_function_spec", 
		"pragma_clause", "pragma_elements", "type_elements_parameter", "drop_sequence", 
		"alter_sequence", "create_sequence", "sequence_spec", "sequence_start_clause", 
		"invoker_rights_clause", "compiler_parameters_clause", "call_spec", "java_spec", 
		"c_spec", "c_agent_in_clause", "c_parameters_clause", "parameter", "default_value_part", 
		"declare_spec", "variable_declaration", "subtype_declaration", "cursor_declaration", 
		"parameter_spec", "exception_declaration", "pragma_declaration", "record_declaration", 
		"record_type_dec", "field_spec", "record_var_dec", "table_declaration", 
		"table_type_dec", "table_indexed_by_part", "varray_type_def", "table_var_dec", 
		"seq_of_statements", "label_declaration", "statement", "assignment_statement", 
		"continue_statement", "exit_statement", "goto_statement", "if_statement", 
		"elsif_part", "else_part", "loop_statement", "cursor_loop_param", "forall_statement", 
		"bounds_clause", "between_bound", "lower_bound", "upper_bound", "null_statement", 
		"raise_statement", "return_statement", "function_call", "body", "exception_clause", 
		"exception_handler", "trigger_block", "block", "sql_statement", "execute_immediate", 
		"dynamic_returning_clause", "data_manipulation_language_statements", "cursor_manipulation_statements", 
		"close_statement", "open_statement", "fetch_statement", "open_for_statement", 
		"transaction_control_statements", "set_transaction_command", "set_constraint_command", 
		"commit_statement", "write_clause", "rollback_statement", "savepoint_statement", 
		"explain_statement", "select_statement", "subquery_factoring_clause", 
		"factoring_element", "search_clause", "cycle_clause", "subquery", "subquery_operation_part", 
		"subquery_basic_elements", "query_block", "selected_element", "from_clause", 
		"select_list_elements", "table_ref_list", "table_ref", "table_ref_aux", 
		"join_clause", "join_on_part", "join_using_part", "outer_join_type", "query_partition_clause", 
		"flashback_query_clause", "pivot_clause", "pivot_element", "pivot_for_clause", 
		"pivot_in_clause", "pivot_in_clause_element", "pivot_in_clause_elements", 
		"unpivot_clause", "unpivot_in_clause", "unpivot_in_elements", "hierarchical_query_clause", 
		"start_part", "group_by_clause", "group_by_elements", "rollup_cube_clause", 
		"grouping_sets_clause", "grouping_sets_elements", "having_clause", "model_clause", 
		"cell_reference_options", "return_rows_clause", "reference_model", "main_model", 
		"model_column_clauses", "model_column_partition_part", "model_column_list", 
		"model_column", "model_rules_clause", "model_rules_part", "model_rules_element", 
		"cell_assignment", "model_iterate_clause", "until_part", "order_by_clause", 
		"order_by_elements", "for_update_clause", "for_update_of_part", "for_update_options", 
		"update_statement", "update_set_clause", "column_based_update_set_clause", 
		"delete_statement", "insert_statement", "single_table_insert", "multi_table_insert", 
		"multi_table_element", "conditional_insert_clause", "conditional_insert_when_part", 
		"conditional_insert_else_part", "insert_into_clause", "values_clause", 
		"merge_statement", "merge_update_clause", "merge_element", "merge_update_delete_part", 
		"merge_insert_clause", "selected_tableview", "lock_table_statement", "wait_nowait_part", 
		"lock_table_element", "lock_mode", "general_table_ref", "static_returning_clause", 
		"error_logging_clause", "error_logging_into_part", "error_logging_reject_part", 
		"dml_table_expression_clause", "table_collection_expression", "subquery_restriction_clause", 
		"sample_clause", "seed_part", "cursor_expression", "expression_list", 
		"condition", "condition_wrapper", "expression", "expression_wrapper", 
		"logical_and_expression", "negated_expression", "equality_expression", 
		"multiset_expression", "multiset_type", "relational_expression", "compound_expression", 
		"like_type", "like_escape_part", "in_elements", "between_elements", "concatenation", 
		"concatenation_wrapper", "additive_expression", "multiply_expression", 
		"datetime_expression", "interval_expression", "model_expression", "model_expression_element", 
		"single_column_for_loop", "for_like_part", "for_increment_decrement_type", 
		"multi_column_for_loop", "unary_expression", "case_statement", "simple_case_statement", 
		"simple_case_when_part", "searched_case_statement", "searched_case_when_part", 
		"case_else_part", "atom", "expression_or_vector", "vector_expr", "quantified_expression", 
		"standard_function", "over_clause_keyword", "within_or_over_clause_keyword", 
		"standard_prediction_function_keyword", "over_clause", "windowing_clause", 
		"windowing_type", "windowing_elements", "using_clause", "using_element", 
		"collect_order_by_part", "within_or_over_part", "cost_matrix_clause", 
		"xml_passing_clause", "xml_attributes_clause", "xml_namespaces_clause", 
		"xml_table_column", "xml_general_default_part", "xml_multiuse_expression_element", 
		"xmlroot_param_version_part", "xmlroot_param_standalone_part", "xmlserialize_param_enconding_part", 
		"xmlserialize_param_version_part", "xmlserialize_param_ident_part", "sql_plus_command", 
		"whenever_command", "set_command", "exit_command", "prompt_command", "show_errors_command", 
		"partition_extension_clause", "column_alias", "table_alias", "alias_quoted_string", 
		"where_clause", "current_of_clause", "into_clause", "xml_column_name", 
		"cost_class_name", "attribute_name", "savepoint_name", "rollback_segment_name", 
		"table_var_name", "schema_name", "routine_name", "package_name", "implementation_type_name", 
		"parameter_name", "reference_model_name", "main_model_name", "aggregate_function_name", 
		"query_name", "constraint_name", "label_name", "type_name", "sequence_name", 
		"exception_name", "function_name", "procedure_name", "trigger_name", "variable_name", 
		"index_name", "cursor_name", "record_name", "collection_name", "link_name", 
		"column_name", "tableview_name", "char_set_name", "keep_clause", "function_argument", 
		"function_argument_analytic", "function_argument_modeling", "respect_or_ignore_nulls", 
		"argument", "type_spec", "datatype", "precision_part", "native_datatype_element", 
		"bind_variable", "general_element", "general_element_part", "table_element", 
		"constant", "numeric", "numeric_negative", "quoted_string", "id", "id_expression", 
		"not_equal_op", "greater_than_or_equals_op", "less_than_or_equals_op", 
		"concatenation_op", "outer_join_sign", "regular_id"
	};

	private static readonly string[] _LiteralNames = {
		null, "'..'", null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, "'.'", null, null, null, null, "'%'", "'&'", "'('", "')'", 
		"'**'", "'*'", "'+'", "'-'", "','", "'/'", "'@'", "':='", null, "':'", 
		"';'", "'<='", "'<'", "'>='", null, "'^'", "'~'", "'!'", "'>'", "'||'", 
		"'|'", "'='", "'['", "']'", "'_'", null, null, null, null, "'all'", "'alter'", 
		"'and'", "'any'", "'as'", "'asc'", "'begin'", "'between'", "'by'", "'case'", 
		"'check'", "'clusters'", "'colauth'", "'compress'", "'connect'", "'connect_by_root'", 
		"'crash'", "'create'", "'current'", "'cursor'", "'date'", "'declare'", 
		"'default'", "'delete'", "'desc'", "'distinct'", "'drop'", "'else'", "'end'", 
		"'exception'", "'exclusive'", "'exists'", "'false'", "'fetch'", "'for'", 
		"'from'", "'goto'", "'grant'", "'group'", "'having'", "'identified'", 
		"'if'", "'in'", "'index'", "'indexes'", "'insert'", "'intersect'", "'into'", 
		"'is'", "'like'", "'lock'", "'minus'", "'mode'", "'nocompress'", "'not'", 
		"'nowait'", "'null'", "'of'", "'on'", "'option'", "'or'", "'order'", "'overlaps'", 
		"'prior'", "'procedure'", "'public'", "'resource'", "'revoke'", "'select'", 
		"'share'", "'size'", "'start'", "'tabauth'", "'table'", "'the'", "'then'", 
		"'to'", "'true'", "'union'", "'unique'", "'update'", "'values'", "'view'", 
		"'views'", "'when'", "'where'", "'with'", "'using'", "'model'", "'elsif'", 
		"'pivot'", "'unpivot'", null, "'@!'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, "A_LETTER", "ADD", "AFTER", "AGENT", "AGGREGATE", "ALL", "ALTER", 
		"ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "ASSOCIATE", "AT", "ATTRIBUTE", 
		"AUDIT", "AUTHID", "AUTO", "AUTOMATIC", "AUTONOMOUS_TRANSACTION", "BATCH", 
		"BEFORE", "BEGIN", "BETWEEN", "BFILE", "BINARY_DOUBLE", "BINARY_FLOAT", 
		"BINARY_INTEGER", "BLOB", "BLOCK", "BODY", "BOOLEAN", "BOTH", "BREADTH", 
		"BULK", "BY", "BYTE", "C_LETTER", "CACHE", "CALL", "CANONICAL", "CASCADE", 
		"CASE", "CAST", "CHAR", "CHAR_CS", "CHARACTER", "CHECK", "CHR", "CLOB", 
		"CLOSE", "CLUSTER", "COLLECT", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", 
		"COMPATIBILITY", "COMPILE", "COMPOUND", "CONNECT", "CONNECT_BY_ROOT", 
		"CONSTANT", "CONSTRAINT", "CONSTRAINTS", "CONSTRUCTOR", "CONTENT", "CONTEXT", 
		"CONTINUE", "CONVERT", "CORRUPT_XID", "CORRUPT_XID_ALL", "COST", "COUNT", 
		"CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_USER", "CURSOR", "CUSTOMDATUM", 
		"CYCLE", "DATA", "DATABASE", "DATE", "DAY", "DB_ROLE_CHANGE", "DBTIMEZONE", 
		"DDL", "DEBUG", "DEC", "DECIMAL", "DECLARE", "DECOMPOSE", "DECREMENT", 
		"DEFAULT", "DEFAULTS", "DEFERRED", "DEFINER", "DELETE", "DEPTH", "DESC", 
		"DETERMINISTIC", "DIMENSION", "DISABLE", "DISASSOCIATE", "DISTINCT", "DOCUMENT", 
		"DOUBLE", "DROP", "DSINTERVAL_UNCONSTRAINED", "EACH", "ELEMENT", "ELSE", 
		"ELSIF", "EMPTY", "ENABLE", "ENCODING", "END", "ENTITYESCAPING", "ERR", 
		"ERRORS", "ESCAPE", "EVALNAME", "EXCEPTION", "EXCEPTION_INIT", "EXCEPTIONS", 
		"EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTERNAL", 
		"EXTRACT", "FAILURE", "FALSE", "FETCH", "FINAL", "FIRST", "FIRST_VALUE", 
		"FLOAT", "FOLLOWING", "FOLLOWS", "FOR", "FORALL", "FORCE", "FROM", "FULL", 
		"FUNCTION", "GOTO", "GRANT", "GROUP", "GROUPING", "HASH", "HAVING", "HIDE", 
		"HOUR", "IF", "IGNORE", "IMMEDIATE", "IN", "INCLUDE", "INCLUDING", "INCREMENT", 
		"INDENT", "INDEX", "INDEXED", "INDICATOR", "INDICES", "INFINITE", "INLINE", 
		"INNER", "INOUT", "INSERT", "INSTANTIABLE", "INSTEAD", "INT", "INTEGER", 
		"INTERSECT", "INTERVAL", "INTO", "INVALIDATE", "IS", "ISOLATION", "ITERATE", 
		"JAVA", "JOIN", "KEEP", "LANGUAGE", "LAST", "LAST_VALUE", "LEADING", "LEFT", 
		"LEVEL", "LIBRARY", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LIMIT", "LOCAL", 
		"LOCK", "LOCKED", "LOG", "LOGOFF", "LOGON", "LONG", "LOOP", "MAIN", "MAP", 
		"MATCHED", "MAXVALUE", "MEASURES", "MEMBER", "MERGE", "MINUS", "MINUTE", 
		"MINVALUE", "MLSLABEL", "MODE", "MODEL", "MODIFY", "MONTH", "MULTISET", 
		"NAME", "NAN", "NATURAL", "NATURALN", "NAV", "NCHAR", "NCHAR_CS", "NCLOB", 
		"NESTED", "NEW", "NO", "NOAUDIT", "NOCACHE", "NOCOPY", "NOCYCLE", "NOENTITYESCAPING", 
		"NOMAXVALUE", "NOMINVALUE", "NONE", "NOORDER", "NOSCHEMACHECK", "NOT", 
		"NOWAIT", "NULL", "NULLS", "NUMBER", "NUMERIC", "NVARCHAR2", "OBJECT", 
		"OF", "OFF", "OID", "OLD", "ON", "ONLY", "OPEN", "OPTION", "OR", "ORADATA", 
		"ORDER", "ORDINALITY", "OSERROR", "OUT", "OUTER", "OVER", "OVERRIDING", 
		"PACKAGE", "PARALLEL_ENABLE", "PARAMETERS", "PARENT", "PARTITION", "PASSING", 
		"PATH", "PERCENT_ROWTYPE", "PERCENT_TYPE", "PIPELINED", "PIVOT", "PLAN", 
		"PLS_INTEGER", "POSITIVE", "POSITIVEN", "PRAGMA", "PRECEDING", "PRECISION", 
		"PRESENT", "PRIOR", "PROCEDURE", "RAISE", "RANGE", "RAW", "READ", "REAL", 
		"RECORD", "REF", "REFERENCE", "REFERENCING", "REJECT", "RELIES_ON", "RENAME", 
		"REPLACE", "RESPECT", "RESTRICT_REFERENCES", "RESULT", "RESULT_CACHE", 
		"RETURN", "RETURNING", "REUSE", "REVERSE", "REVOKE", "RIGHT", "ROLLBACK", 
		"ROLLUP", "ROW", "ROWID", "ROWS", "RULES", "SAMPLE", "SAVE", "SAVEPOINT", 
		"SCHEMA", "SCHEMACHECK", "SCN", "SEARCH", "SECOND", "SEED", "SEGMENT", 
		"SELECT", "SELF", "SEQUENCE", "SEQUENTIAL", "SERIALIZABLE", "SERIALLY_REUSABLE", 
		"SERVERERROR", "SESSIONTIMEZONE", "SET", "SETS", "SETTINGS", "SHARE", 
		"SHOW", "SHUTDOWN", "SIBLINGS", "SIGNTYPE", "SIMPLE_INTEGER", "SINGLE", 
		"SIZE", "SKIP_", "SMALLINT", "SNAPSHOT", "SOME", "SPECIFICATION", "SQLDATA", 
		"SQLERROR", "STANDALONE", "START", "STARTUP", "STATEMENT", "STATEMENT_ID", 
		"STATIC", "STATISTICS", "STRING", "SUBMULTISET", "SUBPARTITION", "SUBSTITUTABLE", 
		"SUBTYPE", "SUCCESS", "SUSPEND", "TABLE", "THE", "THEN", "TIME", "TIMESTAMP", 
		"TIMESTAMP_LTZ_UNCONSTRAINED", "TIMESTAMP_TZ_UNCONSTRAINED", "TIMESTAMP_UNCONSTRAINED", 
		"TIMEZONE_ABBR", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TIMEZONE_REGION", 
		"TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TREAT", "TRIGGER", "TRIM", 
		"TRUE", "TRUNCATE", "TYPE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", "UNLIMITED", 
		"UNPIVOT", "UNTIL", "UPDATE", "UPDATED", "UPSERT", "UROWID", "USE", "USING", 
		"VALIDATE", "VALUE", "VALUES", "VARCHAR", "VARCHAR2", "VARIABLE", "VARRAY", 
		"VARYING", "VERSION", "VERSIONS", "WAIT", "WARNING", "WELLFORMED", "WHEN", 
		"WHENEVER", "WHERE", "WHILE", "WITH", "WITHIN", "WORK", "WRITE", "XML", 
		"XMLAGG", "XMLATTRIBUTES", "XMLCAST", "XMLCOLATTVAL", "XMLELEMENT", "XMLEXISTS", 
		"XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", 
		"XMLSERIALIZE", "XMLTABLE", "YEAR", "YES", "YMINTERVAL_UNCONSTRAINED", 
		"ZONE", "PREDICTION", "PREDICTION_BOUNDS", "PREDICTION_COST", "PREDICTION_DETAILS", 
		"PREDICTION_PROBABILITY", "PREDICTION_SET", "CUME_DIST", "DENSE_RANK", 
		"LISTAGG", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", 
		"AVG", "CORR", "LAG", "LEAD", "MAX", "MEDIAN", "MIN", "NTILE", "RATIO_TO_REPORT", 
		"ROW_NUMBER", "SUM", "VARIANCE", "REGR_", "STDDEV", "VAR_", "COVAR_", 
		"NATIONAL_CHAR_STRING_LIT", "BIT_STRING_LIT", "HEX_STRING_LIT", "DOUBLE_PERIOD", 
		"PERIOD", "UNSIGNED_INTEGER", "APPROXIMATE_NUM_LIT", "CHAR_STRING", "DELIMITED_ID", 
		"PERCENT", "AMPERSAND", "LEFT_PAREN", "RIGHT_PAREN", "DOUBLE_ASTERISK", 
		"ASTERISK", "PLUS_SIGN", "MINUS_SIGN", "COMMA", "SOLIDUS", "AT_SIGN", 
		"ASSIGN_OP", "BINDVAR", "COLON", "SEMICOLON", "LESS_THAN_OR_EQUALS_OP", 
		"LESS_THAN_OP", "GREATER_THAN_OR_EQUALS_OP", "NOT_EQUAL_OP", "CARRET_OPERATOR_PART", 
		"TILDE_OPERATOR_PART", "EXCLAMATION_OPERATOR_PART", "GREATER_THAN_OP", 
		"CONCATENATION_OP", "VERTICAL_BAR", "EQUALS_OP", "LEFT_BRACKET", "RIGHT_BRACKET", 
		"INTRODUCER", "SPACES", "SINGLE_LINE_COMMENT", "MULTI_LINE_COMMENT", "PROMPT", 
		"SQL92_RESERVED_ALL", "SQL92_RESERVED_ALTER", "SQL92_RESERVED_AND", "SQL92_RESERVED_ANY", 
		"SQL92_RESERVED_AS", "SQL92_RESERVED_ASC", "SQL92_RESERVED_BEGIN", "SQL92_RESERVED_BETWEEN", 
		"SQL92_RESERVED_BY", "SQL92_RESERVED_CASE", "SQL92_RESERVED_CHECK", "PLSQL_RESERVED_CLUSTERS", 
		"PLSQL_RESERVED_COLAUTH", "PLSQL_RESERVED_COMPRESS", "SQL92_RESERVED_CONNECT", 
		"PLSQL_NON_RESERVED_CONNECT_BY_ROOT", "PLSQL_RESERVED_CRASH", "SQL92_RESERVED_CREATE", 
		"SQL92_RESERVED_CURRENT", "SQL92_RESERVED_CURSOR", "SQL92_RESERVED_DATE", 
		"SQL92_RESERVED_DECLARE", "SQL92_RESERVED_DEFAULT", "SQL92_RESERVED_DELETE", 
		"SQL92_RESERVED_DESC", "SQL92_RESERVED_DISTINCT", "SQL92_RESERVED_DROP", 
		"SQL92_RESERVED_ELSE", "SQL92_RESERVED_END", "SQL92_RESERVED_EXCEPTION", 
		"PLSQL_RESERVED_EXCLUSIVE", "SQL92_RESERVED_EXISTS", "SQL92_RESERVED_FALSE", 
		"SQL92_RESERVED_FETCH", "SQL92_RESERVED_FOR", "SQL92_RESERVED_FROM", "SQL92_RESERVED_GOTO", 
		"SQL92_RESERVED_GRANT", "SQL92_RESERVED_GROUP", "SQL92_RESERVED_HAVING", 
		"PLSQL_RESERVED_IDENTIFIED", "PLSQL_RESERVED_IF", "SQL92_RESERVED_IN", 
		"PLSQL_RESERVED_INDEX", "PLSQL_RESERVED_INDEXES", "SQL92_RESERVED_INSERT", 
		"SQL92_RESERVED_INTERSECT", "SQL92_RESERVED_INTO", "SQL92_RESERVED_IS", 
		"SQL92_RESERVED_LIKE", "PLSQL_RESERVED_LOCK", "PLSQL_RESERVED_MINUS", 
		"PLSQL_RESERVED_MODE", "PLSQL_RESERVED_NOCOMPRESS", "SQL92_RESERVED_NOT", 
		"PLSQL_RESERVED_NOWAIT", "SQL92_RESERVED_NULL", "SQL92_RESERVED_OF", "SQL92_RESERVED_ON", 
		"SQL92_RESERVED_OPTION", "SQL92_RESERVED_OR", "SQL92_RESERVED_ORDER", 
		"SQL92_RESERVED_OVERLAPS", "SQL92_RESERVED_PRIOR", "SQL92_RESERVED_PROCEDURE", 
		"SQL92_RESERVED_PUBLIC", "PLSQL_RESERVED_RESOURCE", "SQL92_RESERVED_REVOKE", 
		"SQL92_RESERVED_SELECT", "PLSQL_RESERVED_SHARE", "SQL92_RESERVED_SIZE", 
		"PLSQL_RESERVED_START", "PLSQL_RESERVED_TABAUTH", "SQL92_RESERVED_TABLE", 
		"SQL92_RESERVED_THE", "SQL92_RESERVED_THEN", "SQL92_RESERVED_TO", "SQL92_RESERVED_TRUE", 
		"SQL92_RESERVED_UNION", "SQL92_RESERVED_UNIQUE", "SQL92_RESERVED_UPDATE", 
		"SQL92_RESERVED_VALUES", "SQL92_RESERVED_VIEW", "PLSQL_RESERVED_VIEWS", 
		"SQL92_RESERVED_WHEN", "SQL92_RESERVED_WHERE", "SQL92_RESERVED_WITH", 
		"PLSQL_NON_RESERVED_USING", "PLSQL_NON_RESERVED_MODEL", "PLSQL_NON_RESERVED_ELSIF", 
		"PLSQL_NON_RESERVED_PIVOT", "PLSQL_NON_RESERVED_UNPIVOT", "REGULAR_ID", 
		"ZV"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "plsql.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public plsqlParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class Swallow_to_semiContext : ParserRuleContext {
		public Swallow_to_semiContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_swallow_to_semi; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSwallow_to_semi(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSwallow_to_semi(this);
		}
	}

	[RuleVersion(0)]
	public Swallow_to_semiContext swallow_to_semi() {
		Swallow_to_semiContext _localctx = new Swallow_to_semiContext(Context, State);
		EnterRule(_localctx, 0, RULE_swallow_to_semi);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 761;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 760;
				_la = TokenStream.La(1);
				if ( _la <= 0 || (_la==SEMICOLON) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				}
				State = 763;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__0) | (1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND) | (1L << CONNECT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (END - 64)) | (1L << (ENTITYESCAPING - 64)) | (1L << (ERR - 64)) | (1L << (ERRORS - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVALNAME - 64)) | (1L << (EXCEPTION - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)) | (1L << (INTO - 128)) | (1L << (INVALIDATE - 128)) | (1L << (IS - 128)) | (1L << (ISOLATION - 128)) | (1L << (ITERATE - 128)) | (1L << (JAVA - 128)) | (1L << (JOIN - 128)) | (1L << (KEEP - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)) | (1L << (NONE - 192)) | (1L << (NOORDER - 192)) | (1L << (NOSCHEMACHECK - 192)) | (1L << (NOT - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (NULLS - 192)) | (1L << (NUMBER - 192)) | (1L << (NUMERIC - 192)) | (1L << (NVARCHAR2 - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PERCENT_ROWTYPE - 256)) | (1L << (PERCENT_TYPE - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)) | (1L << (RELIES_ON - 256)) | (1L << (RENAME - 256)) | (1L << (REPLACE - 256)) | (1L << (RESPECT - 256)) | (1L << (RESTRICT_REFERENCES - 256)) | (1L << (RESULT - 256)) | (1L << (RESULT_CACHE - 256)) | (1L << (RETURN - 256)) | (1L << (RETURNING - 256)) | (1L << (REUSE - 256)) | (1L << (REVERSE - 256)) | (1L << (REVOKE - 256)) | (1L << (RIGHT - 256)) | (1L << (ROLLBACK - 256)) | (1L << (ROLLUP - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)) | (1L << (SUBMULTISET - 320)) | (1L << (SUBPARTITION - 320)) | (1L << (SUBSTITUTABLE - 320)) | (1L << (SUBTYPE - 320)) | (1L << (SUCCESS - 320)) | (1L << (SUSPEND - 320)) | (1L << (TABLE - 320)) | (1L << (THE - 320)) | (1L << (THEN - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_UNCONSTRAINED - 320)) | (1L << (TIMEZONE_ABBR - 320)) | (1L << (TIMEZONE_HOUR - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)) | (1L << (XML - 384)) | (1L << (XMLAGG - 384)) | (1L << (XMLATTRIBUTES - 384)) | (1L << (XMLCAST - 384)) | (1L << (XMLCOLATTVAL - 384)) | (1L << (XMLELEMENT - 384)) | (1L << (XMLEXISTS - 384)) | (1L << (XMLFOREST - 384)) | (1L << (XMLNAMESPACES - 384)) | (1L << (XMLPARSE - 384)) | (1L << (XMLPI - 384)) | (1L << (XMLQUERY - 384)) | (1L << (XMLROOT - 384)) | (1L << (XMLSERIALIZE - 384)) | (1L << (XMLTABLE - 384)) | (1L << (YEAR - 384)) | (1L << (YES - 384)) | (1L << (YMINTERVAL_UNCONSTRAINED - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (BIT_STRING_LIT - 448)) | (1L << (HEX_STRING_LIT - 448)) | (1L << (DOUBLE_PERIOD - 448)) | (1L << (PERIOD - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (PERCENT - 448)) | (1L << (AMPERSAND - 448)) | (1L << (LEFT_PAREN - 448)) | (1L << (RIGHT_PAREN - 448)) | (1L << (DOUBLE_ASTERISK - 448)) | (1L << (ASTERISK - 448)) | (1L << (PLUS_SIGN - 448)) | (1L << (MINUS_SIGN - 448)) | (1L << (COMMA - 448)) | (1L << (SOLIDUS - 448)) | (1L << (AT_SIGN - 448)) | (1L << (ASSIGN_OP - 448)) | (1L << (BINDVAR - 448)) | (1L << (COLON - 448)) | (1L << (LESS_THAN_OR_EQUALS_OP - 448)) | (1L << (LESS_THAN_OP - 448)) | (1L << (GREATER_THAN_OR_EQUALS_OP - 448)) | (1L << (NOT_EQUAL_OP - 448)) | (1L << (CARRET_OPERATOR_PART - 448)) | (1L << (TILDE_OPERATOR_PART - 448)) | (1L << (EXCLAMATION_OPERATOR_PART - 448)) | (1L << (GREATER_THAN_OP - 448)) | (1L << (CONCATENATION_OP - 448)) | (1L << (VERTICAL_BAR - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (EQUALS_OP - 512)) | (1L << (LEFT_BRACKET - 512)) | (1L << (RIGHT_BRACKET - 512)) | (1L << (INTRODUCER - 512)) | (1L << (SPACES - 512)) | (1L << (SINGLE_LINE_COMMENT - 512)) | (1L << (MULTI_LINE_COMMENT - 512)) | (1L << (PROMPT - 512)) | (1L << (SQL92_RESERVED_ALL - 512)) | (1L << (SQL92_RESERVED_ALTER - 512)) | (1L << (SQL92_RESERVED_AND - 512)) | (1L << (SQL92_RESERVED_ANY - 512)) | (1L << (SQL92_RESERVED_AS - 512)) | (1L << (SQL92_RESERVED_ASC - 512)) | (1L << (SQL92_RESERVED_BEGIN - 512)) | (1L << (SQL92_RESERVED_BETWEEN - 512)) | (1L << (SQL92_RESERVED_BY - 512)) | (1L << (SQL92_RESERVED_CASE - 512)) | (1L << (SQL92_RESERVED_CHECK - 512)) | (1L << (PLSQL_RESERVED_CLUSTERS - 512)) | (1L << (PLSQL_RESERVED_COLAUTH - 512)) | (1L << (PLSQL_RESERVED_COMPRESS - 512)) | (1L << (SQL92_RESERVED_CONNECT - 512)) | (1L << (PLSQL_NON_RESERVED_CONNECT_BY_ROOT - 512)) | (1L << (PLSQL_RESERVED_CRASH - 512)) | (1L << (SQL92_RESERVED_CREATE - 512)) | (1L << (SQL92_RESERVED_CURRENT - 512)) | (1L << (SQL92_RESERVED_CURSOR - 512)) | (1L << (SQL92_RESERVED_DATE - 512)) | (1L << (SQL92_RESERVED_DECLARE - 512)) | (1L << (SQL92_RESERVED_DEFAULT - 512)) | (1L << (SQL92_RESERVED_DELETE - 512)) | (1L << (SQL92_RESERVED_DESC - 512)) | (1L << (SQL92_RESERVED_DISTINCT - 512)) | (1L << (SQL92_RESERVED_DROP - 512)) | (1L << (SQL92_RESERVED_ELSE - 512)) | (1L << (SQL92_RESERVED_END - 512)) | (1L << (SQL92_RESERVED_EXCEPTION - 512)) | (1L << (PLSQL_RESERVED_EXCLUSIVE - 512)) | (1L << (SQL92_RESERVED_EXISTS - 512)) | (1L << (SQL92_RESERVED_FALSE - 512)) | (1L << (SQL92_RESERVED_FETCH - 512)) | (1L << (SQL92_RESERVED_FOR - 512)) | (1L << (SQL92_RESERVED_FROM - 512)) | (1L << (SQL92_RESERVED_GOTO - 512)) | (1L << (SQL92_RESERVED_GRANT - 512)) | (1L << (SQL92_RESERVED_GROUP - 512)) | (1L << (SQL92_RESERVED_HAVING - 512)) | (1L << (PLSQL_RESERVED_IDENTIFIED - 512)) | (1L << (PLSQL_RESERVED_IF - 512)) | (1L << (SQL92_RESERVED_IN - 512)) | (1L << (PLSQL_RESERVED_INDEX - 512)) | (1L << (PLSQL_RESERVED_INDEXES - 512)) | (1L << (SQL92_RESERVED_INSERT - 512)) | (1L << (SQL92_RESERVED_INTERSECT - 512)) | (1L << (SQL92_RESERVED_INTO - 512)) | (1L << (SQL92_RESERVED_IS - 512)) | (1L << (SQL92_RESERVED_LIKE - 512)) | (1L << (PLSQL_RESERVED_LOCK - 512)) | (1L << (PLSQL_RESERVED_MINUS - 512)) | (1L << (PLSQL_RESERVED_MODE - 512)) | (1L << (PLSQL_RESERVED_NOCOMPRESS - 512)) | (1L << (SQL92_RESERVED_NOT - 512)) | (1L << (PLSQL_RESERVED_NOWAIT - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (SQL92_RESERVED_NULL - 576)) | (1L << (SQL92_RESERVED_OF - 576)) | (1L << (SQL92_RESERVED_ON - 576)) | (1L << (SQL92_RESERVED_OPTION - 576)) | (1L << (SQL92_RESERVED_OR - 576)) | (1L << (SQL92_RESERVED_ORDER - 576)) | (1L << (SQL92_RESERVED_OVERLAPS - 576)) | (1L << (SQL92_RESERVED_PRIOR - 576)) | (1L << (SQL92_RESERVED_PROCEDURE - 576)) | (1L << (SQL92_RESERVED_PUBLIC - 576)) | (1L << (PLSQL_RESERVED_RESOURCE - 576)) | (1L << (SQL92_RESERVED_REVOKE - 576)) | (1L << (SQL92_RESERVED_SELECT - 576)) | (1L << (PLSQL_RESERVED_SHARE - 576)) | (1L << (SQL92_RESERVED_SIZE - 576)) | (1L << (PLSQL_RESERVED_START - 576)) | (1L << (PLSQL_RESERVED_TABAUTH - 576)) | (1L << (SQL92_RESERVED_TABLE - 576)) | (1L << (SQL92_RESERVED_THE - 576)) | (1L << (SQL92_RESERVED_THEN - 576)) | (1L << (SQL92_RESERVED_TO - 576)) | (1L << (SQL92_RESERVED_TRUE - 576)) | (1L << (SQL92_RESERVED_UNION - 576)) | (1L << (SQL92_RESERVED_UNIQUE - 576)) | (1L << (SQL92_RESERVED_UPDATE - 576)) | (1L << (SQL92_RESERVED_VALUES - 576)) | (1L << (SQL92_RESERVED_VIEW - 576)) | (1L << (PLSQL_RESERVED_VIEWS - 576)) | (1L << (SQL92_RESERVED_WHEN - 576)) | (1L << (SQL92_RESERVED_WHERE - 576)) | (1L << (SQL92_RESERVED_WITH - 576)) | (1L << (PLSQL_NON_RESERVED_USING - 576)) | (1L << (PLSQL_NON_RESERVED_MODEL - 576)) | (1L << (PLSQL_NON_RESERVED_ELSIF - 576)) | (1L << (PLSQL_NON_RESERVED_PIVOT - 576)) | (1L << (PLSQL_NON_RESERVED_UNPIVOT - 576)) | (1L << (REGULAR_ID - 576)) | (1L << (ZV - 576)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compilation_unitContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(plsqlParser.Eof, 0); }
		public Unit_statementContext[] unit_statement() {
			return GetRuleContexts<Unit_statementContext>();
		}
		public Unit_statementContext unit_statement(int i) {
			return GetRuleContext<Unit_statementContext>(i);
		}
		public Compilation_unitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compilation_unit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompilation_unit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompilation_unit(this);
		}
	}

	[RuleVersion(0)]
	public Compilation_unitContext compilation_unit() {
		Compilation_unitContext _localctx = new Compilation_unitContext(Context, State);
		EnterRule(_localctx, 2, RULE_compilation_unit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 768;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==ALTER || ((((_la - 77)) & ~0x3f) == 0 && ((1L << (_la - 77)) & ((1L << (CREATE - 77)) | (1L << (DELETE - 77)) | (1L << (DROP - 77)) | (1L << (EXPLAIN - 77)))) != 0) || ((((_la - 152)) & ~0x3f) == 0 && ((1L << (_la - 152)) & ((1L << (FUNCTION - 152)) | (1L << (INSERT - 152)) | (1L << (LOCK - 152)))) != 0) || _la==MERGE || _la==PROCEDURE || _la==SELECT || _la==UPDATE || _la==WITH || _la==LEFT_PAREN) {
				{
				{
				State = 765; unit_statement();
				}
				}
				State = 770;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 771; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_scriptContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(plsqlParser.Eof, 0); }
		public Unit_statementContext[] unit_statement() {
			return GetRuleContexts<Unit_statementContext>();
		}
		public Unit_statementContext unit_statement(int i) {
			return GetRuleContext<Unit_statementContext>(i);
		}
		public Sql_plus_commandContext[] sql_plus_command() {
			return GetRuleContexts<Sql_plus_commandContext>();
		}
		public Sql_plus_commandContext sql_plus_command(int i) {
			return GetRuleContext<Sql_plus_commandContext>(i);
		}
		public Sql_scriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_script; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSql_script(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSql_script(this);
		}
	}

	[RuleVersion(0)]
	public Sql_scriptContext sql_script() {
		Sql_scriptContext _localctx = new Sql_scriptContext(Context, State);
		EnterRule(_localctx, 4, RULE_sql_script);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 777;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==ALTER || ((((_la - 77)) & ~0x3f) == 0 && ((1L << (_la - 77)) & ((1L << (CREATE - 77)) | (1L << (DELETE - 77)) | (1L << (DROP - 77)) | (1L << (EXIT - 77)) | (1L << (EXPLAIN - 77)))) != 0) || ((((_la - 152)) & ~0x3f) == 0 && ((1L << (_la - 152)) & ((1L << (FUNCTION - 152)) | (1L << (INSERT - 152)) | (1L << (LOCK - 152)))) != 0) || _la==MERGE || ((((_la - 294)) & ~0x3f) == 0 && ((1L << (_la - 294)) & ((1L << (PROCEDURE - 294)) | (1L << (SELECT - 294)) | (1L << (SET - 294)) | (1L << (SHOW - 294)))) != 0) || ((((_la - 403)) & ~0x3f) == 0 && ((1L << (_la - 403)) & ((1L << (UPDATE - 403)) | (1L << (WHENEVER - 403)) | (1L << (WITH - 403)))) != 0) || ((((_la - 489)) & ~0x3f) == 0 && ((1L << (_la - 489)) & ((1L << (LEFT_PAREN - 489)) | (1L << (SOLIDUS - 489)) | (1L << (PROMPT - 489)))) != 0)) {
				{
				State = 775;
				switch (TokenStream.La(1)) {
				case ALTER:
				case CREATE:
				case DELETE:
				case DROP:
				case EXPLAIN:
				case FUNCTION:
				case INSERT:
				case LOCK:
				case MERGE:
				case PROCEDURE:
				case SELECT:
				case UPDATE:
				case WITH:
				case LEFT_PAREN:
					{
					State = 773; unit_statement();
					}
					break;
				case EXIT:
				case SET:
				case SHOW:
				case WHENEVER:
				case SOLIDUS:
				case PROMPT:
					{
					State = 774; sql_plus_command();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 779;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 780; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unit_statementContext : ParserRuleContext {
		public Alter_functionContext alter_function() {
			return GetRuleContext<Alter_functionContext>(0);
		}
		public Alter_packageContext alter_package() {
			return GetRuleContext<Alter_packageContext>(0);
		}
		public Alter_procedureContext alter_procedure() {
			return GetRuleContext<Alter_procedureContext>(0);
		}
		public Alter_sequenceContext alter_sequence() {
			return GetRuleContext<Alter_sequenceContext>(0);
		}
		public Alter_triggerContext alter_trigger() {
			return GetRuleContext<Alter_triggerContext>(0);
		}
		public Alter_typeContext alter_type() {
			return GetRuleContext<Alter_typeContext>(0);
		}
		public Create_function_bodyContext create_function_body() {
			return GetRuleContext<Create_function_bodyContext>(0);
		}
		public Create_procedure_bodyContext create_procedure_body() {
			return GetRuleContext<Create_procedure_bodyContext>(0);
		}
		public Create_packageContext create_package() {
			return GetRuleContext<Create_packageContext>(0);
		}
		public Create_sequenceContext create_sequence() {
			return GetRuleContext<Create_sequenceContext>(0);
		}
		public Create_triggerContext create_trigger() {
			return GetRuleContext<Create_triggerContext>(0);
		}
		public Create_typeContext create_type() {
			return GetRuleContext<Create_typeContext>(0);
		}
		public Drop_functionContext drop_function() {
			return GetRuleContext<Drop_functionContext>(0);
		}
		public Drop_packageContext drop_package() {
			return GetRuleContext<Drop_packageContext>(0);
		}
		public Drop_procedureContext drop_procedure() {
			return GetRuleContext<Drop_procedureContext>(0);
		}
		public Drop_sequenceContext drop_sequence() {
			return GetRuleContext<Drop_sequenceContext>(0);
		}
		public Drop_triggerContext drop_trigger() {
			return GetRuleContext<Drop_triggerContext>(0);
		}
		public Drop_typeContext drop_type() {
			return GetRuleContext<Drop_typeContext>(0);
		}
		public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
			return GetRuleContext<Data_manipulation_language_statementsContext>(0);
		}
		public Unit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnit_statement(this);
		}
	}

	[RuleVersion(0)]
	public Unit_statementContext unit_statement() {
		Unit_statementContext _localctx = new Unit_statementContext(Context, State);
		EnterRule(_localctx, 6, RULE_unit_statement);
		try {
			State = 801;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 782; alter_function();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 783; alter_package();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 784; alter_procedure();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 785; alter_sequence();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 786; alter_trigger();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 787; alter_type();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 788; create_function_body();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 789; create_procedure_body();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 790; create_package();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 791; create_sequence();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 792; create_trigger();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 793; create_type();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 794; drop_function();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 795; drop_package();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 796; drop_procedure();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 797; drop_sequence();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 798; drop_trigger();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 799; drop_type();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 800; data_manipulation_language_statements();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_functionContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public Drop_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_function(this);
		}
	}

	[RuleVersion(0)]
	public Drop_functionContext drop_function() {
		Drop_functionContext _localctx = new Drop_functionContext(Context, State);
		EnterRule(_localctx, 8, RULE_drop_function);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 803; Match(DROP);
			State = 804; Match(FUNCTION);
			State = 805; function_name();
			State = 806; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_functionContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public Alter_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_function(this);
		}
	}

	[RuleVersion(0)]
	public Alter_functionContext alter_function() {
		Alter_functionContext _localctx = new Alter_functionContext(Context, State);
		EnterRule(_localctx, 10, RULE_alter_function);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 808; Match(ALTER);
			State = 809; Match(FUNCTION);
			State = 810; function_name();
			State = 811; Match(COMPILE);
			State = 813;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				{
				State = 812; Match(DEBUG);
				}
				break;
			}
			State = 818;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 815; compiler_parameters_clause();
					}
					} 
				}
				State = 820;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
			}
			State = 823;
			_la = TokenStream.La(1);
			if (_la==REUSE) {
				{
				State = 821; Match(REUSE);
				State = 822; Match(SETTINGS);
				}
			}

			State = 825; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_function_bodyContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public Implementation_type_nameContext implementation_type_name() {
			return GetRuleContext<Implementation_type_nameContext>(0);
		}
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Invoker_rights_clauseContext[] invoker_rights_clause() {
			return GetRuleContexts<Invoker_rights_clauseContext>();
		}
		public Invoker_rights_clauseContext invoker_rights_clause(int i) {
			return GetRuleContext<Invoker_rights_clauseContext>(i);
		}
		public Parallel_enable_clauseContext[] parallel_enable_clause() {
			return GetRuleContexts<Parallel_enable_clauseContext>();
		}
		public Parallel_enable_clauseContext parallel_enable_clause(int i) {
			return GetRuleContext<Parallel_enable_clauseContext>(i);
		}
		public Result_cache_clauseContext[] result_cache_clause() {
			return GetRuleContexts<Result_cache_clauseContext>();
		}
		public Result_cache_clauseContext result_cache_clause(int i) {
			return GetRuleContext<Result_cache_clauseContext>(i);
		}
		public ITerminalNode[] DETERMINISTIC() { return GetTokens(plsqlParser.DETERMINISTIC); }
		public ITerminalNode DETERMINISTIC(int i) {
			return GetToken(plsqlParser.DETERMINISTIC, i);
		}
		public ITerminalNode PIPELINED() { return GetToken(plsqlParser.PIPELINED, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(plsqlParser.AGGREGATE, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Create_function_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_function_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_function_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_function_body(this);
		}
	}

	[RuleVersion(0)]
	public Create_function_bodyContext create_function_body() {
		Create_function_bodyContext _localctx = new Create_function_bodyContext(Context, State);
		EnterRule(_localctx, 12, RULE_create_function_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 832;
			_la = TokenStream.La(1);
			if (_la==CREATE) {
				{
				State = 827; Match(CREATE);
				State = 830;
				_la = TokenStream.La(1);
				if (_la==OR) {
					{
					State = 828; Match(OR);
					State = 829; Match(REPLACE);
					}
				}

				}
			}

			State = 834; Match(FUNCTION);
			State = 835; function_name();
			State = 847;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 836; Match(LEFT_PAREN);
				State = 837; parameter();
				State = 842;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 838; Match(COMMA);
					State = 839; parameter();
					}
					}
					State = 844;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 845; Match(RIGHT_PAREN);
				}
			}

			State = 849; Match(RETURN);
			State = 850; type_spec();
			State = 857;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==AUTHID || _la==DETERMINISTIC || _la==PARALLEL_ENABLE || _la==RESULT_CACHE) {
				{
				State = 855;
				switch (TokenStream.La(1)) {
				case AUTHID:
					{
					State = 851; invoker_rights_clause();
					}
					break;
				case PARALLEL_ENABLE:
					{
					State = 852; parallel_enable_clause();
					}
					break;
				case RESULT_CACHE:
					{
					State = 853; result_cache_clause();
					}
					break;
				case DETERMINISTIC:
					{
					State = 854; Match(DETERMINISTIC);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 859;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 880;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,18,Context) ) {
			case 1:
				{
				{
				State = 861;
				_la = TokenStream.La(1);
				if (_la==PIPELINED) {
					{
					State = 860; Match(PIPELINED);
					}
				}

				State = 863;
				_la = TokenStream.La(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 875;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
				case 1:
					{
					State = 865;
					_la = TokenStream.La(1);
					if (_la==DECLARE) {
						{
						State = 864; Match(DECLARE);
						}
					}

					State = 870;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
					while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						{
						State = 867; declare_spec();
						}
						}
						State = 872;
						ErrorHandler.Sync(this);
						_la = TokenStream.La(1);
					}
					State = 873; body();
					}
					break;
				case 2:
					{
					State = 874; call_spec();
					}
					break;
				}
				}
				}
				break;
			case 2:
				{
				State = 877;
				_la = TokenStream.La(1);
				if ( !(_la==AGGREGATE || _la==PIPELINED) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 878; Match(USING);
				State = 879; implementation_type_name();
				}
				break;
			}
			State = 882; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parallel_enable_clauseContext : ParserRuleContext {
		public ITerminalNode PARALLEL_ENABLE() { return GetToken(plsqlParser.PARALLEL_ENABLE, 0); }
		public Partition_by_clauseContext partition_by_clause() {
			return GetRuleContext<Partition_by_clauseContext>(0);
		}
		public Parallel_enable_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallel_enable_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterParallel_enable_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitParallel_enable_clause(this);
		}
	}

	[RuleVersion(0)]
	public Parallel_enable_clauseContext parallel_enable_clause() {
		Parallel_enable_clauseContext _localctx = new Parallel_enable_clauseContext(Context, State);
		EnterRule(_localctx, 14, RULE_parallel_enable_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 884; Match(PARALLEL_ENABLE);
			State = 886;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 885; partition_by_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_by_clauseContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public ITerminalNode ANY() { return GetToken(plsqlParser.ANY, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode HASH() { return GetToken(plsqlParser.HASH, 0); }
		public ITerminalNode RANGE() { return GetToken(plsqlParser.RANGE, 0); }
		public Streaming_clauseContext streaming_clause() {
			return GetRuleContext<Streaming_clauseContext>(0);
		}
		public Partition_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPartition_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPartition_by_clause(this);
		}
	}

	[RuleVersion(0)]
	public Partition_by_clauseContext partition_by_clause() {
		Partition_by_clauseContext _localctx = new Partition_by_clauseContext(Context, State);
		EnterRule(_localctx, 16, RULE_partition_by_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 888; Match(LEFT_PAREN);
			State = 889; Match(PARTITION);
			State = 890; expression();
			State = 891; Match(BY);
			State = 905;
			switch (TokenStream.La(1)) {
			case ANY:
				{
				State = 892; Match(ANY);
				}
				break;
			case HASH:
			case RANGE:
				{
				State = 893;
				_la = TokenStream.La(1);
				if ( !(_la==HASH || _la==RANGE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 894; Match(LEFT_PAREN);
				State = 895; column_name();
				State = 900;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 896; Match(COMMA);
					State = 897; column_name();
					}
					}
					State = 902;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 903; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 908;
			_la = TokenStream.La(1);
			if (_la==CLUSTER || _la==ORDER) {
				{
				State = 907; streaming_clause();
				}
			}

			State = 910; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Result_cache_clauseContext : ParserRuleContext {
		public ITerminalNode RESULT_CACHE() { return GetToken(plsqlParser.RESULT_CACHE, 0); }
		public Relies_on_partContext relies_on_part() {
			return GetRuleContext<Relies_on_partContext>(0);
		}
		public Result_cache_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_result_cache_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterResult_cache_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitResult_cache_clause(this);
		}
	}

	[RuleVersion(0)]
	public Result_cache_clauseContext result_cache_clause() {
		Result_cache_clauseContext _localctx = new Result_cache_clauseContext(Context, State);
		EnterRule(_localctx, 18, RULE_result_cache_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 912; Match(RESULT_CACHE);
			State = 914;
			_la = TokenStream.La(1);
			if (_la==RELIES_ON) {
				{
				State = 913; relies_on_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relies_on_partContext : ParserRuleContext {
		public ITerminalNode RELIES_ON() { return GetToken(plsqlParser.RELIES_ON, 0); }
		public Tableview_nameContext[] tableview_name() {
			return GetRuleContexts<Tableview_nameContext>();
		}
		public Tableview_nameContext tableview_name(int i) {
			return GetRuleContext<Tableview_nameContext>(i);
		}
		public Relies_on_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relies_on_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRelies_on_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRelies_on_part(this);
		}
	}

	[RuleVersion(0)]
	public Relies_on_partContext relies_on_part() {
		Relies_on_partContext _localctx = new Relies_on_partContext(Context, State);
		EnterRule(_localctx, 20, RULE_relies_on_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 916; Match(RELIES_ON);
			State = 917; Match(LEFT_PAREN);
			State = 918; tableview_name();
			State = 923;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 919; Match(COMMA);
				State = 920; tableview_name();
				}
				}
				State = 925;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 926; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Streaming_clauseContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public ITerminalNode CLUSTER() { return GetToken(plsqlParser.CLUSTER, 0); }
		public Streaming_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_streaming_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStreaming_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStreaming_clause(this);
		}
	}

	[RuleVersion(0)]
	public Streaming_clauseContext streaming_clause() {
		Streaming_clauseContext _localctx = new Streaming_clauseContext(Context, State);
		EnterRule(_localctx, 22, RULE_streaming_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 928;
			_la = TokenStream.La(1);
			if ( !(_la==CLUSTER || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 929; expression();
			State = 930; Match(BY);
			State = 931; Match(LEFT_PAREN);
			State = 932; column_name();
			State = 937;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 933; Match(COMMA);
				State = 934; column_name();
				}
				}
				State = 939;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 940; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_packageContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode PACKAGE() { return GetToken(plsqlParser.PACKAGE, 0); }
		public Package_nameContext package_name() {
			return GetRuleContext<Package_nameContext>(0);
		}
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public Drop_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_package(this);
		}
	}

	[RuleVersion(0)]
	public Drop_packageContext drop_package() {
		Drop_packageContext _localctx = new Drop_packageContext(Context, State);
		EnterRule(_localctx, 24, RULE_drop_package);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 942; Match(DROP);
			State = 943; Match(PACKAGE);
			State = 945;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				{
				State = 944; Match(BODY);
				}
				break;
			}
			State = 947; package_name();
			State = 948; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_packageContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode[] PACKAGE() { return GetTokens(plsqlParser.PACKAGE); }
		public ITerminalNode PACKAGE(int i) {
			return GetToken(plsqlParser.PACKAGE, i);
		}
		public Package_nameContext package_name() {
			return GetRuleContext<Package_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(plsqlParser.SPECIFICATION, 0); }
		public Alter_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_package(this);
		}
	}

	[RuleVersion(0)]
	public Alter_packageContext alter_package() {
		Alter_packageContext _localctx = new Alter_packageContext(Context, State);
		EnterRule(_localctx, 26, RULE_alter_package);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 950; Match(ALTER);
			State = 951; Match(PACKAGE);
			State = 952; package_name();
			State = 953; Match(COMPILE);
			State = 955;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
			case 1:
				{
				State = 954; Match(DEBUG);
				}
				break;
			}
			State = 958;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,28,Context) ) {
			case 1:
				{
				State = 957;
				_la = TokenStream.La(1);
				if ( !(_la==BODY || _la==PACKAGE || _la==SPECIFICATION) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			}
			State = 963;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 960; compiler_parameters_clause();
					}
					} 
				}
				State = 965;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,29,Context);
			}
			State = 968;
			_la = TokenStream.La(1);
			if (_la==REUSE) {
				{
				State = 966; Match(REUSE);
				State = 967; Match(SETTINGS);
				}
			}

			State = 970; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_packageContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode PACKAGE() { return GetToken(plsqlParser.PACKAGE, 0); }
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public Package_specContext package_spec() {
			return GetRuleContext<Package_specContext>(0);
		}
		public Package_bodyContext package_body() {
			return GetRuleContext<Package_bodyContext>(0);
		}
		public Create_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_package(this);
		}
	}

	[RuleVersion(0)]
	public Create_packageContext create_package() {
		Create_packageContext _localctx = new Create_packageContext(Context, State);
		EnterRule(_localctx, 28, RULE_create_package);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 972; Match(CREATE);
			State = 975;
			_la = TokenStream.La(1);
			if (_la==OR) {
				{
				State = 973; Match(OR);
				State = 974; Match(REPLACE);
				}
			}

			State = 977; Match(PACKAGE);
			State = 980;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,32,Context) ) {
			case 1:
				{
				State = 978; package_spec();
				}
				break;
			case 2:
				{
				State = 979; package_body();
				}
				break;
			}
			State = 982; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_bodyContext : ParserRuleContext {
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public Package_nameContext[] package_name() {
			return GetRuleContexts<Package_nameContext>();
		}
		public Package_nameContext package_name(int i) {
			return GetRuleContext<Package_nameContext>(i);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public ITerminalNode BEGIN() { return GetToken(plsqlParser.BEGIN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Package_obj_bodyContext[] package_obj_body() {
			return GetRuleContexts<Package_obj_bodyContext>();
		}
		public Package_obj_bodyContext package_obj_body(int i) {
			return GetRuleContext<Package_obj_bodyContext>(i);
		}
		public Package_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPackage_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPackage_body(this);
		}
	}

	[RuleVersion(0)]
	public Package_bodyContext package_body() {
		Package_bodyContext _localctx = new Package_bodyContext(Context, State);
		EnterRule(_localctx, 30, RULE_package_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 984; Match(BODY);
			State = 985; package_name();
			State = 986;
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 990;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				{
				State = 987; package_obj_body();
				}
				}
				State = 992;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 999;
			switch (TokenStream.La(1)) {
			case BEGIN:
				{
				State = 993; Match(BEGIN);
				State = 994; seq_of_statements();
				}
				break;
			case END:
				{
				State = 995; Match(END);
				State = 997;
				_la = TokenStream.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 996; package_name();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_specContext : ParserRuleContext {
		public Package_nameContext[] package_name() {
			return GetRuleContexts<Package_nameContext>();
		}
		public Package_nameContext package_name(int i) {
			return GetRuleContext<Package_nameContext>(i);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Package_obj_specContext[] package_obj_spec() {
			return GetRuleContexts<Package_obj_specContext>();
		}
		public Package_obj_specContext package_obj_spec(int i) {
			return GetRuleContext<Package_obj_specContext>(i);
		}
		public Package_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPackage_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPackage_spec(this);
		}
	}

	[RuleVersion(0)]
	public Package_specContext package_spec() {
		Package_specContext _localctx = new Package_specContext(Context, State);
		EnterRule(_localctx, 32, RULE_package_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1001; package_name();
			State = 1003;
			_la = TokenStream.La(1);
			if (_la==AUTHID) {
				{
				State = 1002; invoker_rights_clause();
				}
			}

			State = 1005;
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1009;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				{
				State = 1006; package_obj_spec();
				}
				}
				State = 1011;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1012; Match(END);
			State = 1014;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 1013; package_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_obj_specContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Record_declarationContext record_declaration() {
			return GetRuleContext<Record_declarationContext>(0);
		}
		public Table_declarationContext table_declaration() {
			return GetRuleContext<Table_declarationContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Package_obj_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_obj_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPackage_obj_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPackage_obj_spec(this);
		}
	}

	[RuleVersion(0)]
	public Package_obj_specContext package_obj_spec() {
		Package_obj_specContext _localctx = new Package_obj_specContext(Context, State);
		EnterRule(_localctx, 34, RULE_package_obj_spec);
		try {
			State = 1025;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,39,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1016; variable_declaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1017; subtype_declaration();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1018; cursor_declaration();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1019; exception_declaration();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1020; pragma_declaration();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1021; record_declaration();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1022; table_declaration();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1023; procedure_spec();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1024; function_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_specContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Procedure_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterProcedure_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitProcedure_spec(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_specContext procedure_spec() {
		Procedure_specContext _localctx = new Procedure_specContext(Context, State);
		EnterRule(_localctx, 36, RULE_procedure_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1027; Match(PROCEDURE);
			State = 1028; procedure_name();
			State = 1040;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1029; Match(LEFT_PAREN);
				State = 1030; parameter();
				State = 1035;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1031; Match(COMMA);
					State = 1032; parameter();
					}
					}
					State = 1037;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1038; Match(RIGHT_PAREN);
				}
			}

			State = 1042; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_specContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode DETERMINISTIC() { return GetToken(plsqlParser.DETERMINISTIC, 0); }
		public ITerminalNode RESULT_CACHE() { return GetToken(plsqlParser.RESULT_CACHE, 0); }
		public Function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_spec(this);
		}
	}

	[RuleVersion(0)]
	public Function_specContext function_spec() {
		Function_specContext _localctx = new Function_specContext(Context, State);
		EnterRule(_localctx, 38, RULE_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1044; Match(FUNCTION);
			State = 1045; function_name();
			State = 1057;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1046; Match(LEFT_PAREN);
				State = 1047; parameter();
				State = 1052;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1048; Match(COMMA);
					State = 1049; parameter();
					}
					}
					State = 1054;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1055; Match(RIGHT_PAREN);
				}
			}

			State = 1059; Match(RETURN);
			State = 1060; type_spec();
			State = 1062;
			_la = TokenStream.La(1);
			if (_la==DETERMINISTIC) {
				{
				State = 1061; Match(DETERMINISTIC);
				}
			}

			State = 1065;
			_la = TokenStream.La(1);
			if (_la==RESULT_CACHE) {
				{
				State = 1064; Match(RESULT_CACHE);
				}
			}

			State = 1067; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_obj_bodyContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Record_declarationContext record_declaration() {
			return GetRuleContext<Record_declarationContext>(0);
		}
		public Table_declarationContext table_declaration() {
			return GetRuleContext<Table_declarationContext>(0);
		}
		public Create_procedure_bodyContext create_procedure_body() {
			return GetRuleContext<Create_procedure_bodyContext>(0);
		}
		public Create_function_bodyContext create_function_body() {
			return GetRuleContext<Create_function_bodyContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Package_obj_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_obj_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPackage_obj_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPackage_obj_body(this);
		}
	}

	[RuleVersion(0)]
	public Package_obj_bodyContext package_obj_body() {
		Package_obj_bodyContext _localctx = new Package_obj_bodyContext(Context, State);
		EnterRule(_localctx, 40, RULE_package_obj_body);
		try {
			State = 1079;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,46,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1069; variable_declaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1070; subtype_declaration();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1071; cursor_declaration();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1072; exception_declaration();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1073; record_declaration();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1074; table_declaration();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1075; create_procedure_body();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1076; create_function_body();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1077; procedure_spec();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1078; function_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_procedureContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Drop_procedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_procedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_procedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_procedure(this);
		}
	}

	[RuleVersion(0)]
	public Drop_procedureContext drop_procedure() {
		Drop_procedureContext _localctx = new Drop_procedureContext(Context, State);
		EnterRule(_localctx, 42, RULE_drop_procedure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1081; Match(DROP);
			State = 1082; Match(PROCEDURE);
			State = 1083; procedure_name();
			State = 1084; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_procedureContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public Alter_procedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_procedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_procedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_procedure(this);
		}
	}

	[RuleVersion(0)]
	public Alter_procedureContext alter_procedure() {
		Alter_procedureContext _localctx = new Alter_procedureContext(Context, State);
		EnterRule(_localctx, 44, RULE_alter_procedure);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1086; Match(ALTER);
			State = 1087; Match(PROCEDURE);
			State = 1088; procedure_name();
			State = 1089; Match(COMPILE);
			State = 1091;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,47,Context) ) {
			case 1:
				{
				State = 1090; Match(DEBUG);
				}
				break;
			}
			State = 1096;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,48,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1093; compiler_parameters_clause();
					}
					} 
				}
				State = 1098;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,48,Context);
			}
			State = 1101;
			_la = TokenStream.La(1);
			if (_la==REUSE) {
				{
				State = 1099; Match(REUSE);
				State = 1100; Match(SETTINGS);
				}
			}

			State = 1103; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_procedure_bodyContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public Create_procedure_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_procedure_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_procedure_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_procedure_body(this);
		}
	}

	[RuleVersion(0)]
	public Create_procedure_bodyContext create_procedure_body() {
		Create_procedure_bodyContext _localctx = new Create_procedure_bodyContext(Context, State);
		EnterRule(_localctx, 46, RULE_create_procedure_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1110;
			_la = TokenStream.La(1);
			if (_la==CREATE) {
				{
				State = 1105; Match(CREATE);
				State = 1108;
				_la = TokenStream.La(1);
				if (_la==OR) {
					{
					State = 1106; Match(OR);
					State = 1107; Match(REPLACE);
					}
				}

				}
			}

			State = 1112; Match(PROCEDURE);
			State = 1113; procedure_name();
			State = 1125;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1114; Match(LEFT_PAREN);
				State = 1115; parameter();
				State = 1120;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1116; Match(COMMA);
					State = 1117; parameter();
					}
					}
					State = 1122;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1123; Match(RIGHT_PAREN);
				}
			}

			State = 1128;
			_la = TokenStream.La(1);
			if (_la==AUTHID) {
				{
				State = 1127; invoker_rights_clause();
				}
			}

			State = 1130;
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1143;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,57,Context) ) {
			case 1:
				{
				State = 1132;
				_la = TokenStream.La(1);
				if (_la==DECLARE) {
					{
					State = 1131; Match(DECLARE);
					}
				}

				State = 1137;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1134; declare_spec();
					}
					}
					State = 1139;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1140; body();
				}
				break;
			case 2:
				{
				State = 1141; call_spec();
				}
				break;
			case 3:
				{
				State = 1142; Match(EXTERNAL);
				}
				break;
			}
			State = 1145; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_triggerContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Drop_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_trigger(this);
		}
	}

	[RuleVersion(0)]
	public Drop_triggerContext drop_trigger() {
		Drop_triggerContext _localctx = new Drop_triggerContext(Context, State);
		EnterRule(_localctx, 48, RULE_drop_trigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1147; Match(DROP);
			State = 1148; Match(TRIGGER);
			State = 1149; trigger_name();
			State = 1150; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_triggerContext : ParserRuleContext {
		public Trigger_nameContext tn1;
		public Trigger_nameContext tn2;
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public Trigger_nameContext[] trigger_name() {
			return GetRuleContexts<Trigger_nameContext>();
		}
		public Trigger_nameContext trigger_name(int i) {
			return GetRuleContext<Trigger_nameContext>(i);
		}
		public ITerminalNode RENAME() { return GetToken(plsqlParser.RENAME, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode ENABLE() { return GetToken(plsqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(plsqlParser.DISABLE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public Alter_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_trigger(this);
		}
	}

	[RuleVersion(0)]
	public Alter_triggerContext alter_trigger() {
		Alter_triggerContext _localctx = new Alter_triggerContext(Context, State);
		EnterRule(_localctx, 50, RULE_alter_trigger);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1152; Match(ALTER);
			State = 1153; Match(TRIGGER);
			State = 1154; _localctx.tn1 = trigger_name();
			State = 1173;
			switch (TokenStream.La(1)) {
			case DISABLE:
			case ENABLE:
				{
				State = 1155;
				_la = TokenStream.La(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			case RENAME:
				{
				State = 1156; Match(RENAME);
				State = 1157; Match(TO);
				State = 1158; _localctx.tn2 = trigger_name();
				}
				break;
			case COMPILE:
				{
				State = 1159; Match(COMPILE);
				State = 1161;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,58,Context) ) {
				case 1:
					{
					State = 1160; Match(DEBUG);
					}
					break;
				}
				State = 1166;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,59,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 1163; compiler_parameters_clause();
						}
						} 
					}
					State = 1168;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,59,Context);
				}
				State = 1171;
				_la = TokenStream.La(1);
				if (_la==REUSE) {
					{
					State = 1169; Match(REUSE);
					State = 1170; Match(SETTINGS);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1175; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_triggerContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Trigger_bodyContext trigger_body() {
			return GetRuleContext<Trigger_bodyContext>(0);
		}
		public Simple_dml_triggerContext simple_dml_trigger() {
			return GetRuleContext<Simple_dml_triggerContext>(0);
		}
		public Compound_dml_triggerContext compound_dml_trigger() {
			return GetRuleContext<Compound_dml_triggerContext>(0);
		}
		public Non_dml_triggerContext non_dml_trigger() {
			return GetRuleContext<Non_dml_triggerContext>(0);
		}
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public Trigger_follows_clauseContext trigger_follows_clause() {
			return GetRuleContext<Trigger_follows_clauseContext>(0);
		}
		public Trigger_when_clauseContext trigger_when_clause() {
			return GetRuleContext<Trigger_when_clauseContext>(0);
		}
		public ITerminalNode ENABLE() { return GetToken(plsqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(plsqlParser.DISABLE, 0); }
		public Create_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_trigger(this);
		}
	}

	[RuleVersion(0)]
	public Create_triggerContext create_trigger() {
		Create_triggerContext _localctx = new Create_triggerContext(Context, State);
		EnterRule(_localctx, 52, RULE_create_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1177; Match(CREATE);
			State = 1180;
			_la = TokenStream.La(1);
			if (_la==OR) {
				{
				State = 1178; Match(OR);
				State = 1179; Match(REPLACE);
				}
			}

			State = 1182; Match(TRIGGER);
			State = 1183; trigger_name();
			State = 1187;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,63,Context) ) {
			case 1:
				{
				State = 1184; simple_dml_trigger();
				}
				break;
			case 2:
				{
				State = 1185; compound_dml_trigger();
				}
				break;
			case 3:
				{
				State = 1186; non_dml_trigger();
				}
				break;
			}
			State = 1190;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,64,Context) ) {
			case 1:
				{
				State = 1189; trigger_follows_clause();
				}
				break;
			}
			State = 1193;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,65,Context) ) {
			case 1:
				{
				State = 1192;
				_la = TokenStream.La(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			}
			State = 1196;
			_la = TokenStream.La(1);
			if (_la==WHEN) {
				{
				State = 1195; trigger_when_clause();
				}
			}

			State = 1198; trigger_body();
			State = 1199; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_follows_clauseContext : ParserRuleContext {
		public ITerminalNode FOLLOWS() { return GetToken(plsqlParser.FOLLOWS, 0); }
		public Trigger_nameContext[] trigger_name() {
			return GetRuleContexts<Trigger_nameContext>();
		}
		public Trigger_nameContext trigger_name(int i) {
			return GetRuleContext<Trigger_nameContext>(i);
		}
		public Trigger_follows_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_follows_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_follows_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_follows_clause(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_follows_clauseContext trigger_follows_clause() {
		Trigger_follows_clauseContext _localctx = new Trigger_follows_clauseContext(Context, State);
		EnterRule(_localctx, 54, RULE_trigger_follows_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1201; Match(FOLLOWS);
			State = 1202; trigger_name();
			State = 1207;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1203; Match(COMMA);
				State = 1204; trigger_name();
				}
				}
				State = 1209;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_when_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Trigger_when_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_when_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_when_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_when_clause(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_when_clauseContext trigger_when_clause() {
		Trigger_when_clauseContext _localctx = new Trigger_when_clauseContext(Context, State);
		EnterRule(_localctx, 56, RULE_trigger_when_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1210; Match(WHEN);
			State = 1211; Match(LEFT_PAREN);
			State = 1212; condition();
			State = 1213; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_dml_triggerContext : ParserRuleContext {
		public Dml_event_clauseContext dml_event_clause() {
			return GetRuleContext<Dml_event_clauseContext>(0);
		}
		public ITerminalNode BEFORE() { return GetToken(plsqlParser.BEFORE, 0); }
		public ITerminalNode AFTER() { return GetToken(plsqlParser.AFTER, 0); }
		public ITerminalNode INSTEAD() { return GetToken(plsqlParser.INSTEAD, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Referencing_clauseContext referencing_clause() {
			return GetRuleContext<Referencing_clauseContext>(0);
		}
		public For_each_rowContext for_each_row() {
			return GetRuleContext<For_each_rowContext>(0);
		}
		public Simple_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSimple_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSimple_dml_trigger(this);
		}
	}

	[RuleVersion(0)]
	public Simple_dml_triggerContext simple_dml_trigger() {
		Simple_dml_triggerContext _localctx = new Simple_dml_triggerContext(Context, State);
		EnterRule(_localctx, 58, RULE_simple_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1219;
			switch (TokenStream.La(1)) {
			case BEFORE:
				{
				State = 1215; Match(BEFORE);
				}
				break;
			case AFTER:
				{
				State = 1216; Match(AFTER);
				}
				break;
			case INSTEAD:
				{
				State = 1217; Match(INSTEAD);
				State = 1218; Match(OF);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1221; dml_event_clause();
			State = 1223;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,69,Context) ) {
			case 1:
				{
				State = 1222; referencing_clause();
				}
				break;
			}
			State = 1226;
			_la = TokenStream.La(1);
			if (_la==FOR) {
				{
				State = 1225; for_each_row();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_each_rowContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public ITerminalNode EACH() { return GetToken(plsqlParser.EACH, 0); }
		public ITerminalNode ROW() { return GetToken(plsqlParser.ROW, 0); }
		public For_each_rowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_each_row; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_each_row(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_each_row(this);
		}
	}

	[RuleVersion(0)]
	public For_each_rowContext for_each_row() {
		For_each_rowContext _localctx = new For_each_rowContext(Context, State);
		EnterRule(_localctx, 60, RULE_for_each_row);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1228; Match(FOR);
			State = 1229; Match(EACH);
			State = 1230; Match(ROW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_dml_triggerContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Dml_event_clauseContext dml_event_clause() {
			return GetRuleContext<Dml_event_clauseContext>(0);
		}
		public Referencing_clauseContext referencing_clause() {
			return GetRuleContext<Referencing_clauseContext>(0);
		}
		public Compound_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompound_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompound_dml_trigger(this);
		}
	}

	[RuleVersion(0)]
	public Compound_dml_triggerContext compound_dml_trigger() {
		Compound_dml_triggerContext _localctx = new Compound_dml_triggerContext(Context, State);
		EnterRule(_localctx, 62, RULE_compound_dml_trigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1232; Match(FOR);
			State = 1233; dml_event_clause();
			State = 1235;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,71,Context) ) {
			case 1:
				{
				State = 1234; referencing_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_dml_triggerContext : ParserRuleContext {
		public Non_dml_eventContext[] non_dml_event() {
			return GetRuleContexts<Non_dml_eventContext>();
		}
		public Non_dml_eventContext non_dml_event(int i) {
			return GetRuleContext<Non_dml_eventContext>(i);
		}
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public ITerminalNode BEFORE() { return GetToken(plsqlParser.BEFORE, 0); }
		public ITerminalNode AFTER() { return GetToken(plsqlParser.AFTER, 0); }
		public ITerminalNode DATABASE() { return GetToken(plsqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(plsqlParser.SCHEMA, 0); }
		public ITerminalNode[] OR() { return GetTokens(plsqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(plsqlParser.OR, i);
		}
		public Schema_nameContext schema_name() {
			return GetRuleContext<Schema_nameContext>(0);
		}
		public Non_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNon_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNon_dml_trigger(this);
		}
	}

	[RuleVersion(0)]
	public Non_dml_triggerContext non_dml_trigger() {
		Non_dml_triggerContext _localctx = new Non_dml_triggerContext(Context, State);
		EnterRule(_localctx, 64, RULE_non_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1237;
			_la = TokenStream.La(1);
			if ( !(_la==AFTER || _la==BEFORE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1238; non_dml_event();
			State = 1243;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==OR) {
				{
				{
				State = 1239; Match(OR);
				State = 1240; non_dml_event();
				}
				}
				State = 1245;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1246; Match(ON);
			State = 1254;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,74,Context) ) {
			case 1:
				{
				State = 1247; Match(DATABASE);
				}
				break;
			case 2:
				{
				State = 1251;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,73,Context) ) {
				case 1:
					{
					State = 1248; schema_name();
					State = 1249; Match(PERIOD);
					}
					break;
				}
				State = 1253; Match(SCHEMA);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_bodyContext : ParserRuleContext {
		public ITerminalNode COMPOUND() { return GetToken(plsqlParser.COMPOUND, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public ITerminalNode CALL() { return GetToken(plsqlParser.CALL, 0); }
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Trigger_blockContext trigger_block() {
			return GetRuleContext<Trigger_blockContext>(0);
		}
		public Trigger_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_body(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_bodyContext trigger_body() {
		Trigger_bodyContext _localctx = new Trigger_bodyContext(Context, State);
		EnterRule(_localctx, 66, RULE_trigger_body);
		try {
			State = 1261;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,75,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1256; Match(COMPOUND);
				State = 1257; Match(TRIGGER);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1258; Match(CALL);
				State = 1259; id();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1260; trigger_block();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Routine_clauseContext : ParserRuleContext {
		public Routine_nameContext routine_name() {
			return GetRuleContext<Routine_nameContext>(0);
		}
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public Routine_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routine_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRoutine_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRoutine_clause(this);
		}
	}

	[RuleVersion(0)]
	public Routine_clauseContext routine_clause() {
		Routine_clauseContext _localctx = new Routine_clauseContext(Context, State);
		EnterRule(_localctx, 68, RULE_routine_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1263; routine_name();
			State = 1265;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1264; function_argument();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_trigger_blockContext : ParserRuleContext {
		public ITerminalNode COMPOUND() { return GetToken(plsqlParser.COMPOUND, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Timing_point_sectionContext[] timing_point_section() {
			return GetRuleContexts<Timing_point_sectionContext>();
		}
		public Timing_point_sectionContext timing_point_section(int i) {
			return GetRuleContext<Timing_point_sectionContext>(i);
		}
		public Compound_trigger_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_trigger_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompound_trigger_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompound_trigger_block(this);
		}
	}

	[RuleVersion(0)]
	public Compound_trigger_blockContext compound_trigger_block() {
		Compound_trigger_blockContext _localctx = new Compound_trigger_blockContext(Context, State);
		EnterRule(_localctx, 70, RULE_compound_trigger_block);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1267; Match(COMPOUND);
			State = 1268; Match(TRIGGER);
			State = 1272;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,77,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1269; declare_spec();
					}
					} 
				}
				State = 1274;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,77,Context);
			}
			State = 1276;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 1275; timing_point_section();
				}
				}
				State = 1278;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==AFTER || _la==BEFORE );
			State = 1280; Match(END);
			State = 1281; trigger_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Timing_point_sectionContext : ParserRuleContext {
		public IToken bk;
		public IToken ak;
		public ITerminalNode[] STATEMENT() { return GetTokens(plsqlParser.STATEMENT); }
		public ITerminalNode STATEMENT(int i) {
			return GetToken(plsqlParser.STATEMENT, i);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Trigger_blockContext trigger_block() {
			return GetRuleContext<Trigger_blockContext>(0);
		}
		public ITerminalNode[] BEFORE() { return GetTokens(plsqlParser.BEFORE); }
		public ITerminalNode BEFORE(int i) {
			return GetToken(plsqlParser.BEFORE, i);
		}
		public ITerminalNode[] EACH() { return GetTokens(plsqlParser.EACH); }
		public ITerminalNode EACH(int i) {
			return GetToken(plsqlParser.EACH, i);
		}
		public ITerminalNode[] ROW() { return GetTokens(plsqlParser.ROW); }
		public ITerminalNode ROW(int i) {
			return GetToken(plsqlParser.ROW, i);
		}
		public ITerminalNode[] AFTER() { return GetTokens(plsqlParser.AFTER); }
		public ITerminalNode AFTER(int i) {
			return GetToken(plsqlParser.AFTER, i);
		}
		public Timing_point_sectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timing_point_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTiming_point_section(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTiming_point_section(this);
		}
	}

	[RuleVersion(0)]
	public Timing_point_sectionContext timing_point_section() {
		Timing_point_sectionContext _localctx = new Timing_point_sectionContext(Context, State);
		EnterRule(_localctx, 72, RULE_timing_point_section);
		try {
			State = 1319;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,79,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1283; _localctx.bk = Match(BEFORE);
				State = 1284; Match(STATEMENT);
				State = 1285; Match(IS);
				State = 1286; trigger_block();
				State = 1287; Match(BEFORE);
				State = 1288; Match(STATEMENT);
				State = 1289; Match(SEMICOLON);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1291; _localctx.bk = Match(BEFORE);
				State = 1292; Match(EACH);
				State = 1293; Match(ROW);
				State = 1294; Match(IS);
				State = 1295; trigger_block();
				State = 1296; Match(BEFORE);
				State = 1297; Match(EACH);
				State = 1298; Match(ROW);
				State = 1299; Match(SEMICOLON);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1301; _localctx.ak = Match(AFTER);
				State = 1302; Match(STATEMENT);
				State = 1303; Match(IS);
				State = 1304; trigger_block();
				State = 1305; Match(AFTER);
				State = 1306; Match(STATEMENT);
				State = 1307; Match(SEMICOLON);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1309; _localctx.ak = Match(AFTER);
				State = 1310; Match(EACH);
				State = 1311; Match(ROW);
				State = 1312; Match(IS);
				State = 1313; trigger_block();
				State = 1314; Match(AFTER);
				State = 1315; Match(EACH);
				State = 1316; Match(ROW);
				State = 1317; Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_dml_eventContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode ANALYZE() { return GetToken(plsqlParser.ANALYZE, 0); }
		public ITerminalNode ASSOCIATE() { return GetToken(plsqlParser.ASSOCIATE, 0); }
		public ITerminalNode STATISTICS() { return GetToken(plsqlParser.STATISTICS, 0); }
		public ITerminalNode AUDIT() { return GetToken(plsqlParser.AUDIT, 0); }
		public ITerminalNode COMMENT() { return GetToken(plsqlParser.COMMENT, 0); }
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode DISASSOCIATE() { return GetToken(plsqlParser.DISASSOCIATE, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode GRANT() { return GetToken(plsqlParser.GRANT, 0); }
		public ITerminalNode NOAUDIT() { return GetToken(plsqlParser.NOAUDIT, 0); }
		public ITerminalNode RENAME() { return GetToken(plsqlParser.RENAME, 0); }
		public ITerminalNode REVOKE() { return GetToken(plsqlParser.REVOKE, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(plsqlParser.TRUNCATE, 0); }
		public ITerminalNode DDL() { return GetToken(plsqlParser.DDL, 0); }
		public ITerminalNode STARTUP() { return GetToken(plsqlParser.STARTUP, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(plsqlParser.SHUTDOWN, 0); }
		public ITerminalNode DB_ROLE_CHANGE() { return GetToken(plsqlParser.DB_ROLE_CHANGE, 0); }
		public ITerminalNode LOGON() { return GetToken(plsqlParser.LOGON, 0); }
		public ITerminalNode LOGOFF() { return GetToken(plsqlParser.LOGOFF, 0); }
		public ITerminalNode SERVERERROR() { return GetToken(plsqlParser.SERVERERROR, 0); }
		public ITerminalNode SUSPEND() { return GetToken(plsqlParser.SUSPEND, 0); }
		public ITerminalNode DATABASE() { return GetToken(plsqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(plsqlParser.SCHEMA, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(plsqlParser.FOLLOWS, 0); }
		public Non_dml_eventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_dml_event; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNon_dml_event(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNon_dml_event(this);
		}
	}

	[RuleVersion(0)]
	public Non_dml_eventContext non_dml_event() {
		Non_dml_eventContext _localctx = new Non_dml_eventContext(Context, State);
		EnterRule(_localctx, 74, RULE_non_dml_event);
		try {
			State = 1347;
			switch (TokenStream.La(1)) {
			case ALTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1321; Match(ALTER);
				}
				break;
			case ANALYZE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1322; Match(ANALYZE);
				}
				break;
			case ASSOCIATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1323; Match(ASSOCIATE);
				State = 1324; Match(STATISTICS);
				}
				break;
			case AUDIT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1325; Match(AUDIT);
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1326; Match(COMMENT);
				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1327; Match(CREATE);
				}
				break;
			case DISASSOCIATE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1328; Match(DISASSOCIATE);
				State = 1329; Match(STATISTICS);
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1330; Match(DROP);
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1331; Match(GRANT);
				}
				break;
			case NOAUDIT:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1332; Match(NOAUDIT);
				}
				break;
			case RENAME:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1333; Match(RENAME);
				}
				break;
			case REVOKE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1334; Match(REVOKE);
				}
				break;
			case TRUNCATE:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1335; Match(TRUNCATE);
				}
				break;
			case DDL:
				EnterOuterAlt(_localctx, 14);
				{
				State = 1336; Match(DDL);
				}
				break;
			case STARTUP:
				EnterOuterAlt(_localctx, 15);
				{
				State = 1337; Match(STARTUP);
				}
				break;
			case SHUTDOWN:
				EnterOuterAlt(_localctx, 16);
				{
				State = 1338; Match(SHUTDOWN);
				}
				break;
			case DB_ROLE_CHANGE:
				EnterOuterAlt(_localctx, 17);
				{
				State = 1339; Match(DB_ROLE_CHANGE);
				}
				break;
			case LOGON:
				EnterOuterAlt(_localctx, 18);
				{
				State = 1340; Match(LOGON);
				}
				break;
			case LOGOFF:
				EnterOuterAlt(_localctx, 19);
				{
				State = 1341; Match(LOGOFF);
				}
				break;
			case SERVERERROR:
				EnterOuterAlt(_localctx, 20);
				{
				State = 1342; Match(SERVERERROR);
				}
				break;
			case SUSPEND:
				EnterOuterAlt(_localctx, 21);
				{
				State = 1343; Match(SUSPEND);
				}
				break;
			case DATABASE:
				EnterOuterAlt(_localctx, 22);
				{
				State = 1344; Match(DATABASE);
				}
				break;
			case SCHEMA:
				EnterOuterAlt(_localctx, 23);
				{
				State = 1345; Match(SCHEMA);
				}
				break;
			case FOLLOWS:
				EnterOuterAlt(_localctx, 24);
				{
				State = 1346; Match(FOLLOWS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_clauseContext : ParserRuleContext {
		public Dml_event_elementContext[] dml_event_element() {
			return GetRuleContexts<Dml_event_elementContext>();
		}
		public Dml_event_elementContext dml_event_element(int i) {
			return GetRuleContext<Dml_event_elementContext>(i);
		}
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode[] OR() { return GetTokens(plsqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(plsqlParser.OR, i);
		}
		public Dml_event_nested_clauseContext dml_event_nested_clause() {
			return GetRuleContext<Dml_event_nested_clauseContext>(0);
		}
		public Dml_event_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDml_event_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDml_event_clause(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_clauseContext dml_event_clause() {
		Dml_event_clauseContext _localctx = new Dml_event_clauseContext(Context, State);
		EnterRule(_localctx, 76, RULE_dml_event_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1349; dml_event_element();
			State = 1354;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==OR) {
				{
				{
				State = 1350; Match(OR);
				State = 1351; dml_event_element();
				}
				}
				State = 1356;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1357; Match(ON);
			State = 1359;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,82,Context) ) {
			case 1:
				{
				State = 1358; dml_event_nested_clause();
				}
				break;
			}
			State = 1361; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_elementContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(plsqlParser.DELETE, 0); }
		public ITerminalNode INSERT() { return GetToken(plsqlParser.INSERT, 0); }
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Dml_event_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDml_event_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDml_event_element(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_elementContext dml_event_element() {
		Dml_event_elementContext _localctx = new Dml_event_elementContext(Context, State);
		EnterRule(_localctx, 78, RULE_dml_event_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1363;
			_la = TokenStream.La(1);
			if ( !(_la==DELETE || _la==INSERT || _la==UPDATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1373;
			_la = TokenStream.La(1);
			if (_la==OF) {
				{
				State = 1364; Match(OF);
				State = 1365; column_name();
				State = 1370;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1366; Match(COMMA);
					State = 1367; column_name();
					}
					}
					State = 1372;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_nested_clauseContext : ParserRuleContext {
		public ITerminalNode NESTED() { return GetToken(plsqlParser.NESTED, 0); }
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Dml_event_nested_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_nested_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDml_event_nested_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDml_event_nested_clause(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_nested_clauseContext dml_event_nested_clause() {
		Dml_event_nested_clauseContext _localctx = new Dml_event_nested_clauseContext(Context, State);
		EnterRule(_localctx, 80, RULE_dml_event_nested_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1375; Match(NESTED);
			State = 1376; Match(TABLE);
			State = 1377; tableview_name();
			State = 1378; Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Referencing_clauseContext : ParserRuleContext {
		public ITerminalNode REFERENCING() { return GetToken(plsqlParser.REFERENCING, 0); }
		public Referencing_elementContext[] referencing_element() {
			return GetRuleContexts<Referencing_elementContext>();
		}
		public Referencing_elementContext referencing_element(int i) {
			return GetRuleContext<Referencing_elementContext>(i);
		}
		public Referencing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReferencing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReferencing_clause(this);
		}
	}

	[RuleVersion(0)]
	public Referencing_clauseContext referencing_clause() {
		Referencing_clauseContext _localctx = new Referencing_clauseContext(Context, State);
		EnterRule(_localctx, 82, RULE_referencing_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1380; Match(REFERENCING);
			State = 1382;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 1381; referencing_element();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1384;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,85,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Referencing_elementContext : ParserRuleContext {
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(plsqlParser.NEW, 0); }
		public ITerminalNode OLD() { return GetToken(plsqlParser.OLD, 0); }
		public ITerminalNode PARENT() { return GetToken(plsqlParser.PARENT, 0); }
		public Referencing_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencing_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReferencing_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReferencing_element(this);
		}
	}

	[RuleVersion(0)]
	public Referencing_elementContext referencing_element() {
		Referencing_elementContext _localctx = new Referencing_elementContext(Context, State);
		EnterRule(_localctx, 84, RULE_referencing_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1386;
			_la = TokenStream.La(1);
			if ( !(((((_la - 237)) & ~0x3f) == 0 && ((1L << (_la - 237)) & ((1L << (NEW - 237)) | (1L << (OLD - 237)) | (1L << (PARENT - 237)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1387; column_alias();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_typeContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public ITerminalNode VALIDATE() { return GetToken(plsqlParser.VALIDATE, 0); }
		public Drop_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_type(this);
		}
	}

	[RuleVersion(0)]
	public Drop_typeContext drop_type() {
		Drop_typeContext _localctx = new Drop_typeContext(Context, State);
		EnterRule(_localctx, 86, RULE_drop_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1389; Match(DROP);
			State = 1390; Match(TYPE);
			State = 1392;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,86,Context) ) {
			case 1:
				{
				State = 1391; Match(BODY);
				}
				break;
			}
			State = 1394; type_name();
			State = 1396;
			_la = TokenStream.La(1);
			if (_la==FORCE || _la==VALIDATE) {
				{
				State = 1395;
				_la = TokenStream.La(1);
				if ( !(_la==FORCE || _la==VALIDATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			State = 1398; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_typeContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public Compile_type_clauseContext compile_type_clause() {
			return GetRuleContext<Compile_type_clauseContext>(0);
		}
		public Replace_type_clauseContext replace_type_clause() {
			return GetRuleContext<Replace_type_clauseContext>(0);
		}
		public Alter_method_specContext alter_method_spec() {
			return GetRuleContext<Alter_method_specContext>(0);
		}
		public Alter_collection_clausesContext alter_collection_clauses() {
			return GetRuleContext<Alter_collection_clausesContext>(0);
		}
		public Modifier_clauseContext modifier_clause() {
			return GetRuleContext<Modifier_clauseContext>(0);
		}
		public Dependent_handling_clauseContext dependent_handling_clause() {
			return GetRuleContext<Dependent_handling_clauseContext>(0);
		}
		public Alter_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_type(this);
		}
	}

	[RuleVersion(0)]
	public Alter_typeContext alter_type() {
		Alter_typeContext _localctx = new Alter_typeContext(Context, State);
		EnterRule(_localctx, 88, RULE_alter_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1400; Match(ALTER);
			State = 1401; Match(TYPE);
			State = 1402; type_name();
			State = 1408;
			switch (TokenStream.La(1)) {
			case COMPILE:
				{
				State = 1403; compile_type_clause();
				}
				break;
			case REPLACE:
				{
				State = 1404; replace_type_clause();
				}
				break;
			case ADD:
			case DROP:
				{
				State = 1405; alter_method_spec();
				}
				break;
			case MODIFY:
				{
				State = 1406; alter_collection_clauses();
				}
				break;
			case FINAL:
			case INSTANTIABLE:
			case NOT:
			case OVERRIDING:
				{
				State = 1407; modifier_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1411;
			_la = TokenStream.La(1);
			if (_la==CASCADE || _la==INVALIDATE) {
				{
				State = 1410; dependent_handling_clause();
				}
			}

			State = 1413; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compile_type_clauseContext : ParserRuleContext {
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(plsqlParser.SPECIFICATION, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public Compile_type_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compile_type_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompile_type_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompile_type_clause(this);
		}
	}

	[RuleVersion(0)]
	public Compile_type_clauseContext compile_type_clause() {
		Compile_type_clauseContext _localctx = new Compile_type_clauseContext(Context, State);
		EnterRule(_localctx, 90, RULE_compile_type_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1415; Match(COMPILE);
			State = 1417;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,90,Context) ) {
			case 1:
				{
				State = 1416; Match(DEBUG);
				}
				break;
			}
			State = 1420;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,91,Context) ) {
			case 1:
				{
				State = 1419;
				_la = TokenStream.La(1);
				if ( !(_la==BODY || _la==SPECIFICATION) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			}
			State = 1425;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,92,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1422; compiler_parameters_clause();
					}
					} 
				}
				State = 1427;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,92,Context);
			}
			State = 1430;
			_la = TokenStream.La(1);
			if (_la==REUSE) {
				{
				State = 1428; Match(REUSE);
				State = 1429; Match(SETTINGS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Replace_type_clauseContext : ParserRuleContext {
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public ITerminalNode OBJECT() { return GetToken(plsqlParser.OBJECT, 0); }
		public Object_member_specContext[] object_member_spec() {
			return GetRuleContexts<Object_member_specContext>();
		}
		public Object_member_specContext object_member_spec(int i) {
			return GetRuleContext<Object_member_specContext>(i);
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Replace_type_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replace_type_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReplace_type_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReplace_type_clause(this);
		}
	}

	[RuleVersion(0)]
	public Replace_type_clauseContext replace_type_clause() {
		Replace_type_clauseContext _localctx = new Replace_type_clauseContext(Context, State);
		EnterRule(_localctx, 92, RULE_replace_type_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1432; Match(REPLACE);
			State = 1434;
			_la = TokenStream.La(1);
			if (_la==AUTHID) {
				{
				State = 1433; invoker_rights_clause();
				}
			}

			State = 1436; Match(AS);
			State = 1437; Match(OBJECT);
			State = 1438; Match(LEFT_PAREN);
			State = 1439; object_member_spec();
			State = 1444;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1440; Match(COMMA);
				State = 1441; object_member_spec();
				}
				}
				State = 1446;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1447; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_method_specContext : ParserRuleContext {
		public Alter_method_elementContext[] alter_method_element() {
			return GetRuleContexts<Alter_method_elementContext>();
		}
		public Alter_method_elementContext alter_method_element(int i) {
			return GetRuleContext<Alter_method_elementContext>(i);
		}
		public Alter_method_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_method_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_method_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_method_spec(this);
		}
	}

	[RuleVersion(0)]
	public Alter_method_specContext alter_method_spec() {
		Alter_method_specContext _localctx = new Alter_method_specContext(Context, State);
		EnterRule(_localctx, 94, RULE_alter_method_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1449; alter_method_element();
			State = 1454;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1450; Match(COMMA);
				State = 1451; alter_method_element();
				}
				}
				State = 1456;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_method_elementContext : ParserRuleContext {
		public ITerminalNode ADD() { return GetToken(plsqlParser.ADD, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public Map_order_function_specContext map_order_function_spec() {
			return GetRuleContext<Map_order_function_specContext>(0);
		}
		public Subprogram_specContext subprogram_spec() {
			return GetRuleContext<Subprogram_specContext>(0);
		}
		public Alter_method_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_method_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_method_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_method_element(this);
		}
	}

	[RuleVersion(0)]
	public Alter_method_elementContext alter_method_element() {
		Alter_method_elementContext _localctx = new Alter_method_elementContext(Context, State);
		EnterRule(_localctx, 96, RULE_alter_method_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1457;
			_la = TokenStream.La(1);
			if ( !(_la==ADD || _la==DROP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1460;
			switch (TokenStream.La(1)) {
			case MAP:
			case ORDER:
				{
				State = 1458; map_order_function_spec();
				}
				break;
			case MEMBER:
			case STATIC:
				{
				State = 1459; subprogram_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_attribute_definitionContext : ParserRuleContext {
		public ITerminalNode ATTRIBUTE() { return GetToken(plsqlParser.ATTRIBUTE, 0); }
		public ITerminalNode ADD() { return GetToken(plsqlParser.ADD, 0); }
		public ITerminalNode MODIFY() { return GetToken(plsqlParser.MODIFY, 0); }
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public Attribute_definitionContext[] attribute_definition() {
			return GetRuleContexts<Attribute_definitionContext>();
		}
		public Attribute_definitionContext attribute_definition(int i) {
			return GetRuleContext<Attribute_definitionContext>(i);
		}
		public Alter_attribute_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_attribute_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_attribute_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_attribute_definition(this);
		}
	}

	[RuleVersion(0)]
	public Alter_attribute_definitionContext alter_attribute_definition() {
		Alter_attribute_definitionContext _localctx = new Alter_attribute_definitionContext(Context, State);
		EnterRule(_localctx, 98, RULE_alter_attribute_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1462;
			_la = TokenStream.La(1);
			if ( !(_la==ADD || _la==DROP || _la==MODIFY) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1463; Match(ATTRIBUTE);
			State = 1476;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 1464; attribute_definition();
				}
				break;
			case LEFT_PAREN:
				{
				State = 1465; Match(LEFT_PAREN);
				State = 1466; attribute_definition();
				State = 1471;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1467; Match(COMMA);
					State = 1468; attribute_definition();
					}
					}
					State = 1473;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1474; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_definitionContext : ParserRuleContext {
		public Attribute_nameContext attribute_name() {
			return GetRuleContext<Attribute_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Attribute_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAttribute_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAttribute_definition(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_definitionContext attribute_definition() {
		Attribute_definitionContext _localctx = new Attribute_definitionContext(Context, State);
		EnterRule(_localctx, 100, RULE_attribute_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1478; attribute_name();
			State = 1480;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 1479; type_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_collection_clausesContext : ParserRuleContext {
		public ITerminalNode MODIFY() { return GetToken(plsqlParser.MODIFY, 0); }
		public ITerminalNode LIMIT() { return GetToken(plsqlParser.LIMIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ELEMENT() { return GetToken(plsqlParser.ELEMENT, 0); }
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Alter_collection_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_collection_clauses; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_collection_clauses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_collection_clauses(this);
		}
	}

	[RuleVersion(0)]
	public Alter_collection_clausesContext alter_collection_clauses() {
		Alter_collection_clausesContext _localctx = new Alter_collection_clausesContext(Context, State);
		EnterRule(_localctx, 102, RULE_alter_collection_clauses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1482; Match(MODIFY);
			State = 1488;
			switch (TokenStream.La(1)) {
			case LIMIT:
				{
				State = 1483; Match(LIMIT);
				State = 1484; expression();
				}
				break;
			case ELEMENT:
				{
				State = 1485; Match(ELEMENT);
				State = 1486; Match(TYPE);
				State = 1487; type_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dependent_handling_clauseContext : ParserRuleContext {
		public ITerminalNode INVALIDATE() { return GetToken(plsqlParser.INVALIDATE, 0); }
		public ITerminalNode CASCADE() { return GetToken(plsqlParser.CASCADE, 0); }
		public ITerminalNode CONVERT() { return GetToken(plsqlParser.CONVERT, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(plsqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode INCLUDING() { return GetToken(plsqlParser.INCLUDING, 0); }
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public ITerminalNode DATA() { return GetToken(plsqlParser.DATA, 0); }
		public Dependent_exceptions_partContext dependent_exceptions_part() {
			return GetRuleContext<Dependent_exceptions_partContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public Dependent_handling_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependent_handling_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDependent_handling_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDependent_handling_clause(this);
		}
	}

	[RuleVersion(0)]
	public Dependent_handling_clauseContext dependent_handling_clause() {
		Dependent_handling_clauseContext _localctx = new Dependent_handling_clauseContext(Context, State);
		EnterRule(_localctx, 104, RULE_dependent_handling_clause);
		int _la;
		try {
			State = 1506;
			switch (TokenStream.La(1)) {
			case INVALIDATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1490; Match(INVALIDATE);
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1491; Match(CASCADE);
				State = 1501;
				switch (TokenStream.La(1)) {
				case CONVERT:
					{
					State = 1492; Match(CONVERT);
					State = 1493; Match(TO);
					State = 1494; Match(SUBSTITUTABLE);
					}
					break;
				case INCLUDING:
				case NOT:
					{
					State = 1496;
					_la = TokenStream.La(1);
					if (_la==NOT) {
						{
						State = 1495; Match(NOT);
						}
					}

					State = 1498; Match(INCLUDING);
					State = 1499; Match(TABLE);
					State = 1500; Match(DATA);
					}
					break;
				case EXCEPTIONS:
				case FORCE:
				case SEMICOLON:
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1504;
				_la = TokenStream.La(1);
				if (_la==EXCEPTIONS || _la==FORCE) {
					{
					State = 1503; dependent_exceptions_part();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dependent_exceptions_partContext : ParserRuleContext {
		public ITerminalNode EXCEPTIONS() { return GetToken(plsqlParser.EXCEPTIONS, 0); }
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public Dependent_exceptions_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependent_exceptions_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDependent_exceptions_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDependent_exceptions_part(this);
		}
	}

	[RuleVersion(0)]
	public Dependent_exceptions_partContext dependent_exceptions_part() {
		Dependent_exceptions_partContext _localctx = new Dependent_exceptions_partContext(Context, State);
		EnterRule(_localctx, 106, RULE_dependent_exceptions_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1509;
			_la = TokenStream.La(1);
			if (_la==FORCE) {
				{
				State = 1508; Match(FORCE);
				}
			}

			State = 1511; Match(EXCEPTIONS);
			State = 1512; Match(INTO);
			State = 1513; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_typeContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Type_definitionContext type_definition() {
			return GetRuleContext<Type_definitionContext>(0);
		}
		public Type_bodyContext type_body() {
			return GetRuleContext<Type_bodyContext>(0);
		}
		public ITerminalNode OR() { return GetToken(plsqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public Create_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_type(this);
		}
	}

	[RuleVersion(0)]
	public Create_typeContext create_type() {
		Create_typeContext _localctx = new Create_typeContext(Context, State);
		EnterRule(_localctx, 108, RULE_create_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1515; Match(CREATE);
			State = 1518;
			_la = TokenStream.La(1);
			if (_la==OR) {
				{
				State = 1516; Match(OR);
				State = 1517; Match(REPLACE);
				}
			}

			State = 1520; Match(TYPE);
			State = 1523;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,108,Context) ) {
			case 1:
				{
				State = 1521; type_definition();
				}
				break;
			case 2:
				{
				State = 1522; type_body();
				}
				break;
			}
			State = 1525; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_definitionContext : ParserRuleContext {
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode OID() { return GetToken(plsqlParser.OID, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public Object_type_defContext object_type_def() {
			return GetRuleContext<Object_type_defContext>(0);
		}
		public Type_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_definition(this);
		}
	}

	[RuleVersion(0)]
	public Type_definitionContext type_definition() {
		Type_definitionContext _localctx = new Type_definitionContext(Context, State);
		EnterRule(_localctx, 110, RULE_type_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1527; type_name();
			State = 1530;
			_la = TokenStream.La(1);
			if (_la==OID) {
				{
				State = 1528; Match(OID);
				State = 1529; Match(CHAR_STRING);
				}
			}

			State = 1533;
			_la = TokenStream.La(1);
			if (_la==AS || _la==AUTHID || _la==IS || _la==UNDER) {
				{
				State = 1532; object_type_def();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_type_defContext : ParserRuleContext {
		public Object_as_partContext object_as_part() {
			return GetRuleContext<Object_as_partContext>(0);
		}
		public Object_under_partContext object_under_part() {
			return GetRuleContext<Object_under_partContext>(0);
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Sqlj_object_typeContext sqlj_object_type() {
			return GetRuleContext<Sqlj_object_typeContext>(0);
		}
		public Object_member_specContext[] object_member_spec() {
			return GetRuleContexts<Object_member_specContext>();
		}
		public Object_member_specContext object_member_spec(int i) {
			return GetRuleContext<Object_member_specContext>(i);
		}
		public Modifier_clauseContext[] modifier_clause() {
			return GetRuleContexts<Modifier_clauseContext>();
		}
		public Modifier_clauseContext modifier_clause(int i) {
			return GetRuleContext<Modifier_clauseContext>(i);
		}
		public Object_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterObject_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitObject_type_def(this);
		}
	}

	[RuleVersion(0)]
	public Object_type_defContext object_type_def() {
		Object_type_defContext _localctx = new Object_type_defContext(Context, State);
		EnterRule(_localctx, 112, RULE_object_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1536;
			_la = TokenStream.La(1);
			if (_la==AUTHID) {
				{
				State = 1535; invoker_rights_clause();
				}
			}

			State = 1540;
			switch (TokenStream.La(1)) {
			case AS:
			case IS:
				{
				State = 1538; object_as_part();
				}
				break;
			case UNDER:
				{
				State = 1539; object_under_part();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1543;
			_la = TokenStream.La(1);
			if (_la==EXTERNAL) {
				{
				State = 1542; sqlj_object_type();
				}
			}

			State = 1556;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1545; Match(LEFT_PAREN);
				State = 1546; object_member_spec();
				State = 1551;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1547; Match(COMMA);
					State = 1548; object_member_spec();
					}
					}
					State = 1553;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1554; Match(RIGHT_PAREN);
				}
			}

			State = 1561;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
				{
				{
				State = 1558; modifier_clause();
				}
				}
				State = 1563;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_as_partContext : ParserRuleContext {
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public ITerminalNode OBJECT() { return GetToken(plsqlParser.OBJECT, 0); }
		public Varray_type_defContext varray_type_def() {
			return GetRuleContext<Varray_type_defContext>(0);
		}
		public Nested_table_type_defContext nested_table_type_def() {
			return GetRuleContext<Nested_table_type_defContext>(0);
		}
		public Object_as_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_as_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterObject_as_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitObject_as_part(this);
		}
	}

	[RuleVersion(0)]
	public Object_as_partContext object_as_part() {
		Object_as_partContext _localctx = new Object_as_partContext(Context, State);
		EnterRule(_localctx, 114, RULE_object_as_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1564;
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1568;
			switch (TokenStream.La(1)) {
			case OBJECT:
				{
				State = 1565; Match(OBJECT);
				}
				break;
			case VARRAY:
			case VARYING:
				{
				State = 1566; varray_type_def();
				}
				break;
			case TABLE:
				{
				State = 1567; nested_table_type_def();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_under_partContext : ParserRuleContext {
		public ITerminalNode UNDER() { return GetToken(plsqlParser.UNDER, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Object_under_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_under_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterObject_under_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitObject_under_part(this);
		}
	}

	[RuleVersion(0)]
	public Object_under_partContext object_under_part() {
		Object_under_partContext _localctx = new Object_under_partContext(Context, State);
		EnterRule(_localctx, 116, RULE_object_under_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1570; Match(UNDER);
			State = 1571; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Nested_table_type_defContext : ParserRuleContext {
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Nested_table_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nested_table_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNested_table_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNested_table_type_def(this);
		}
	}

	[RuleVersion(0)]
	public Nested_table_type_defContext nested_table_type_def() {
		Nested_table_type_defContext _localctx = new Nested_table_type_defContext(Context, State);
		EnterRule(_localctx, 118, RULE_nested_table_type_def);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1573; Match(TABLE);
			State = 1574; Match(OF);
			State = 1575; type_spec();
			State = 1578;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,118,Context) ) {
			case 1:
				{
				State = 1576; Match(NOT);
				State = 1577; Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlj_object_typeContext : ParserRuleContext {
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LANGUAGE() { return GetToken(plsqlParser.LANGUAGE, 0); }
		public ITerminalNode JAVA() { return GetToken(plsqlParser.JAVA, 0); }
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public ITerminalNode SQLDATA() { return GetToken(plsqlParser.SQLDATA, 0); }
		public ITerminalNode CUSTOMDATUM() { return GetToken(plsqlParser.CUSTOMDATUM, 0); }
		public ITerminalNode ORADATA() { return GetToken(plsqlParser.ORADATA, 0); }
		public Sqlj_object_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlj_object_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSqlj_object_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSqlj_object_type(this);
		}
	}

	[RuleVersion(0)]
	public Sqlj_object_typeContext sqlj_object_type() {
		Sqlj_object_typeContext _localctx = new Sqlj_object_typeContext(Context, State);
		EnterRule(_localctx, 120, RULE_sqlj_object_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1580; Match(EXTERNAL);
			State = 1581; Match(NAME);
			State = 1582; expression();
			State = 1583; Match(LANGUAGE);
			State = 1584; Match(JAVA);
			State = 1585; Match(USING);
			State = 1586;
			_la = TokenStream.La(1);
			if ( !(_la==CUSTOMDATUM || _la==ORADATA || _la==SQLDATA) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_bodyContext : ParserRuleContext {
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Type_body_elementsContext[] type_body_elements() {
			return GetRuleContexts<Type_body_elementsContext>();
		}
		public Type_body_elementsContext type_body_elements(int i) {
			return GetRuleContext<Type_body_elementsContext>(i);
		}
		public Type_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_body(this);
		}
	}

	[RuleVersion(0)]
	public Type_bodyContext type_body() {
		Type_bodyContext _localctx = new Type_bodyContext(Context, State);
		EnterRule(_localctx, 122, RULE_type_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1588; Match(BODY);
			State = 1589; type_name();
			State = 1590;
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1592;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 1591; type_body_elements();
				}
				}
				State = 1594;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( ((((_la - 213)) & ~0x3f) == 0 && ((1L << (_la - 213)) & ((1L << (MAP - 213)) | (1L << (MEMBER - 213)) | (1L << (ORDER - 213)))) != 0) || _la==STATIC );
			State = 1596; Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_body_elementsContext : ParserRuleContext {
		public Map_order_func_declarationContext map_order_func_declaration() {
			return GetRuleContext<Map_order_func_declarationContext>(0);
		}
		public Subprog_decl_in_typeContext subprog_decl_in_type() {
			return GetRuleContext<Subprog_decl_in_typeContext>(0);
		}
		public Type_body_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_body_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_body_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_body_elements(this);
		}
	}

	[RuleVersion(0)]
	public Type_body_elementsContext type_body_elements() {
		Type_body_elementsContext _localctx = new Type_body_elementsContext(Context, State);
		EnterRule(_localctx, 124, RULE_type_body_elements);
		try {
			State = 1600;
			switch (TokenStream.La(1)) {
			case MAP:
			case ORDER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1598; map_order_func_declaration();
				}
				break;
			case MEMBER:
			case STATIC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1599; subprog_decl_in_type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Map_order_func_declarationContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public Func_decl_in_typeContext func_decl_in_type() {
			return GetRuleContext<Func_decl_in_typeContext>(0);
		}
		public ITerminalNode MAP() { return GetToken(plsqlParser.MAP, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public Map_order_func_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map_order_func_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMap_order_func_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMap_order_func_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Map_order_func_declarationContext map_order_func_declaration() {
		Map_order_func_declarationContext _localctx = new Map_order_func_declarationContext(Context, State);
		EnterRule(_localctx, 126, RULE_map_order_func_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1602;
			_la = TokenStream.La(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1603; Match(MEMBER);
			State = 1604; func_decl_in_type();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subprog_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public ITerminalNode STATIC() { return GetToken(plsqlParser.STATIC, 0); }
		public Proc_decl_in_typeContext proc_decl_in_type() {
			return GetRuleContext<Proc_decl_in_typeContext>(0);
		}
		public Func_decl_in_typeContext func_decl_in_type() {
			return GetRuleContext<Func_decl_in_typeContext>(0);
		}
		public Constructor_declarationContext constructor_declaration() {
			return GetRuleContext<Constructor_declarationContext>(0);
		}
		public Subprog_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subprog_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubprog_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubprog_decl_in_type(this);
		}
	}

	[RuleVersion(0)]
	public Subprog_decl_in_typeContext subprog_decl_in_type() {
		Subprog_decl_in_typeContext _localctx = new Subprog_decl_in_typeContext(Context, State);
		EnterRule(_localctx, 128, RULE_subprog_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1606;
			_la = TokenStream.La(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1610;
			switch (TokenStream.La(1)) {
			case PROCEDURE:
				{
				State = 1607; proc_decl_in_type();
				}
				break;
			case FUNCTION:
				{
				State = 1608; func_decl_in_type();
				}
				break;
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
				{
				State = 1609; constructor_declaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proc_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Proc_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proc_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterProc_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitProc_decl_in_type(this);
		}
	}

	[RuleVersion(0)]
	public Proc_decl_in_typeContext proc_decl_in_type() {
		Proc_decl_in_typeContext _localctx = new Proc_decl_in_typeContext(Context, State);
		EnterRule(_localctx, 130, RULE_proc_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1612; Match(PROCEDURE);
			State = 1613; procedure_name();
			State = 1614; Match(LEFT_PAREN);
			State = 1615; type_elements_parameter();
			State = 1620;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1616; Match(COMMA);
				State = 1617; type_elements_parameter();
				}
				}
				State = 1622;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1623; Match(RIGHT_PAREN);
			State = 1624;
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1638;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,125,Context) ) {
			case 1:
				{
				State = 1625; call_spec();
				}
				break;
			case 2:
				{
				State = 1627;
				_la = TokenStream.La(1);
				if (_la==DECLARE) {
					{
					State = 1626; Match(DECLARE);
					}
				}

				State = 1632;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1629; declare_spec();
					}
					}
					State = 1634;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1635; body();
				State = 1636; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Func_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Func_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_func_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunc_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunc_decl_in_type(this);
		}
	}

	[RuleVersion(0)]
	public Func_decl_in_typeContext func_decl_in_type() {
		Func_decl_in_typeContext _localctx = new Func_decl_in_typeContext(Context, State);
		EnterRule(_localctx, 132, RULE_func_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1640; Match(FUNCTION);
			State = 1641; function_name();
			State = 1653;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1642; Match(LEFT_PAREN);
				State = 1643; type_elements_parameter();
				State = 1648;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1644; Match(COMMA);
					State = 1645; type_elements_parameter();
					}
					}
					State = 1650;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1651; Match(RIGHT_PAREN);
				}
			}

			State = 1655; Match(RETURN);
			State = 1656; type_spec();
			State = 1657;
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1671;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,130,Context) ) {
			case 1:
				{
				State = 1658; call_spec();
				}
				break;
			case 2:
				{
				State = 1660;
				_la = TokenStream.La(1);
				if (_la==DECLARE) {
					{
					State = 1659; Match(DECLARE);
					}
				}

				State = 1665;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1662; declare_spec();
					}
					}
					State = 1667;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1668; body();
				State = 1669; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constructor_declarationContext : ParserRuleContext {
		public ITerminalNode CONSTRUCTOR() { return GetToken(plsqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode[] SELF() { return GetTokens(plsqlParser.SELF); }
		public ITerminalNode SELF(int i) {
			return GetToken(plsqlParser.SELF, i);
		}
		public ITerminalNode[] AS() { return GetTokens(plsqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(plsqlParser.AS, i);
		}
		public ITerminalNode RESULT() { return GetToken(plsqlParser.RESULT, 0); }
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode FINAL() { return GetToken(plsqlParser.FINAL, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(plsqlParser.INSTANTIABLE, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(plsqlParser.OUT, 0); }
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Constructor_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructor_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConstructor_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConstructor_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Constructor_declarationContext constructor_declaration() {
		Constructor_declarationContext _localctx = new Constructor_declarationContext(Context, State);
		EnterRule(_localctx, 134, RULE_constructor_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1674;
			_la = TokenStream.La(1);
			if (_la==FINAL) {
				{
				State = 1673; Match(FINAL);
				}
			}

			State = 1677;
			_la = TokenStream.La(1);
			if (_la==INSTANTIABLE) {
				{
				State = 1676; Match(INSTANTIABLE);
				}
			}

			State = 1679; Match(CONSTRUCTOR);
			State = 1680; Match(FUNCTION);
			State = 1681; type_spec();
			State = 1699;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1682; Match(LEFT_PAREN);
				{
				State = 1683; Match(SELF);
				State = 1684; Match(IN);
				State = 1685; Match(OUT);
				State = 1686; type_spec();
				State = 1687; Match(COMMA);
				}
				State = 1689; type_elements_parameter();
				State = 1694;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1690; Match(COMMA);
					State = 1691; type_elements_parameter();
					}
					}
					State = 1696;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1697; Match(RIGHT_PAREN);
				}
			}

			State = 1701; Match(RETURN);
			State = 1702; Match(SELF);
			State = 1703; Match(AS);
			State = 1704; Match(RESULT);
			State = 1705;
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1719;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,137,Context) ) {
			case 1:
				{
				State = 1706; call_spec();
				}
				break;
			case 2:
				{
				State = 1708;
				_la = TokenStream.La(1);
				if (_la==DECLARE) {
					{
					State = 1707; Match(DECLARE);
					}
				}

				State = 1713;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					{
					State = 1710; declare_spec();
					}
					}
					State = 1715;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1716; body();
				State = 1717; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Modifier_clauseContext : ParserRuleContext {
		public ITerminalNode INSTANTIABLE() { return GetToken(plsqlParser.INSTANTIABLE, 0); }
		public ITerminalNode FINAL() { return GetToken(plsqlParser.FINAL, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(plsqlParser.OVERRIDING, 0); }
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public Modifier_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifier_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModifier_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModifier_clause(this);
		}
	}

	[RuleVersion(0)]
	public Modifier_clauseContext modifier_clause() {
		Modifier_clauseContext _localctx = new Modifier_clauseContext(Context, State);
		EnterRule(_localctx, 136, RULE_modifier_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1722;
			_la = TokenStream.La(1);
			if (_la==NOT) {
				{
				State = 1721; Match(NOT);
				}
			}

			State = 1724;
			_la = TokenStream.La(1);
			if ( !(_la==FINAL || _la==INSTANTIABLE || _la==OVERRIDING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_member_specContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Sqlj_object_type_attrContext sqlj_object_type_attr() {
			return GetRuleContext<Sqlj_object_type_attrContext>(0);
		}
		public Element_specContext element_spec() {
			return GetRuleContext<Element_specContext>(0);
		}
		public Object_member_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_member_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterObject_member_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitObject_member_spec(this);
		}
	}

	[RuleVersion(0)]
	public Object_member_specContext object_member_spec() {
		Object_member_specContext _localctx = new Object_member_specContext(Context, State);
		EnterRule(_localctx, 138, RULE_object_member_spec);
		int _la;
		try {
			State = 1732;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,140,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1726; id();
				State = 1727; type_spec();
				State = 1729;
				_la = TokenStream.La(1);
				if (_la==EXTERNAL) {
					{
					State = 1728; sqlj_object_type_attr();
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1731; element_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlj_object_type_attrContext : ParserRuleContext {
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Sqlj_object_type_attrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlj_object_type_attr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSqlj_object_type_attr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSqlj_object_type_attr(this);
		}
	}

	[RuleVersion(0)]
	public Sqlj_object_type_attrContext sqlj_object_type_attr() {
		Sqlj_object_type_attrContext _localctx = new Sqlj_object_type_attrContext(Context, State);
		EnterRule(_localctx, 140, RULE_sqlj_object_type_attr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1734; Match(EXTERNAL);
			State = 1735; Match(NAME);
			State = 1736; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_specContext : ParserRuleContext {
		public Modifier_clauseContext modifier_clause() {
			return GetRuleContext<Modifier_clauseContext>(0);
		}
		public Element_spec_optionsContext[] element_spec_options() {
			return GetRuleContexts<Element_spec_optionsContext>();
		}
		public Element_spec_optionsContext element_spec_options(int i) {
			return GetRuleContext<Element_spec_optionsContext>(i);
		}
		public Pragma_clauseContext pragma_clause() {
			return GetRuleContext<Pragma_clauseContext>(0);
		}
		public Element_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterElement_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitElement_spec(this);
		}
	}

	[RuleVersion(0)]
	public Element_specContext element_spec() {
		Element_specContext _localctx = new Element_specContext(Context, State);
		EnterRule(_localctx, 142, RULE_element_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1739;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,141,Context) ) {
			case 1:
				{
				State = 1738; modifier_clause();
				}
				break;
			}
			State = 1742;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 1741; element_spec_options();
				}
				}
				State = 1744;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==CONSTRUCTOR || _la==FINAL || _la==INSTANTIABLE || ((((_la - 213)) & ~0x3f) == 0 && ((1L << (_la - 213)) & ((1L << (MAP - 213)) | (1L << (MEMBER - 213)) | (1L << (ORDER - 213)))) != 0) || _la==STATIC );
			State = 1748;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,143,Context) ) {
			case 1:
				{
				State = 1746; Match(COMMA);
				State = 1747; pragma_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_spec_optionsContext : ParserRuleContext {
		public Subprogram_specContext subprogram_spec() {
			return GetRuleContext<Subprogram_specContext>(0);
		}
		public Constructor_specContext constructor_spec() {
			return GetRuleContext<Constructor_specContext>(0);
		}
		public Map_order_function_specContext map_order_function_spec() {
			return GetRuleContext<Map_order_function_specContext>(0);
		}
		public Element_spec_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_spec_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterElement_spec_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitElement_spec_options(this);
		}
	}

	[RuleVersion(0)]
	public Element_spec_optionsContext element_spec_options() {
		Element_spec_optionsContext _localctx = new Element_spec_optionsContext(Context, State);
		EnterRule(_localctx, 144, RULE_element_spec_options);
		try {
			State = 1753;
			switch (TokenStream.La(1)) {
			case MEMBER:
			case STATIC:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1750; subprogram_spec();
				}
				break;
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1751; constructor_spec();
				}
				break;
			case MAP:
			case ORDER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1752; map_order_function_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subprogram_specContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public ITerminalNode STATIC() { return GetToken(plsqlParser.STATIC, 0); }
		public Type_procedure_specContext type_procedure_spec() {
			return GetRuleContext<Type_procedure_specContext>(0);
		}
		public Type_function_specContext type_function_spec() {
			return GetRuleContext<Type_function_specContext>(0);
		}
		public Subprogram_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subprogram_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubprogram_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubprogram_spec(this);
		}
	}

	[RuleVersion(0)]
	public Subprogram_specContext subprogram_spec() {
		Subprogram_specContext _localctx = new Subprogram_specContext(Context, State);
		EnterRule(_localctx, 146, RULE_subprogram_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1755;
			_la = TokenStream.La(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1758;
			switch (TokenStream.La(1)) {
			case PROCEDURE:
				{
				State = 1756; type_procedure_spec();
				}
				break;
			case FUNCTION:
				{
				State = 1757; type_function_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_procedure_specContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(plsqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Type_procedure_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_procedure_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_procedure_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_procedure_spec(this);
		}
	}

	[RuleVersion(0)]
	public Type_procedure_specContext type_procedure_spec() {
		Type_procedure_specContext _localctx = new Type_procedure_specContext(Context, State);
		EnterRule(_localctx, 148, RULE_type_procedure_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1760; Match(PROCEDURE);
			State = 1761; procedure_name();
			State = 1762; Match(LEFT_PAREN);
			State = 1763; type_elements_parameter();
			State = 1768;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1764; Match(COMMA);
				State = 1765; type_elements_parameter();
				}
				}
				State = 1770;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1771; Match(RIGHT_PAREN);
			State = 1774;
			_la = TokenStream.La(1);
			if (_la==AS || _la==IS) {
				{
				State = 1772;
				_la = TokenStream.La(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 1773; call_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_function_specContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode SELF() { return GetToken(plsqlParser.SELF, 0); }
		public ITerminalNode[] AS() { return GetTokens(plsqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(plsqlParser.AS, i);
		}
		public ITerminalNode RESULT() { return GetToken(plsqlParser.RESULT, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode VARIABLE() { return GetToken(plsqlParser.VARIABLE, 0); }
		public Type_function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_function_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_function_spec(this);
		}
	}

	[RuleVersion(0)]
	public Type_function_specContext type_function_spec() {
		Type_function_specContext _localctx = new Type_function_specContext(Context, State);
		EnterRule(_localctx, 150, RULE_type_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1776; Match(FUNCTION);
			State = 1777; function_name();
			State = 1789;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1778; Match(LEFT_PAREN);
				State = 1779; type_elements_parameter();
				State = 1784;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1780; Match(COMMA);
					State = 1781; type_elements_parameter();
					}
					}
					State = 1786;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1787; Match(RIGHT_PAREN);
				}
			}

			State = 1791; Match(RETURN);
			State = 1796;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,150,Context) ) {
			case 1:
				{
				State = 1792; type_spec();
				}
				break;
			case 2:
				{
				State = 1793; Match(SELF);
				State = 1794; Match(AS);
				State = 1795; Match(RESULT);
				}
				break;
			}
			State = 1806;
			switch (TokenStream.La(1)) {
			case AS:
			case IS:
				{
				State = 1798;
				_la = TokenStream.La(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 1799; call_spec();
				}
				break;
			case EXTERNAL:
				{
				State = 1800; Match(EXTERNAL);
				State = 1802;
				_la = TokenStream.La(1);
				if (_la==VARIABLE) {
					{
					State = 1801; Match(VARIABLE);
					}
				}

				State = 1804; Match(NAME);
				State = 1805; expression();
				}
				break;
			case CASCADE:
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
			case INVALIDATE:
			case MAP:
			case MEMBER:
			case ORDER:
			case STATIC:
			case RIGHT_PAREN:
			case COMMA:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constructor_specContext : ParserRuleContext {
		public ITerminalNode CONSTRUCTOR() { return GetToken(plsqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode[] SELF() { return GetTokens(plsqlParser.SELF); }
		public ITerminalNode SELF(int i) {
			return GetToken(plsqlParser.SELF, i);
		}
		public ITerminalNode[] AS() { return GetTokens(plsqlParser.AS); }
		public ITerminalNode AS(int i) {
			return GetToken(plsqlParser.AS, i);
		}
		public ITerminalNode RESULT() { return GetToken(plsqlParser.RESULT, 0); }
		public ITerminalNode FINAL() { return GetToken(plsqlParser.FINAL, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(plsqlParser.INSTANTIABLE, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(plsqlParser.OUT, 0); }
		public Constructor_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructor_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConstructor_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConstructor_spec(this);
		}
	}

	[RuleVersion(0)]
	public Constructor_specContext constructor_spec() {
		Constructor_specContext _localctx = new Constructor_specContext(Context, State);
		EnterRule(_localctx, 152, RULE_constructor_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1809;
			_la = TokenStream.La(1);
			if (_la==FINAL) {
				{
				State = 1808; Match(FINAL);
				}
			}

			State = 1812;
			_la = TokenStream.La(1);
			if (_la==INSTANTIABLE) {
				{
				State = 1811; Match(INSTANTIABLE);
				}
			}

			State = 1814; Match(CONSTRUCTOR);
			State = 1815; Match(FUNCTION);
			State = 1816; type_spec();
			State = 1834;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1817; Match(LEFT_PAREN);
				{
				State = 1818; Match(SELF);
				State = 1819; Match(IN);
				State = 1820; Match(OUT);
				State = 1821; type_spec();
				State = 1822; Match(COMMA);
				}
				State = 1824; type_elements_parameter();
				State = 1829;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1825; Match(COMMA);
					State = 1826; type_elements_parameter();
					}
					}
					State = 1831;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 1832; Match(RIGHT_PAREN);
				}
			}

			State = 1836; Match(RETURN);
			State = 1837; Match(SELF);
			State = 1838; Match(AS);
			State = 1839; Match(RESULT);
			State = 1842;
			_la = TokenStream.La(1);
			if (_la==AS || _la==IS) {
				{
				State = 1840;
				_la = TokenStream.La(1);
				if ( !(_la==AS || _la==IS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 1841; call_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Map_order_function_specContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public Type_function_specContext type_function_spec() {
			return GetRuleContext<Type_function_specContext>(0);
		}
		public ITerminalNode MAP() { return GetToken(plsqlParser.MAP, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public Map_order_function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map_order_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMap_order_function_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMap_order_function_spec(this);
		}
	}

	[RuleVersion(0)]
	public Map_order_function_specContext map_order_function_spec() {
		Map_order_function_specContext _localctx = new Map_order_function_specContext(Context, State);
		EnterRule(_localctx, 154, RULE_map_order_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1844;
			_la = TokenStream.La(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1845; Match(MEMBER);
			State = 1846; type_function_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_clauseContext : ParserRuleContext {
		public ITerminalNode PRAGMA() { return GetToken(plsqlParser.PRAGMA, 0); }
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(plsqlParser.RESTRICT_REFERENCES, 0); }
		public Pragma_elementsContext[] pragma_elements() {
			return GetRuleContexts<Pragma_elementsContext>();
		}
		public Pragma_elementsContext pragma_elements(int i) {
			return GetRuleContext<Pragma_elementsContext>(i);
		}
		public Pragma_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPragma_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPragma_clause(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_clauseContext pragma_clause() {
		Pragma_clauseContext _localctx = new Pragma_clauseContext(Context, State);
		EnterRule(_localctx, 156, RULE_pragma_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1848; Match(PRAGMA);
			State = 1849; Match(RESTRICT_REFERENCES);
			State = 1850; Match(LEFT_PAREN);
			State = 1851; pragma_elements();
			State = 1856;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1852; Match(COMMA);
				State = 1853; pragma_elements();
				}
				}
				State = 1858;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1859; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_elementsContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Pragma_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPragma_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPragma_elements(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_elementsContext pragma_elements() {
		Pragma_elementsContext _localctx = new Pragma_elementsContext(Context, State);
		EnterRule(_localctx, 158, RULE_pragma_elements);
		try {
			State = 1863;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1861; id();
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1862; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_elements_parameterContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Type_elements_parameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_elements_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_elements_parameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_elements_parameter(this);
		}
	}

	[RuleVersion(0)]
	public Type_elements_parameterContext type_elements_parameter() {
		Type_elements_parameterContext _localctx = new Type_elements_parameterContext(Context, State);
		EnterRule(_localctx, 160, RULE_type_elements_parameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1865; parameter_name();
			State = 1866; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_sequenceContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(plsqlParser.DROP, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(plsqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Drop_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDrop_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDrop_sequence(this);
		}
	}

	[RuleVersion(0)]
	public Drop_sequenceContext drop_sequence() {
		Drop_sequenceContext _localctx = new Drop_sequenceContext(Context, State);
		EnterRule(_localctx, 162, RULE_drop_sequence);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1868; Match(DROP);
			State = 1869; Match(SEQUENCE);
			State = 1870; sequence_name();
			State = 1871; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_sequenceContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(plsqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Sequence_specContext[] sequence_spec() {
			return GetRuleContexts<Sequence_specContext>();
		}
		public Sequence_specContext sequence_spec(int i) {
			return GetRuleContext<Sequence_specContext>(i);
		}
		public Alter_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlter_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlter_sequence(this);
		}
	}

	[RuleVersion(0)]
	public Alter_sequenceContext alter_sequence() {
		Alter_sequenceContext _localctx = new Alter_sequenceContext(Context, State);
		EnterRule(_localctx, 164, RULE_alter_sequence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1873; Match(ALTER);
			State = 1874; Match(SEQUENCE);
			State = 1875; sequence_name();
			State = 1877;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 1876; sequence_spec();
				}
				}
				State = 1879;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==CACHE || _la==CYCLE || ((((_la - 167)) & ~0x3f) == 0 && ((1L << (_la - 167)) & ((1L << (INCREMENT - 167)) | (1L << (MAXVALUE - 167)) | (1L << (MINVALUE - 167)))) != 0) || ((((_la - 240)) & ~0x3f) == 0 && ((1L << (_la - 240)) & ((1L << (NOCACHE - 240)) | (1L << (NOCYCLE - 240)) | (1L << (NOMAXVALUE - 240)) | (1L << (NOMINVALUE - 240)) | (1L << (NOORDER - 240)) | (1L << (ORDER - 240)))) != 0) );
			State = 1881; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_sequenceContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(plsqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Sequence_start_clauseContext[] sequence_start_clause() {
			return GetRuleContexts<Sequence_start_clauseContext>();
		}
		public Sequence_start_clauseContext sequence_start_clause(int i) {
			return GetRuleContext<Sequence_start_clauseContext>(i);
		}
		public Sequence_specContext[] sequence_spec() {
			return GetRuleContexts<Sequence_specContext>();
		}
		public Sequence_specContext sequence_spec(int i) {
			return GetRuleContext<Sequence_specContext>(i);
		}
		public Create_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCreate_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCreate_sequence(this);
		}
	}

	[RuleVersion(0)]
	public Create_sequenceContext create_sequence() {
		Create_sequenceContext _localctx = new Create_sequenceContext(Context, State);
		EnterRule(_localctx, 166, RULE_create_sequence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1883; Match(CREATE);
			State = 1884; Match(SEQUENCE);
			State = 1885; sequence_name();
			State = 1890;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==CACHE || _la==CYCLE || ((((_la - 167)) & ~0x3f) == 0 && ((1L << (_la - 167)) & ((1L << (INCREMENT - 167)) | (1L << (MAXVALUE - 167)) | (1L << (MINVALUE - 167)))) != 0) || ((((_la - 240)) & ~0x3f) == 0 && ((1L << (_la - 240)) & ((1L << (NOCACHE - 240)) | (1L << (NOCYCLE - 240)) | (1L << (NOMAXVALUE - 240)) | (1L << (NOMINVALUE - 240)) | (1L << (NOORDER - 240)) | (1L << (ORDER - 240)))) != 0) || _la==START) {
				{
				State = 1888;
				switch (TokenStream.La(1)) {
				case START:
					{
					State = 1886; sequence_start_clause();
					}
					break;
				case CACHE:
				case CYCLE:
				case INCREMENT:
				case MAXVALUE:
				case MINVALUE:
				case NOCACHE:
				case NOCYCLE:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOORDER:
				case ORDER:
					{
					State = 1887; sequence_spec();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 1892;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1893; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_specContext : ParserRuleContext {
		public ITerminalNode INCREMENT() { return GetToken(plsqlParser.INCREMENT, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(plsqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(plsqlParser.MAXVALUE, 0); }
		public ITerminalNode NOMAXVALUE() { return GetToken(plsqlParser.NOMAXVALUE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(plsqlParser.MINVALUE, 0); }
		public ITerminalNode NOMINVALUE() { return GetToken(plsqlParser.NOMINVALUE, 0); }
		public ITerminalNode CYCLE() { return GetToken(plsqlParser.CYCLE, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(plsqlParser.NOCYCLE, 0); }
		public ITerminalNode CACHE() { return GetToken(plsqlParser.CACHE, 0); }
		public ITerminalNode NOCACHE() { return GetToken(plsqlParser.NOCACHE, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public ITerminalNode NOORDER() { return GetToken(plsqlParser.NOORDER, 0); }
		public Sequence_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSequence_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSequence_spec(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_specContext sequence_spec() {
		Sequence_specContext _localctx = new Sequence_specContext(Context, State);
		EnterRule(_localctx, 168, RULE_sequence_spec);
		try {
			State = 1911;
			switch (TokenStream.La(1)) {
			case INCREMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1895; Match(INCREMENT);
				State = 1896; Match(BY);
				State = 1897; Match(UNSIGNED_INTEGER);
				}
				break;
			case MAXVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1898; Match(MAXVALUE);
				State = 1899; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1900; Match(NOMAXVALUE);
				}
				break;
			case MINVALUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1901; Match(MINVALUE);
				State = 1902; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1903; Match(NOMINVALUE);
				}
				break;
			case CYCLE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1904; Match(CYCLE);
				}
				break;
			case NOCYCLE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1905; Match(NOCYCLE);
				}
				break;
			case CACHE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1906; Match(CACHE);
				State = 1907; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOCACHE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1908; Match(NOCACHE);
				}
				break;
			case ORDER:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1909; Match(ORDER);
				}
				break;
			case NOORDER:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1910; Match(NOORDER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_start_clauseContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(plsqlParser.START, 0); }
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(plsqlParser.UNSIGNED_INTEGER, 0); }
		public Sequence_start_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_start_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSequence_start_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSequence_start_clause(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_start_clauseContext sequence_start_clause() {
		Sequence_start_clauseContext _localctx = new Sequence_start_clauseContext(Context, State);
		EnterRule(_localctx, 170, RULE_sequence_start_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1913; Match(START);
			State = 1914; Match(WITH);
			State = 1915; Match(UNSIGNED_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Invoker_rights_clauseContext : ParserRuleContext {
		public ITerminalNode AUTHID() { return GetToken(plsqlParser.AUTHID, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(plsqlParser.CURRENT_USER, 0); }
		public ITerminalNode DEFINER() { return GetToken(plsqlParser.DEFINER, 0); }
		public Invoker_rights_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_invoker_rights_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInvoker_rights_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInvoker_rights_clause(this);
		}
	}

	[RuleVersion(0)]
	public Invoker_rights_clauseContext invoker_rights_clause() {
		Invoker_rights_clauseContext _localctx = new Invoker_rights_clauseContext(Context, State);
		EnterRule(_localctx, 172, RULE_invoker_rights_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1917; Match(AUTHID);
			State = 1918;
			_la = TokenStream.La(1);
			if ( !(_la==CURRENT_USER || _la==DEFINER) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compiler_parameters_clauseContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Compiler_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compiler_parameters_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompiler_parameters_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompiler_parameters_clause(this);
		}
	}

	[RuleVersion(0)]
	public Compiler_parameters_clauseContext compiler_parameters_clause() {
		Compiler_parameters_clauseContext _localctx = new Compiler_parameters_clauseContext(Context, State);
		EnterRule(_localctx, 174, RULE_compiler_parameters_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1920; id();
			State = 1921; Match(EQUALS_OP);
			State = 1922; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Call_specContext : ParserRuleContext {
		public ITerminalNode LANGUAGE() { return GetToken(plsqlParser.LANGUAGE, 0); }
		public Java_specContext java_spec() {
			return GetRuleContext<Java_specContext>(0);
		}
		public C_specContext c_spec() {
			return GetRuleContext<C_specContext>(0);
		}
		public Call_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_call_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCall_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCall_spec(this);
		}
	}

	[RuleVersion(0)]
	public Call_specContext call_spec() {
		Call_specContext _localctx = new Call_specContext(Context, State);
		EnterRule(_localctx, 176, RULE_call_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1924; Match(LANGUAGE);
			State = 1927;
			switch (TokenStream.La(1)) {
			case JAVA:
				{
				State = 1925; java_spec();
				}
				break;
			case C_LETTER:
				{
				State = 1926; c_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Java_specContext : ParserRuleContext {
		public ITerminalNode JAVA() { return GetToken(plsqlParser.JAVA, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public Java_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_java_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterJava_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitJava_spec(this);
		}
	}

	[RuleVersion(0)]
	public Java_specContext java_spec() {
		Java_specContext _localctx = new Java_specContext(Context, State);
		EnterRule(_localctx, 178, RULE_java_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1929; Match(JAVA);
			State = 1930; Match(NAME);
			State = 1931; Match(CHAR_STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_specContext : ParserRuleContext {
		public ITerminalNode C_LETTER() { return GetToken(plsqlParser.C_LETTER, 0); }
		public ITerminalNode LIBRARY() { return GetToken(plsqlParser.LIBRARY, 0); }
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public C_agent_in_clauseContext c_agent_in_clause() {
			return GetRuleContext<C_agent_in_clauseContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode CONTEXT() { return GetToken(plsqlParser.CONTEXT, 0); }
		public C_parameters_clauseContext c_parameters_clause() {
			return GetRuleContext<C_parameters_clauseContext>(0);
		}
		public C_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterC_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitC_spec(this);
		}
	}

	[RuleVersion(0)]
	public C_specContext c_spec() {
		C_specContext _localctx = new C_specContext(Context, State);
		EnterRule(_localctx, 180, RULE_c_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1933; Match(C_LETTER);
			State = 1936;
			_la = TokenStream.La(1);
			if (_la==NAME) {
				{
				State = 1934; Match(NAME);
				State = 1935; Match(CHAR_STRING);
				}
			}

			State = 1938; Match(LIBRARY);
			State = 1939; id();
			State = 1941;
			_la = TokenStream.La(1);
			if (_la==AGENT) {
				{
				State = 1940; c_agent_in_clause();
				}
			}

			State = 1945;
			_la = TokenStream.La(1);
			if (_la==WITH) {
				{
				State = 1943; Match(WITH);
				State = 1944; Match(CONTEXT);
				}
			}

			State = 1948;
			_la = TokenStream.La(1);
			if (_la==PARAMETERS) {
				{
				State = 1947; c_parameters_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_agent_in_clauseContext : ParserRuleContext {
		public ITerminalNode AGENT() { return GetToken(plsqlParser.AGENT, 0); }
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public C_agent_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_agent_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterC_agent_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitC_agent_in_clause(this);
		}
	}

	[RuleVersion(0)]
	public C_agent_in_clauseContext c_agent_in_clause() {
		C_agent_in_clauseContext _localctx = new C_agent_in_clauseContext(Context, State);
		EnterRule(_localctx, 182, RULE_c_agent_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1950; Match(AGENT);
			State = 1951; Match(IN);
			State = 1952; Match(LEFT_PAREN);
			State = 1953; expression();
			State = 1958;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1954; Match(COMMA);
				State = 1955; expression();
				}
				}
				State = 1960;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 1961; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_parameters_clauseContext : ParserRuleContext {
		public ITerminalNode PARAMETERS() { return GetToken(plsqlParser.PARAMETERS, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public C_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_parameters_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterC_parameters_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitC_parameters_clause(this);
		}
	}

	[RuleVersion(0)]
	public C_parameters_clauseContext c_parameters_clause() {
		C_parameters_clauseContext _localctx = new C_parameters_clauseContext(Context, State);
		EnterRule(_localctx, 184, RULE_c_parameters_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1963; Match(PARAMETERS);
			State = 1964; Match(LEFT_PAREN);
			State = 1976;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 1965; expression();
				State = 1970;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1966; Match(COMMA);
					State = 1967; expression();
					}
					}
					State = 1972;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			case PERIOD:
				{
				State = 1973; Match(PERIOD);
				State = 1974; Match(PERIOD);
				State = 1975; Match(PERIOD);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1978; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public ITerminalNode[] IN() { return GetTokens(plsqlParser.IN); }
		public ITerminalNode IN(int i) {
			return GetToken(plsqlParser.IN, i);
		}
		public ITerminalNode[] OUT() { return GetTokens(plsqlParser.OUT); }
		public ITerminalNode OUT(int i) {
			return GetToken(plsqlParser.OUT, i);
		}
		public ITerminalNode[] INOUT() { return GetTokens(plsqlParser.INOUT); }
		public ITerminalNode INOUT(int i) {
			return GetToken(plsqlParser.INOUT, i);
		}
		public ITerminalNode[] NOCOPY() { return GetTokens(plsqlParser.NOCOPY); }
		public ITerminalNode NOCOPY(int i) {
			return GetToken(plsqlParser.NOCOPY, i);
		}
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitParameter(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(Context, State);
		EnterRule(_localctx, 186, RULE_parameter);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1980; parameter_name();
			State = 1984;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,172,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1981;
					_la = TokenStream.La(1);
					if ( !(_la==IN || _la==INOUT || _la==NOCOPY || _la==OUT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					}
					} 
				}
				State = 1986;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,172,Context);
			}
			State = 1988;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 1987; type_spec();
				}
			}

			State = 1991;
			_la = TokenStream.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 1990; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Default_value_partContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASSIGN_OP() { return GetToken(plsqlParser.ASSIGN_OP, 0); }
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Default_value_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_default_value_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDefault_value_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDefault_value_part(this);
		}
	}

	[RuleVersion(0)]
	public Default_value_partContext default_value_part() {
		Default_value_partContext _localctx = new Default_value_partContext(Context, State);
		EnterRule(_localctx, 188, RULE_default_value_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1993;
			_la = TokenStream.La(1);
			if ( !(_la==DEFAULT || _la==ASSIGN_OP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 1994; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Declare_specContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Record_declarationContext record_declaration() {
			return GetRuleContext<Record_declarationContext>(0);
		}
		public Table_declarationContext table_declaration() {
			return GetRuleContext<Table_declarationContext>(0);
		}
		public Create_procedure_bodyContext create_procedure_body() {
			return GetRuleContext<Create_procedure_bodyContext>(0);
		}
		public Create_function_bodyContext create_function_body() {
			return GetRuleContext<Create_function_bodyContext>(0);
		}
		public Declare_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declare_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDeclare_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDeclare_spec(this);
		}
	}

	[RuleVersion(0)]
	public Declare_specContext declare_spec() {
		Declare_specContext _localctx = new Declare_specContext(Context, State);
		EnterRule(_localctx, 190, RULE_declare_spec);
		try {
			State = 2005;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,175,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1996; variable_declaration();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1997; subtype_declaration();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1998; cursor_declaration();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1999; exception_declaration();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2000; pragma_declaration();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2001; record_declaration();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2002; table_declaration();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2003; create_procedure_body();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2004; create_function_body();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_declarationContext : ParserRuleContext {
		public Variable_nameContext variable_name() {
			return GetRuleContext<Variable_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode CONSTANT() { return GetToken(plsqlParser.CONSTANT, 0); }
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Variable_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterVariable_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitVariable_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Variable_declarationContext variable_declaration() {
		Variable_declarationContext _localctx = new Variable_declarationContext(Context, State);
		EnterRule(_localctx, 192, RULE_variable_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2007; variable_name();
			State = 2009;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,176,Context) ) {
			case 1:
				{
				State = 2008; Match(CONSTANT);
				}
				break;
			}
			State = 2011; type_spec();
			State = 2014;
			_la = TokenStream.La(1);
			if (_la==NOT) {
				{
				State = 2012; Match(NOT);
				State = 2013; Match(NULL);
				}
			}

			State = 2017;
			_la = TokenStream.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2016; default_value_part();
				}
			}

			State = 2019; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subtype_declarationContext : ParserRuleContext {
		public ITerminalNode SUBTYPE() { return GetToken(plsqlParser.SUBTYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode RANGE() { return GetToken(plsqlParser.RANGE, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Subtype_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subtype_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubtype_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubtype_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Subtype_declarationContext subtype_declaration() {
		Subtype_declarationContext _localctx = new Subtype_declarationContext(Context, State);
		EnterRule(_localctx, 194, RULE_subtype_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2021; Match(SUBTYPE);
			State = 2022; type_name();
			State = 2023; Match(IS);
			State = 2024; type_spec();
			State = 2030;
			_la = TokenStream.La(1);
			if (_la==RANGE) {
				{
				State = 2025; Match(RANGE);
				State = 2026; expression();
				State = 2027; Match(T__0);
				State = 2028; expression();
				}
			}

			State = 2034;
			_la = TokenStream.La(1);
			if (_la==NOT) {
				{
				State = 2032; Match(NOT);
				State = 2033; Match(NULL);
				}
			}

			State = 2036; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_declarationContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(plsqlParser.CURSOR, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Parameter_specContext[] parameter_spec() {
			return GetRuleContexts<Parameter_specContext>();
		}
		public Parameter_specContext parameter_spec(int i) {
			return GetRuleContext<Parameter_specContext>(i);
		}
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Cursor_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_declarationContext cursor_declaration() {
		Cursor_declarationContext _localctx = new Cursor_declarationContext(Context, State);
		EnterRule(_localctx, 196, RULE_cursor_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2038; Match(CURSOR);
			State = 2039; cursor_name();
			State = 2051;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2040; Match(LEFT_PAREN);
				State = 2041; parameter_spec();
				State = 2046;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2042; Match(COMMA);
					State = 2043; parameter_spec();
					}
					}
					State = 2048;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 2049; Match(RIGHT_PAREN);
				}
			}

			State = 2055;
			_la = TokenStream.La(1);
			if (_la==RETURN) {
				{
				State = 2053; Match(RETURN);
				State = 2054; type_spec();
				}
			}

			State = 2059;
			_la = TokenStream.La(1);
			if (_la==IS) {
				{
				State = 2057; Match(IS);
				State = 2058; select_statement();
				}
			}

			State = 2061; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_specContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Parameter_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterParameter_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitParameter_spec(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_specContext parameter_spec() {
		Parameter_specContext _localctx = new Parameter_specContext(Context, State);
		EnterRule(_localctx, 198, RULE_parameter_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2063; parameter_name();
			State = 2068;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (IN - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2065;
				_la = TokenStream.La(1);
				if (_la==IN) {
					{
					State = 2064; Match(IN);
					}
				}

				State = 2067; type_spec();
				}
			}

			State = 2071;
			_la = TokenStream.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2070; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_declarationContext : ParserRuleContext {
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public ITerminalNode EXCEPTION() { return GetToken(plsqlParser.EXCEPTION, 0); }
		public Exception_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterException_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitException_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Exception_declarationContext exception_declaration() {
		Exception_declarationContext _localctx = new Exception_declarationContext(Context, State);
		EnterRule(_localctx, 200, RULE_exception_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2073; exception_name();
			State = 2074; Match(EXCEPTION);
			State = 2075; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_declarationContext : ParserRuleContext {
		public IdContext id1;
		public ITerminalNode PRAGMA() { return GetToken(plsqlParser.PRAGMA, 0); }
		public ITerminalNode SERIALLY_REUSABLE() { return GetToken(plsqlParser.SERIALLY_REUSABLE, 0); }
		public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(plsqlParser.AUTONOMOUS_TRANSACTION, 0); }
		public ITerminalNode EXCEPTION_INIT() { return GetToken(plsqlParser.EXCEPTION_INIT, 0); }
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public Numeric_negativeContext numeric_negative() {
			return GetRuleContext<Numeric_negativeContext>(0);
		}
		public ITerminalNode INLINE() { return GetToken(plsqlParser.INLINE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(plsqlParser.RESTRICT_REFERENCES, 0); }
		public IdContext[] id() {
			return GetRuleContexts<IdContext>();
		}
		public IdContext id(int i) {
			return GetRuleContext<IdContext>(i);
		}
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Pragma_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPragma_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPragma_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_declarationContext pragma_declaration() {
		Pragma_declarationContext _localctx = new Pragma_declarationContext(Context, State);
		EnterRule(_localctx, 202, RULE_pragma_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2077; Match(PRAGMA);
			State = 2108;
			switch (TokenStream.La(1)) {
			case SERIALLY_REUSABLE:
				{
				State = 2078; Match(SERIALLY_REUSABLE);
				}
				break;
			case AUTONOMOUS_TRANSACTION:
				{
				State = 2079; Match(AUTONOMOUS_TRANSACTION);
				}
				break;
			case EXCEPTION_INIT:
				{
				State = 2080; Match(EXCEPTION_INIT);
				State = 2081; Match(LEFT_PAREN);
				State = 2082; exception_name();
				State = 2083; Match(COMMA);
				State = 2084; numeric_negative();
				State = 2085; Match(RIGHT_PAREN);
				}
				break;
			case INLINE:
				{
				State = 2087; Match(INLINE);
				State = 2088; Match(LEFT_PAREN);
				State = 2089; _localctx.id1 = id();
				State = 2090; Match(COMMA);
				State = 2091; expression();
				State = 2092; Match(RIGHT_PAREN);
				}
				break;
			case RESTRICT_REFERENCES:
				{
				State = 2094; Match(RESTRICT_REFERENCES);
				State = 2095; Match(LEFT_PAREN);
				State = 2098;
				switch (TokenStream.La(1)) {
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 2096; id();
					}
					break;
				case DEFAULT:
					{
					State = 2097; Match(DEFAULT);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2102;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				do {
					{
					{
					State = 2100; Match(COMMA);
					State = 2101; id();
					}
					}
					State = 2104;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				} while ( _la==COMMA );
				State = 2106; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2110; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_declarationContext : ParserRuleContext {
		public Record_type_decContext record_type_dec() {
			return GetRuleContext<Record_type_decContext>(0);
		}
		public Record_var_decContext record_var_dec() {
			return GetRuleContext<Record_var_decContext>(0);
		}
		public Record_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRecord_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRecord_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Record_declarationContext record_declaration() {
		Record_declarationContext _localctx = new Record_declarationContext(Context, State);
		EnterRule(_localctx, 204, RULE_record_declaration);
		try {
			State = 2114;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,191,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2112; record_type_dec();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2113; record_var_dec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_type_decContext : ParserRuleContext {
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode RECORD() { return GetToken(plsqlParser.RECORD, 0); }
		public Field_specContext[] field_spec() {
			return GetRuleContexts<Field_specContext>();
		}
		public Field_specContext field_spec(int i) {
			return GetRuleContext<Field_specContext>(i);
		}
		public ITerminalNode REF() { return GetToken(plsqlParser.REF, 0); }
		public ITerminalNode CURSOR() { return GetToken(plsqlParser.CURSOR, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Record_type_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_type_dec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRecord_type_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRecord_type_dec(this);
		}
	}

	[RuleVersion(0)]
	public Record_type_decContext record_type_dec() {
		Record_type_decContext _localctx = new Record_type_decContext(Context, State);
		EnterRule(_localctx, 206, RULE_record_type_dec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2116; Match(TYPE);
			State = 2117; type_name();
			State = 2118; Match(IS);
			State = 2137;
			switch (TokenStream.La(1)) {
			case RECORD:
				{
				State = 2119; Match(RECORD);
				State = 2120; Match(LEFT_PAREN);
				State = 2121; field_spec();
				State = 2126;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2122; Match(COMMA);
					State = 2123; field_spec();
					}
					}
					State = 2128;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 2129; Match(RIGHT_PAREN);
				}
				break;
			case REF:
				{
				State = 2131; Match(REF);
				State = 2132; Match(CURSOR);
				State = 2135;
				_la = TokenStream.La(1);
				if (_la==RETURN) {
					{
					State = 2133; Match(RETURN);
					State = 2134; type_spec();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2139; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_specContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Field_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterField_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitField_spec(this);
		}
	}

	[RuleVersion(0)]
	public Field_specContext field_spec() {
		Field_specContext _localctx = new Field_specContext(Context, State);
		EnterRule(_localctx, 208, RULE_field_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2141; column_name();
			State = 2143;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DATE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2142; type_spec();
				}
			}

			State = 2147;
			_la = TokenStream.La(1);
			if (_la==NOT) {
				{
				State = 2145; Match(NOT);
				State = 2146; Match(NULL);
				}
			}

			State = 2150;
			_la = TokenStream.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2149; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_var_decContext : ParserRuleContext {
		public Record_nameContext record_name() {
			return GetRuleContext<Record_nameContext>(0);
		}
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode PERCENT_ROWTYPE() { return GetToken(plsqlParser.PERCENT_ROWTYPE, 0); }
		public ITerminalNode PERCENT_TYPE() { return GetToken(plsqlParser.PERCENT_TYPE, 0); }
		public Record_var_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_var_dec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRecord_var_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRecord_var_dec(this);
		}
	}

	[RuleVersion(0)]
	public Record_var_decContext record_var_dec() {
		Record_var_decContext _localctx = new Record_var_decContext(Context, State);
		EnterRule(_localctx, 210, RULE_record_var_dec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2152; record_name();
			State = 2153; type_name();
			State = 2154;
			_la = TokenStream.La(1);
			if ( !(_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 2155; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_declarationContext : ParserRuleContext {
		public Table_type_decContext table_type_dec() {
			return GetRuleContext<Table_type_decContext>(0);
		}
		public Table_var_decContext table_var_dec() {
			return GetRuleContext<Table_var_decContext>(0);
		}
		public Table_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Table_declarationContext table_declaration() {
		Table_declarationContext _localctx = new Table_declarationContext(Context, State);
		EnterRule(_localctx, 212, RULE_table_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2159;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,198,Context) ) {
			case 1:
				{
				State = 2157; table_type_dec();
				}
				break;
			case 2:
				{
				State = 2158; table_var_dec();
				}
				break;
			}
			State = 2161; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_type_decContext : ParserRuleContext {
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(plsqlParser.IS, 0); }
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Varray_type_defContext varray_type_def() {
			return GetRuleContext<Varray_type_defContext>(0);
		}
		public Table_indexed_by_partContext table_indexed_by_part() {
			return GetRuleContext<Table_indexed_by_partContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Table_type_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_type_dec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_type_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_type_dec(this);
		}
	}

	[RuleVersion(0)]
	public Table_type_decContext table_type_dec() {
		Table_type_decContext _localctx = new Table_type_decContext(Context, State);
		EnterRule(_localctx, 214, RULE_table_type_dec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2163; Match(TYPE);
			State = 2164; type_name();
			State = 2165; Match(IS);
			State = 2177;
			switch (TokenStream.La(1)) {
			case TABLE:
				{
				State = 2166; Match(TABLE);
				State = 2167; Match(OF);
				State = 2168; type_spec();
				State = 2170;
				_la = TokenStream.La(1);
				if (_la==INDEX || _la==INDEXED) {
					{
					State = 2169; table_indexed_by_part();
					}
				}

				State = 2174;
				_la = TokenStream.La(1);
				if (_la==NOT) {
					{
					State = 2172; Match(NOT);
					State = 2173; Match(NULL);
					}
				}

				}
				break;
			case VARRAY:
			case VARYING:
				{
				State = 2176; varray_type_def();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_indexed_by_partContext : ParserRuleContext {
		public IToken idx1;
		public IToken idx2;
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode INDEXED() { return GetToken(plsqlParser.INDEXED, 0); }
		public ITerminalNode INDEX() { return GetToken(plsqlParser.INDEX, 0); }
		public Table_indexed_by_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_indexed_by_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_indexed_by_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_indexed_by_part(this);
		}
	}

	[RuleVersion(0)]
	public Table_indexed_by_partContext table_indexed_by_part() {
		Table_indexed_by_partContext _localctx = new Table_indexed_by_partContext(Context, State);
		EnterRule(_localctx, 216, RULE_table_indexed_by_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2181;
			switch (TokenStream.La(1)) {
			case INDEXED:
				{
				State = 2179; _localctx.idx1 = Match(INDEXED);
				}
				break;
			case INDEX:
				{
				State = 2180; _localctx.idx2 = Match(INDEX);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2183; Match(BY);
			State = 2184; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Varray_type_defContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode VARRAY() { return GetToken(plsqlParser.VARRAY, 0); }
		public ITerminalNode VARYING() { return GetToken(plsqlParser.VARYING, 0); }
		public ITerminalNode ARRAY() { return GetToken(plsqlParser.ARRAY, 0); }
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Varray_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varray_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterVarray_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitVarray_type_def(this);
		}
	}

	[RuleVersion(0)]
	public Varray_type_defContext varray_type_def() {
		Varray_type_defContext _localctx = new Varray_type_defContext(Context, State);
		EnterRule(_localctx, 218, RULE_varray_type_def);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2189;
			switch (TokenStream.La(1)) {
			case VARRAY:
				{
				State = 2186; Match(VARRAY);
				}
				break;
			case VARYING:
				{
				State = 2187; Match(VARYING);
				State = 2188; Match(ARRAY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2191; Match(LEFT_PAREN);
			State = 2192; expression();
			State = 2193; Match(RIGHT_PAREN);
			State = 2194; Match(OF);
			State = 2195; type_spec();
			State = 2198;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,204,Context) ) {
			case 1:
				{
				State = 2196; Match(NOT);
				State = 2197; Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_var_decContext : ParserRuleContext {
		public Table_var_nameContext table_var_name() {
			return GetRuleContext<Table_var_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Table_var_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_var_dec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_var_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_var_dec(this);
		}
	}

	[RuleVersion(0)]
	public Table_var_decContext table_var_dec() {
		Table_var_decContext _localctx = new Table_var_decContext(Context, State);
		EnterRule(_localctx, 220, RULE_table_var_dec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2200; table_var_name();
			State = 2201; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seq_of_statementsContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public Label_declarationContext[] label_declaration() {
			return GetRuleContexts<Label_declarationContext>();
		}
		public Label_declarationContext label_declaration(int i) {
			return GetRuleContext<Label_declarationContext>(i);
		}
		public ITerminalNode[] Eof() { return GetTokens(plsqlParser.Eof); }
		public ITerminalNode Eof(int i) {
			return GetToken(plsqlParser.Eof, i);
		}
		public Seq_of_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seq_of_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSeq_of_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSeq_of_statements(this);
		}
	}

	[RuleVersion(0)]
	public Seq_of_statementsContext seq_of_statements() {
		Seq_of_statementsContext _localctx = new Seq_of_statementsContext(Context, State);
		EnterRule(_localctx, 222, RULE_seq_of_statements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2207;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				State = 2207;
				switch (TokenStream.La(1)) {
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALTER:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BEGIN:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CREATE:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECLARE:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FETCH:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FOR:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GOTO:
				case GRANT:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IF:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSERT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCK:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PROCEDURE:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELECT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATE:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITH:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case DELIMITED_ID:
				case LEFT_PAREN:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 2203; statement();
					State = 2204;
					_la = TokenStream.La(1);
					if ( !(_la==Eof || _la==SEMICOLON) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					}
					break;
				case LESS_THAN_OP:
					{
					State = 2206; label_declaration();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 2209;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALTER) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECLARE - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DELETE - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FETCH - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FOR - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GOTO - 129)) | (1L << (GRANT - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IF - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSERT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCK - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULL - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELECT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATE - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITH - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (LEFT_PAREN - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)) | (1L << (LESS_THAN_OP - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Label_declarationContext : ParserRuleContext {
		public IToken ltp1;
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Label_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLabel_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLabel_declaration(this);
		}
	}

	[RuleVersion(0)]
	public Label_declarationContext label_declaration() {
		Label_declarationContext _localctx = new Label_declarationContext(Context, State);
		EnterRule(_localctx, 224, RULE_label_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2211; _localctx.ltp1 = Match(LESS_THAN_OP);
			State = 2212; Match(LESS_THAN_OP);
			State = 2213; label_name();
			State = 2214; Match(GREATER_THAN_OP);
			State = 2215; Match(GREATER_THAN_OP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(plsqlParser.CREATE, 0); }
		public Swallow_to_semiContext swallow_to_semi() {
			return GetRuleContext<Swallow_to_semiContext>(0);
		}
		public ITerminalNode ALTER() { return GetToken(plsqlParser.ALTER, 0); }
		public ITerminalNode GRANT() { return GetToken(plsqlParser.GRANT, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(plsqlParser.TRUNCATE, 0); }
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public Assignment_statementContext assignment_statement() {
			return GetRuleContext<Assignment_statementContext>(0);
		}
		public Continue_statementContext continue_statement() {
			return GetRuleContext<Continue_statementContext>(0);
		}
		public Exit_statementContext exit_statement() {
			return GetRuleContext<Exit_statementContext>(0);
		}
		public Goto_statementContext goto_statement() {
			return GetRuleContext<Goto_statementContext>(0);
		}
		public If_statementContext if_statement() {
			return GetRuleContext<If_statementContext>(0);
		}
		public Loop_statementContext loop_statement() {
			return GetRuleContext<Loop_statementContext>(0);
		}
		public Forall_statementContext forall_statement() {
			return GetRuleContext<Forall_statementContext>(0);
		}
		public Null_statementContext null_statement() {
			return GetRuleContext<Null_statementContext>(0);
		}
		public Raise_statementContext raise_statement() {
			return GetRuleContext<Raise_statementContext>(0);
		}
		public Return_statementContext return_statement() {
			return GetRuleContext<Return_statementContext>(0);
		}
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Sql_statementContext sql_statement() {
			return GetRuleContext<Sql_statementContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 226, RULE_statement);
		try {
			State = 2240;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,207,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2217; Match(CREATE);
				State = 2218; swallow_to_semi();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2219; Match(ALTER);
				State = 2220; swallow_to_semi();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2221; Match(GRANT);
				State = 2222; swallow_to_semi();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2223; Match(TRUNCATE);
				State = 2224; swallow_to_semi();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2225; body();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2226; block();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2227; assignment_statement();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2228; continue_statement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2229; exit_statement();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2230; goto_statement();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2231; if_statement();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2232; loop_statement();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2233; forall_statement();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2234; null_statement();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 2235; raise_statement();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 2236; return_statement();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 2237; case_statement();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 2238; sql_statement();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 2239; function_call();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assignment_statementContext : ParserRuleContext {
		public ITerminalNode ASSIGN_OP() { return GetToken(plsqlParser.ASSIGN_OP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Assignment_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAssignment_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAssignment_statement(this);
		}
	}

	[RuleVersion(0)]
	public Assignment_statementContext assignment_statement() {
		Assignment_statementContext _localctx = new Assignment_statementContext(Context, State);
		EnterRule(_localctx, 228, RULE_assignment_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2244;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2242; general_element();
				}
				break;
			case BINDVAR:
			case COLON:
				{
				State = 2243; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2246; Match(ASSIGN_OP);
			State = 2247; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Continue_statementContext : ParserRuleContext {
		public ITerminalNode CONTINUE() { return GetToken(plsqlParser.CONTINUE, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Continue_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_continue_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterContinue_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitContinue_statement(this);
		}
	}

	[RuleVersion(0)]
	public Continue_statementContext continue_statement() {
		Continue_statementContext _localctx = new Continue_statementContext(Context, State);
		EnterRule(_localctx, 230, RULE_continue_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2249; Match(CONTINUE);
			State = 2251;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2250; label_name();
				}
			}

			State = 2255;
			_la = TokenStream.La(1);
			if (_la==WHEN) {
				{
				State = 2253; Match(WHEN);
				State = 2254; condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exit_statementContext : ParserRuleContext {
		public ITerminalNode EXIT() { return GetToken(plsqlParser.EXIT, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Exit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExit_statement(this);
		}
	}

	[RuleVersion(0)]
	public Exit_statementContext exit_statement() {
		Exit_statementContext _localctx = new Exit_statementContext(Context, State);
		EnterRule(_localctx, 232, RULE_exit_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2257; Match(EXIT);
			State = 2259;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2258; label_name();
				}
			}

			State = 2263;
			_la = TokenStream.La(1);
			if (_la==WHEN) {
				{
				State = 2261; Match(WHEN);
				State = 2262; condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Goto_statementContext : ParserRuleContext {
		public ITerminalNode GOTO() { return GetToken(plsqlParser.GOTO, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Goto_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_goto_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGoto_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGoto_statement(this);
		}
	}

	[RuleVersion(0)]
	public Goto_statementContext goto_statement() {
		Goto_statementContext _localctx = new Goto_statementContext(Context, State);
		EnterRule(_localctx, 234, RULE_goto_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2265; Match(GOTO);
			State = 2266; label_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class If_statementContext : ParserRuleContext {
		public ITerminalNode[] IF() { return GetTokens(plsqlParser.IF); }
		public ITerminalNode IF(int i) {
			return GetToken(plsqlParser.IF, i);
		}
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Elsif_partContext[] elsif_part() {
			return GetRuleContexts<Elsif_partContext>();
		}
		public Elsif_partContext elsif_part(int i) {
			return GetRuleContext<Elsif_partContext>(i);
		}
		public Else_partContext else_part() {
			return GetRuleContext<Else_partContext>(0);
		}
		public If_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterIf_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitIf_statement(this);
		}
	}

	[RuleVersion(0)]
	public If_statementContext if_statement() {
		If_statementContext _localctx = new If_statementContext(Context, State);
		EnterRule(_localctx, 236, RULE_if_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2268; Match(IF);
			State = 2269; condition();
			State = 2270; Match(THEN);
			State = 2271; seq_of_statements();
			State = 2275;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==ELSIF) {
				{
				{
				State = 2272; elsif_part();
				}
				}
				State = 2277;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 2279;
			_la = TokenStream.La(1);
			if (_la==ELSE) {
				{
				State = 2278; else_part();
				}
			}

			State = 2281; Match(END);
			State = 2282; Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Elsif_partContext : ParserRuleContext {
		public ITerminalNode ELSIF() { return GetToken(plsqlParser.ELSIF, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Elsif_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsif_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterElsif_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitElsif_part(this);
		}
	}

	[RuleVersion(0)]
	public Elsif_partContext elsif_part() {
		Elsif_partContext _localctx = new Elsif_partContext(Context, State);
		EnterRule(_localctx, 238, RULE_elsif_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2284; Match(ELSIF);
			State = 2285; condition();
			State = 2286; Match(THEN);
			State = 2287; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(plsqlParser.ELSE, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterElse_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitElse_part(this);
		}
	}

	[RuleVersion(0)]
	public Else_partContext else_part() {
		Else_partContext _localctx = new Else_partContext(Context, State);
		EnterRule(_localctx, 240, RULE_else_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2289; Match(ELSE);
			State = 2290; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_statementContext : ParserRuleContext {
		public ITerminalNode[] LOOP() { return GetTokens(plsqlParser.LOOP); }
		public ITerminalNode LOOP(int i) {
			return GetToken(plsqlParser.LOOP, i);
		}
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Label_nameContext[] label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public ITerminalNode WHILE() { return GetToken(plsqlParser.WHILE, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Cursor_loop_paramContext cursor_loop_param() {
			return GetRuleContext<Cursor_loop_paramContext>(0);
		}
		public Loop_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLoop_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLoop_statement(this);
		}
	}

	[RuleVersion(0)]
	public Loop_statementContext loop_statement() {
		Loop_statementContext _localctx = new Loop_statementContext(Context, State);
		EnterRule(_localctx, 242, RULE_loop_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2293;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,215,Context) ) {
			case 1:
				{
				State = 2292; label_name();
				}
				break;
			}
			State = 2299;
			switch (TokenStream.La(1)) {
			case WHILE:
				{
				State = 2295; Match(WHILE);
				State = 2296; condition();
				}
				break;
			case FOR:
				{
				State = 2297; Match(FOR);
				State = 2298; cursor_loop_param();
				}
				break;
			case LOOP:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2301; Match(LOOP);
			State = 2302; seq_of_statements();
			State = 2303; Match(END);
			State = 2304; Match(LOOP);
			State = 2306;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2305; label_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_loop_paramContext : ParserRuleContext {
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public ITerminalNode REVERSE() { return GetToken(plsqlParser.REVERSE, 0); }
		public Record_nameContext record_name() {
			return GetRuleContext<Record_nameContext>(0);
		}
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Cursor_loop_paramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_loop_param; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_loop_param(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_loop_param(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_loop_paramContext cursor_loop_param() {
		Cursor_loop_paramContext _localctx = new Cursor_loop_paramContext(Context, State);
		EnterRule(_localctx, 244, RULE_cursor_loop_param);
		int _la;
		try {
			State = 2329;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,221,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2308; index_name();
				State = 2309; Match(IN);
				State = 2311;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,218,Context) ) {
				case 1:
					{
					State = 2310; Match(REVERSE);
					}
					break;
				}
				State = 2313; lower_bound();
				State = 2314; Match(T__0);
				State = 2315; upper_bound();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2317; record_name();
				State = 2318; Match(IN);
				State = 2327;
				switch (TokenStream.La(1)) {
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case DELIMITED_ID:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 2319; cursor_name();
					State = 2321;
					_la = TokenStream.La(1);
					if (_la==LEFT_PAREN) {
						{
						State = 2320; expression_list();
						}
					}

					}
					break;
				case LEFT_PAREN:
					{
					State = 2323; Match(LEFT_PAREN);
					State = 2324; select_statement();
					State = 2325; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Forall_statementContext : ParserRuleContext {
		public ITerminalNode FORALL() { return GetToken(plsqlParser.FORALL, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Bounds_clauseContext bounds_clause() {
			return GetRuleContext<Bounds_clauseContext>(0);
		}
		public Sql_statementContext sql_statement() {
			return GetRuleContext<Sql_statementContext>(0);
		}
		public ITerminalNode SAVE() { return GetToken(plsqlParser.SAVE, 0); }
		public ITerminalNode EXCEPTIONS() { return GetToken(plsqlParser.EXCEPTIONS, 0); }
		public Forall_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forall_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterForall_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitForall_statement(this);
		}
	}

	[RuleVersion(0)]
	public Forall_statementContext forall_statement() {
		Forall_statementContext _localctx = new Forall_statementContext(Context, State);
		EnterRule(_localctx, 246, RULE_forall_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2331; Match(FORALL);
			State = 2332; index_name();
			State = 2333; Match(IN);
			State = 2334; bounds_clause();
			State = 2335; sql_statement();
			State = 2338;
			_la = TokenStream.La(1);
			if (_la==SAVE) {
				{
				State = 2336; Match(SAVE);
				State = 2337; Match(EXCEPTIONS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bounds_clauseContext : ParserRuleContext {
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public ITerminalNode INDICES() { return GetToken(plsqlParser.INDICES, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Collection_nameContext collection_name() {
			return GetRuleContext<Collection_nameContext>(0);
		}
		public Between_boundContext between_bound() {
			return GetRuleContext<Between_boundContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(plsqlParser.VALUES, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public Bounds_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bounds_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBounds_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBounds_clause(this);
		}
	}

	[RuleVersion(0)]
	public Bounds_clauseContext bounds_clause() {
		Bounds_clauseContext _localctx = new Bounds_clauseContext(Context, State);
		EnterRule(_localctx, 248, RULE_bounds_clause);
		int _la;
		try {
			State = 2353;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,224,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2340; lower_bound();
				State = 2341; Match(T__0);
				State = 2342; upper_bound();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2344; Match(INDICES);
				State = 2345; Match(OF);
				State = 2346; collection_name();
				State = 2348;
				_la = TokenStream.La(1);
				if (_la==BETWEEN) {
					{
					State = 2347; between_bound();
					}
				}

				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2350; Match(VALUES);
				State = 2351; Match(OF);
				State = 2352; index_name();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Between_boundContext : ParserRuleContext {
		public ITerminalNode BETWEEN() { return GetToken(plsqlParser.BETWEEN, 0); }
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public ITerminalNode AND() { return GetToken(plsqlParser.AND, 0); }
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public Between_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_between_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBetween_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBetween_bound(this);
		}
	}

	[RuleVersion(0)]
	public Between_boundContext between_bound() {
		Between_boundContext _localctx = new Between_boundContext(Context, State);
		EnterRule(_localctx, 250, RULE_between_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2355; Match(BETWEEN);
			State = 2356; lower_bound();
			State = 2357; Match(AND);
			State = 2358; upper_bound();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lower_boundContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Lower_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lower_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLower_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLower_bound(this);
		}
	}

	[RuleVersion(0)]
	public Lower_boundContext lower_bound() {
		Lower_boundContext _localctx = new Lower_boundContext(Context, State);
		EnterRule(_localctx, 252, RULE_lower_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2360; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Upper_boundContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Upper_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_upper_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUpper_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUpper_bound(this);
		}
	}

	[RuleVersion(0)]
	public Upper_boundContext upper_bound() {
		Upper_boundContext _localctx = new Upper_boundContext(Context, State);
		EnterRule(_localctx, 254, RULE_upper_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2362; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Null_statementContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public Null_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_null_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNull_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNull_statement(this);
		}
	}

	[RuleVersion(0)]
	public Null_statementContext null_statement() {
		Null_statementContext _localctx = new Null_statementContext(Context, State);
		EnterRule(_localctx, 256, RULE_null_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2364; Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Raise_statementContext : ParserRuleContext {
		public ITerminalNode RAISE() { return GetToken(plsqlParser.RAISE, 0); }
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public Raise_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_raise_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRaise_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRaise_statement(this);
		}
	}

	[RuleVersion(0)]
	public Raise_statementContext raise_statement() {
		Raise_statementContext _localctx = new Raise_statementContext(Context, State);
		EnterRule(_localctx, 258, RULE_raise_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2366; Match(RAISE);
			State = 2368;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2367; exception_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_statementContext : ParserRuleContext {
		public ConditionContext cn1;
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Return_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReturn_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReturn_statement(this);
		}
	}

	[RuleVersion(0)]
	public Return_statementContext return_statement() {
		Return_statementContext _localctx = new Return_statementContext(Context, State);
		EnterRule(_localctx, 260, RULE_return_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2370; Match(RETURN);
			State = 2372;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENTITYESCAPING - 64)) | (1L << (ERR - 64)) | (1L << (ERRORS - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVALNAME - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERVAL - 128)) | (1L << (INVALIDATE - 128)) | (1L << (ISOLATION - 128)) | (1L << (ITERATE - 128)) | (1L << (JAVA - 128)) | (1L << (JOIN - 128)) | (1L << (KEEP - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NONE - 192)) | (1L << (NOSCHEMACHECK - 192)) | (1L << (NOT - 192)) | (1L << (NULL - 192)) | (1L << (NULLS - 192)) | (1L << (NUMBER - 192)) | (1L << (NUMERIC - 192)) | (1L << (NVARCHAR2 - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (OBJECT - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)) | (1L << (RELIES_ON - 256)) | (1L << (RENAME - 256)) | (1L << (REPLACE - 256)) | (1L << (RESPECT - 256)) | (1L << (RESTRICT_REFERENCES - 256)) | (1L << (RESULT - 256)) | (1L << (RESULT_CACHE - 256)) | (1L << (RETURN - 256)) | (1L << (RETURNING - 256)) | (1L << (REUSE - 256)) | (1L << (REVERSE - 256)) | (1L << (RIGHT - 256)) | (1L << (ROLLBACK - 256)) | (1L << (ROLLUP - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (STANDALONE - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)) | (1L << (SUBMULTISET - 320)) | (1L << (SUBPARTITION - 320)) | (1L << (SUBSTITUTABLE - 320)) | (1L << (SUBTYPE - 320)) | (1L << (SUCCESS - 320)) | (1L << (SUSPEND - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_UNCONSTRAINED - 320)) | (1L << (TIMEZONE_ABBR - 320)) | (1L << (TIMEZONE_HOUR - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHILE - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)) | (1L << (XML - 384)) | (1L << (XMLAGG - 384)) | (1L << (XMLATTRIBUTES - 384)) | (1L << (XMLCAST - 384)) | (1L << (XMLCOLATTVAL - 384)) | (1L << (XMLELEMENT - 384)) | (1L << (XMLEXISTS - 384)) | (1L << (XMLFOREST - 384)) | (1L << (XMLNAMESPACES - 384)) | (1L << (XMLPARSE - 384)) | (1L << (XMLPI - 384)) | (1L << (XMLQUERY - 384)) | (1L << (XMLROOT - 384)) | (1L << (XMLSERIALIZE - 384)) | (1L << (XMLTABLE - 384)) | (1L << (YEAR - 384)) | (1L << (YES - 384)) | (1L << (YMINTERVAL_UNCONSTRAINED - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)) | (1L << (PLUS_SIGN - 448)) | (1L << (MINUS_SIGN - 448)) | (1L << (BINDVAR - 448)) | (1L << (COLON - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2371; _localctx.cn1 = condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_callContext : ParserRuleContext {
		public Routine_nameContext routine_name() {
			return GetRuleContext<Routine_nameContext>(0);
		}
		public ITerminalNode CALL() { return GetToken(plsqlParser.CALL, 0); }
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public Function_callContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_call; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_call(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_call(this);
		}
	}

	[RuleVersion(0)]
	public Function_callContext function_call() {
		Function_callContext _localctx = new Function_callContext(Context, State);
		EnterRule(_localctx, 262, RULE_function_call);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2375;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,227,Context) ) {
			case 1:
				{
				State = 2374; Match(CALL);
				}
				break;
			}
			State = 2377; routine_name();
			State = 2379;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2378; function_argument();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BodyContext : ParserRuleContext {
		public ITerminalNode BEGIN() { return GetToken(plsqlParser.BEGIN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public Exception_clauseContext exception_clause() {
			return GetRuleContext<Exception_clauseContext>(0);
		}
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public BodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBody(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBody(this);
		}
	}

	[RuleVersion(0)]
	public BodyContext body() {
		BodyContext _localctx = new BodyContext(Context, State);
		EnterRule(_localctx, 264, RULE_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2381; Match(BEGIN);
			State = 2382; seq_of_statements();
			State = 2384;
			_la = TokenStream.La(1);
			if (_la==EXCEPTION) {
				{
				State = 2383; exception_clause();
				}
			}

			State = 2386; Match(END);
			State = 2388;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,230,Context) ) {
			case 1:
				{
				State = 2387; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_clauseContext : ParserRuleContext {
		public ITerminalNode EXCEPTION() { return GetToken(plsqlParser.EXCEPTION, 0); }
		public Exception_handlerContext[] exception_handler() {
			return GetRuleContexts<Exception_handlerContext>();
		}
		public Exception_handlerContext exception_handler(int i) {
			return GetRuleContext<Exception_handlerContext>(i);
		}
		public Exception_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterException_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitException_clause(this);
		}
	}

	[RuleVersion(0)]
	public Exception_clauseContext exception_clause() {
		Exception_clauseContext _localctx = new Exception_clauseContext(Context, State);
		EnterRule(_localctx, 266, RULE_exception_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2390; Match(EXCEPTION);
			State = 2392;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 2391; exception_handler();
				}
				}
				State = 2394;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==WHEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_handlerContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public Exception_nameContext[] exception_name() {
			return GetRuleContexts<Exception_nameContext>();
		}
		public Exception_nameContext exception_name(int i) {
			return GetRuleContext<Exception_nameContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode[] OR() { return GetTokens(plsqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(plsqlParser.OR, i);
		}
		public Exception_handlerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_handler; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterException_handler(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitException_handler(this);
		}
	}

	[RuleVersion(0)]
	public Exception_handlerContext exception_handler() {
		Exception_handlerContext _localctx = new Exception_handlerContext(Context, State);
		EnterRule(_localctx, 268, RULE_exception_handler);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2396; Match(WHEN);
			State = 2397; exception_name();
			State = 2402;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==OR) {
				{
				{
				State = 2398; Match(OR);
				State = 2399; exception_name();
				}
				}
				State = 2404;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 2405; Match(THEN);
			State = 2406; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_blockContext : ParserRuleContext {
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Trigger_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_block(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_blockContext trigger_block() {
		Trigger_blockContext _localctx = new Trigger_blockContext(Context, State);
		EnterRule(_localctx, 270, RULE_trigger_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2416;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECLARE - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2409;
				_la = TokenStream.La(1);
				if (_la==DECLARE) {
					{
					State = 2408; Match(DECLARE);
					}
				}

				State = 2412;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				do {
					{
					{
					State = 2411; declare_spec();
					}
					}
					State = 2414;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
				}
			}

			State = 2418; body();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode DECLARE() { return GetToken(plsqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 272, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2421;
			_la = TokenStream.La(1);
			if (_la==DECLARE) {
				{
				State = 2420; Match(DECLARE);
				}
			}

			State = 2424;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 2423; declare_spec();
				}
				}
				State = 2426;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CREATE - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (PROCEDURE - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)) | (1L << (BINDVAR - 451)) | (1L << (COLON - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID );
			State = 2428; body();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_statementContext : ParserRuleContext {
		public Execute_immediateContext execute_immediate() {
			return GetRuleContext<Execute_immediateContext>(0);
		}
		public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
			return GetRuleContext<Data_manipulation_language_statementsContext>(0);
		}
		public Cursor_manipulation_statementsContext cursor_manipulation_statements() {
			return GetRuleContext<Cursor_manipulation_statementsContext>(0);
		}
		public Transaction_control_statementsContext transaction_control_statements() {
			return GetRuleContext<Transaction_control_statementsContext>(0);
		}
		public Sql_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSql_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSql_statement(this);
		}
	}

	[RuleVersion(0)]
	public Sql_statementContext sql_statement() {
		Sql_statementContext _localctx = new Sql_statementContext(Context, State);
		EnterRule(_localctx, 274, RULE_sql_statement);
		try {
			State = 2434;
			switch (TokenStream.La(1)) {
			case EXECUTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2430; execute_immediate();
				}
				break;
			case DELETE:
			case EXPLAIN:
			case INSERT:
			case LOCK:
			case MERGE:
			case SELECT:
			case UPDATE:
			case WITH:
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2431; data_manipulation_language_statements();
				}
				break;
			case CLOSE:
			case FETCH:
			case OPEN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2432; cursor_manipulation_statements();
				}
				break;
			case COMMIT:
			case ROLLBACK:
			case SAVEPOINT:
			case SET:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2433; transaction_control_statements();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Execute_immediateContext : ParserRuleContext {
		public ITerminalNode EXECUTE() { return GetToken(plsqlParser.EXECUTE, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(plsqlParser.IMMEDIATE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public Dynamic_returning_clauseContext dynamic_returning_clause() {
			return GetRuleContext<Dynamic_returning_clauseContext>(0);
		}
		public Execute_immediateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_execute_immediate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExecute_immediate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExecute_immediate(this);
		}
	}

	[RuleVersion(0)]
	public Execute_immediateContext execute_immediate() {
		Execute_immediateContext _localctx = new Execute_immediateContext(Context, State);
		EnterRule(_localctx, 276, RULE_execute_immediate);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2436; Match(EXECUTE);
			State = 2437; Match(IMMEDIATE);
			State = 2438; expression();
			State = 2448;
			switch (TokenStream.La(1)) {
			case BULK:
			case INTO:
				{
				State = 2439; into_clause();
				State = 2441;
				_la = TokenStream.La(1);
				if (_la==USING) {
					{
					State = 2440; using_clause();
					}
				}

				}
				break;
			case USING:
				{
				State = 2443; using_clause();
				State = 2445;
				_la = TokenStream.La(1);
				if (_la==RETURN || _la==RETURNING) {
					{
					State = 2444; dynamic_returning_clause();
					}
				}

				}
				break;
			case RETURN:
			case RETURNING:
				{
				State = 2447; dynamic_returning_clause();
				}
				break;
			case Eof:
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dynamic_returning_clauseContext : ParserRuleContext {
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public ITerminalNode RETURNING() { return GetToken(plsqlParser.RETURNING, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Dynamic_returning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamic_returning_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDynamic_returning_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDynamic_returning_clause(this);
		}
	}

	[RuleVersion(0)]
	public Dynamic_returning_clauseContext dynamic_returning_clause() {
		Dynamic_returning_clauseContext _localctx = new Dynamic_returning_clauseContext(Context, State);
		EnterRule(_localctx, 278, RULE_dynamic_returning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2450;
			_la = TokenStream.La(1);
			if ( !(_la==RETURN || _la==RETURNING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 2451; into_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_manipulation_language_statementsContext : ParserRuleContext {
		public Merge_statementContext merge_statement() {
			return GetRuleContext<Merge_statementContext>(0);
		}
		public Lock_table_statementContext lock_table_statement() {
			return GetRuleContext<Lock_table_statementContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Update_statementContext update_statement() {
			return GetRuleContext<Update_statementContext>(0);
		}
		public Delete_statementContext delete_statement() {
			return GetRuleContext<Delete_statementContext>(0);
		}
		public Insert_statementContext insert_statement() {
			return GetRuleContext<Insert_statementContext>(0);
		}
		public Explain_statementContext explain_statement() {
			return GetRuleContext<Explain_statementContext>(0);
		}
		public Data_manipulation_language_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_manipulation_language_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterData_manipulation_language_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitData_manipulation_language_statements(this);
		}
	}

	[RuleVersion(0)]
	public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
		Data_manipulation_language_statementsContext _localctx = new Data_manipulation_language_statementsContext(Context, State);
		EnterRule(_localctx, 280, RULE_data_manipulation_language_statements);
		try {
			State = 2460;
			switch (TokenStream.La(1)) {
			case MERGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2453; merge_statement();
				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2454; lock_table_statement();
				}
				break;
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2455; select_statement();
				}
				break;
			case UPDATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2456; update_statement();
				}
				break;
			case DELETE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2457; delete_statement();
				}
				break;
			case INSERT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2458; insert_statement();
				}
				break;
			case EXPLAIN:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2459; explain_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_manipulation_statementsContext : ParserRuleContext {
		public Close_statementContext close_statement() {
			return GetRuleContext<Close_statementContext>(0);
		}
		public Open_statementContext open_statement() {
			return GetRuleContext<Open_statementContext>(0);
		}
		public Fetch_statementContext fetch_statement() {
			return GetRuleContext<Fetch_statementContext>(0);
		}
		public Open_for_statementContext open_for_statement() {
			return GetRuleContext<Open_for_statementContext>(0);
		}
		public Cursor_manipulation_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_manipulation_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_manipulation_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_manipulation_statements(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_manipulation_statementsContext cursor_manipulation_statements() {
		Cursor_manipulation_statementsContext _localctx = new Cursor_manipulation_statementsContext(Context, State);
		EnterRule(_localctx, 282, RULE_cursor_manipulation_statements);
		try {
			State = 2466;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,243,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2462; close_statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2463; open_statement();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2464; fetch_statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2465; open_for_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Close_statementContext : ParserRuleContext {
		public ITerminalNode CLOSE() { return GetToken(plsqlParser.CLOSE, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Close_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_close_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterClose_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitClose_statement(this);
		}
	}

	[RuleVersion(0)]
	public Close_statementContext close_statement() {
		Close_statementContext _localctx = new Close_statementContext(Context, State);
		EnterRule(_localctx, 284, RULE_close_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2468; Match(CLOSE);
			State = 2469; cursor_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Open_statementContext : ParserRuleContext {
		public ITerminalNode OPEN() { return GetToken(plsqlParser.OPEN, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Open_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_open_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOpen_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOpen_statement(this);
		}
	}

	[RuleVersion(0)]
	public Open_statementContext open_statement() {
		Open_statementContext _localctx = new Open_statementContext(Context, State);
		EnterRule(_localctx, 286, RULE_open_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2471; Match(OPEN);
			State = 2472; cursor_name();
			State = 2474;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2473; expression_list();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Fetch_statementContext : ParserRuleContext {
		public IToken it1;
		public ITerminalNode FETCH() { return GetToken(plsqlParser.FETCH, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Variable_nameContext[] variable_name() {
			return GetRuleContexts<Variable_nameContext>();
		}
		public Variable_nameContext variable_name(int i) {
			return GetRuleContext<Variable_nameContext>(i);
		}
		public ITerminalNode BULK() { return GetToken(plsqlParser.BULK, 0); }
		public ITerminalNode COLLECT() { return GetToken(plsqlParser.COLLECT, 0); }
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Fetch_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetch_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFetch_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFetch_statement(this);
		}
	}

	[RuleVersion(0)]
	public Fetch_statementContext fetch_statement() {
		Fetch_statementContext _localctx = new Fetch_statementContext(Context, State);
		EnterRule(_localctx, 288, RULE_fetch_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2476; Match(FETCH);
			State = 2477; cursor_name();
			State = 2498;
			switch (TokenStream.La(1)) {
			case INTO:
				{
				State = 2478; _localctx.it1 = Match(INTO);
				State = 2479; variable_name();
				State = 2484;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2480; Match(COMMA);
					State = 2481; variable_name();
					}
					}
					State = 2486;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			case BULK:
				{
				State = 2487; Match(BULK);
				State = 2488; Match(COLLECT);
				State = 2489; Match(INTO);
				State = 2490; variable_name();
				State = 2495;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2491; Match(COMMA);
					State = 2492; variable_name();
					}
					}
					State = 2497;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Open_for_statementContext : ParserRuleContext {
		public ITerminalNode OPEN() { return GetToken(plsqlParser.OPEN, 0); }
		public Variable_nameContext variable_name() {
			return GetRuleContext<Variable_nameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public Open_for_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_open_for_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOpen_for_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOpen_for_statement(this);
		}
	}

	[RuleVersion(0)]
	public Open_for_statementContext open_for_statement() {
		Open_for_statementContext _localctx = new Open_for_statementContext(Context, State);
		EnterRule(_localctx, 290, RULE_open_for_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2500; Match(OPEN);
			State = 2501; variable_name();
			State = 2502; Match(FOR);
			State = 2505;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,248,Context) ) {
			case 1:
				{
				State = 2503; select_statement();
				}
				break;
			case 2:
				{
				State = 2504; expression();
				}
				break;
			}
			State = 2508;
			_la = TokenStream.La(1);
			if (_la==USING) {
				{
				State = 2507; using_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Transaction_control_statementsContext : ParserRuleContext {
		public Set_transaction_commandContext set_transaction_command() {
			return GetRuleContext<Set_transaction_commandContext>(0);
		}
		public Set_constraint_commandContext set_constraint_command() {
			return GetRuleContext<Set_constraint_commandContext>(0);
		}
		public Commit_statementContext commit_statement() {
			return GetRuleContext<Commit_statementContext>(0);
		}
		public Rollback_statementContext rollback_statement() {
			return GetRuleContext<Rollback_statementContext>(0);
		}
		public Savepoint_statementContext savepoint_statement() {
			return GetRuleContext<Savepoint_statementContext>(0);
		}
		public Transaction_control_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transaction_control_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTransaction_control_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTransaction_control_statements(this);
		}
	}

	[RuleVersion(0)]
	public Transaction_control_statementsContext transaction_control_statements() {
		Transaction_control_statementsContext _localctx = new Transaction_control_statementsContext(Context, State);
		EnterRule(_localctx, 292, RULE_transaction_control_statements);
		try {
			State = 2515;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,250,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2510; set_transaction_command();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2511; set_constraint_command();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2512; commit_statement();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2513; rollback_statement();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2514; savepoint_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_transaction_commandContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(plsqlParser.TRANSACTION, 0); }
		public ITerminalNode READ() { return GetToken(plsqlParser.READ, 0); }
		public ITerminalNode ISOLATION() { return GetToken(plsqlParser.ISOLATION, 0); }
		public ITerminalNode LEVEL() { return GetToken(plsqlParser.LEVEL, 0); }
		public ITerminalNode USE() { return GetToken(plsqlParser.USE, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(plsqlParser.ROLLBACK, 0); }
		public ITerminalNode SEGMENT() { return GetToken(plsqlParser.SEGMENT, 0); }
		public Rollback_segment_nameContext rollback_segment_name() {
			return GetRuleContext<Rollback_segment_nameContext>(0);
		}
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public ITerminalNode WRITE() { return GetToken(plsqlParser.WRITE, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(plsqlParser.SERIALIZABLE, 0); }
		public ITerminalNode COMMITTED() { return GetToken(plsqlParser.COMMITTED, 0); }
		public Set_transaction_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_transaction_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSet_transaction_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSet_transaction_command(this);
		}
	}

	[RuleVersion(0)]
	public Set_transaction_commandContext set_transaction_command() {
		Set_transaction_commandContext _localctx = new Set_transaction_commandContext(Context, State);
		EnterRule(_localctx, 294, RULE_set_transaction_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2517; Match(SET);
			State = 2518; Match(TRANSACTION);
			State = 2532;
			switch (TokenStream.La(1)) {
			case READ:
				{
				State = 2519; Match(READ);
				State = 2520;
				_la = TokenStream.La(1);
				if ( !(_la==ONLY || _la==WRITE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			case ISOLATION:
				{
				State = 2521; Match(ISOLATION);
				State = 2522; Match(LEVEL);
				State = 2526;
				switch (TokenStream.La(1)) {
				case SERIALIZABLE:
					{
					State = 2523; Match(SERIALIZABLE);
					}
					break;
				case READ:
					{
					State = 2524; Match(READ);
					State = 2525; Match(COMMITTED);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case USE:
				{
				State = 2528; Match(USE);
				State = 2529; Match(ROLLBACK);
				State = 2530; Match(SEGMENT);
				State = 2531; rollback_segment_name();
				}
				break;
			case Eof:
			case NAME:
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2536;
			_la = TokenStream.La(1);
			if (_la==NAME) {
				{
				State = 2534; Match(NAME);
				State = 2535; quoted_string();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_constraint_commandContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(plsqlParser.CONSTRAINT, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(plsqlParser.CONSTRAINTS, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(plsqlParser.IMMEDIATE, 0); }
		public ITerminalNode DEFERRED() { return GetToken(plsqlParser.DEFERRED, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Constraint_nameContext[] constraint_name() {
			return GetRuleContexts<Constraint_nameContext>();
		}
		public Constraint_nameContext constraint_name(int i) {
			return GetRuleContext<Constraint_nameContext>(i);
		}
		public Set_constraint_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_constraint_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSet_constraint_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSet_constraint_command(this);
		}
	}

	[RuleVersion(0)]
	public Set_constraint_commandContext set_constraint_command() {
		Set_constraint_commandContext _localctx = new Set_constraint_commandContext(Context, State);
		EnterRule(_localctx, 296, RULE_set_constraint_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2538; Match(SET);
			State = 2539;
			_la = TokenStream.La(1);
			if ( !(_la==CONSTRAINT || _la==CONSTRAINTS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 2549;
			switch (TokenStream.La(1)) {
			case ALL:
				{
				State = 2540; Match(ALL);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2541; constraint_name();
				State = 2546;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2542; Match(COMMA);
					State = 2543; constraint_name();
					}
					}
					State = 2548;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2551;
			_la = TokenStream.La(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Commit_statementContext : ParserRuleContext {
		public ITerminalNode COMMIT() { return GetToken(plsqlParser.COMMIT, 0); }
		public ITerminalNode WORK() { return GetToken(plsqlParser.WORK, 0); }
		public ITerminalNode COMMENT() { return GetToken(plsqlParser.COMMENT, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public Write_clauseContext write_clause() {
			return GetRuleContext<Write_clauseContext>(0);
		}
		public ITerminalNode CORRUPT_XID() { return GetToken(plsqlParser.CORRUPT_XID, 0); }
		public ITerminalNode CORRUPT_XID_ALL() { return GetToken(plsqlParser.CORRUPT_XID_ALL, 0); }
		public Commit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCommit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCommit_statement(this);
		}
	}

	[RuleVersion(0)]
	public Commit_statementContext commit_statement() {
		Commit_statementContext _localctx = new Commit_statementContext(Context, State);
		EnterRule(_localctx, 298, RULE_commit_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2553; Match(COMMIT);
			State = 2555;
			_la = TokenStream.La(1);
			if (_la==WORK) {
				{
				State = 2554; Match(WORK);
				}
			}

			State = 2570;
			switch (TokenStream.La(1)) {
			case COMMENT:
				{
				State = 2557; Match(COMMENT);
				State = 2558; expression();
				}
				break;
			case FORCE:
				{
				State = 2559; Match(FORCE);
				State = 2568;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,258,Context) ) {
				case 1:
					{
					State = 2560; Match(CORRUPT_XID);
					State = 2561; expression();
					}
					break;
				case 2:
					{
					State = 2562; Match(CORRUPT_XID_ALL);
					}
					break;
				case 3:
					{
					State = 2563; expression();
					State = 2566;
					_la = TokenStream.La(1);
					if (_la==COMMA) {
						{
						State = 2564; Match(COMMA);
						State = 2565; expression();
						}
					}

					}
					break;
				}
				}
				break;
			case Eof:
			case SAVE:
			case WRITE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2573;
			_la = TokenStream.La(1);
			if (_la==WRITE) {
				{
				State = 2572; write_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Write_clauseContext : ParserRuleContext {
		public ITerminalNode WRITE() { return GetToken(plsqlParser.WRITE, 0); }
		public ITerminalNode WAIT() { return GetToken(plsqlParser.WAIT, 0); }
		public ITerminalNode NOWAIT() { return GetToken(plsqlParser.NOWAIT, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(plsqlParser.IMMEDIATE, 0); }
		public ITerminalNode BATCH() { return GetToken(plsqlParser.BATCH, 0); }
		public Write_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_write_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWrite_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWrite_clause(this);
		}
	}

	[RuleVersion(0)]
	public Write_clauseContext write_clause() {
		Write_clauseContext _localctx = new Write_clauseContext(Context, State);
		EnterRule(_localctx, 300, RULE_write_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2575; Match(WRITE);
			State = 2577;
			_la = TokenStream.La(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 2576;
				_la = TokenStream.La(1);
				if ( !(_la==NOWAIT || _la==WAIT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			State = 2580;
			_la = TokenStream.La(1);
			if (_la==BATCH || _la==IMMEDIATE) {
				{
				State = 2579;
				_la = TokenStream.La(1);
				if ( !(_la==BATCH || _la==IMMEDIATE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollback_statementContext : ParserRuleContext {
		public ITerminalNode ROLLBACK() { return GetToken(plsqlParser.ROLLBACK, 0); }
		public ITerminalNode WORK() { return GetToken(plsqlParser.WORK, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public Savepoint_nameContext savepoint_name() {
			return GetRuleContext<Savepoint_nameContext>(0);
		}
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode SAVEPOINT() { return GetToken(plsqlParser.SAVEPOINT, 0); }
		public Rollback_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollback_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRollback_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRollback_statement(this);
		}
	}

	[RuleVersion(0)]
	public Rollback_statementContext rollback_statement() {
		Rollback_statementContext _localctx = new Rollback_statementContext(Context, State);
		EnterRule(_localctx, 302, RULE_rollback_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2582; Match(ROLLBACK);
			State = 2584;
			_la = TokenStream.La(1);
			if (_la==WORK) {
				{
				State = 2583; Match(WORK);
				}
			}

			State = 2593;
			switch (TokenStream.La(1)) {
			case TO:
				{
				State = 2586; Match(TO);
				State = 2588;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,264,Context) ) {
				case 1:
					{
					State = 2587; Match(SAVEPOINT);
					}
					break;
				}
				State = 2590; savepoint_name();
				}
				break;
			case FORCE:
				{
				State = 2591; Match(FORCE);
				State = 2592; quoted_string();
				}
				break;
			case Eof:
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Savepoint_statementContext : ParserRuleContext {
		public ITerminalNode SAVEPOINT() { return GetToken(plsqlParser.SAVEPOINT, 0); }
		public Savepoint_nameContext savepoint_name() {
			return GetRuleContext<Savepoint_nameContext>(0);
		}
		public Savepoint_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepoint_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSavepoint_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSavepoint_statement(this);
		}
	}

	[RuleVersion(0)]
	public Savepoint_statementContext savepoint_statement() {
		Savepoint_statementContext _localctx = new Savepoint_statementContext(Context, State);
		EnterRule(_localctx, 304, RULE_savepoint_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2595; Match(SAVEPOINT);
			State = 2596; savepoint_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Explain_statementContext : ParserRuleContext {
		public ITerminalNode EXPLAIN() { return GetToken(plsqlParser.EXPLAIN, 0); }
		public ITerminalNode PLAN() { return GetToken(plsqlParser.PLAN, 0); }
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Update_statementContext update_statement() {
			return GetRuleContext<Update_statementContext>(0);
		}
		public Delete_statementContext delete_statement() {
			return GetRuleContext<Delete_statementContext>(0);
		}
		public Insert_statementContext insert_statement() {
			return GetRuleContext<Insert_statementContext>(0);
		}
		public Merge_statementContext merge_statement() {
			return GetRuleContext<Merge_statementContext>(0);
		}
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode STATEMENT_ID() { return GetToken(plsqlParser.STATEMENT_ID, 0); }
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Explain_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explain_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExplain_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExplain_statement(this);
		}
	}

	[RuleVersion(0)]
	public Explain_statementContext explain_statement() {
		Explain_statementContext _localctx = new Explain_statementContext(Context, State);
		EnterRule(_localctx, 306, RULE_explain_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2598; Match(EXPLAIN);
			State = 2599; Match(PLAN);
			State = 2604;
			_la = TokenStream.La(1);
			if (_la==SET) {
				{
				State = 2600; Match(SET);
				State = 2601; Match(STATEMENT_ID);
				State = 2602; Match(EQUALS_OP);
				State = 2603; quoted_string();
				}
			}

			State = 2608;
			_la = TokenStream.La(1);
			if (_la==INTO) {
				{
				State = 2606; Match(INTO);
				State = 2607; tableview_name();
				}
			}

			State = 2610; Match(FOR);
			State = 2616;
			switch (TokenStream.La(1)) {
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				{
				State = 2611; select_statement();
				}
				break;
			case UPDATE:
				{
				State = 2612; update_statement();
				}
				break;
			case DELETE:
				{
				State = 2613; delete_statement();
				}
				break;
			case INSERT:
				{
				State = 2614; insert_statement();
				}
				break;
			case MERGE:
				{
				State = 2615; merge_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_statementContext : ParserRuleContext {
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Subquery_factoring_clauseContext subquery_factoring_clause() {
			return GetRuleContext<Subquery_factoring_clauseContext>(0);
		}
		public For_update_clauseContext[] for_update_clause() {
			return GetRuleContexts<For_update_clauseContext>();
		}
		public For_update_clauseContext for_update_clause(int i) {
			return GetRuleContext<For_update_clauseContext>(i);
		}
		public Order_by_clauseContext[] order_by_clause() {
			return GetRuleContexts<Order_by_clauseContext>();
		}
		public Order_by_clauseContext order_by_clause(int i) {
			return GetRuleContext<Order_by_clauseContext>(i);
		}
		public Select_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSelect_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSelect_statement(this);
		}
	}

	[RuleVersion(0)]
	public Select_statementContext select_statement() {
		Select_statementContext _localctx = new Select_statementContext(Context, State);
		EnterRule(_localctx, 308, RULE_select_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2619;
			_la = TokenStream.La(1);
			if (_la==WITH) {
				{
				State = 2618; subquery_factoring_clause();
				}
			}

			State = 2621; subquery();
			State = 2626;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==FOR || _la==ORDER) {
				{
				State = 2624;
				switch (TokenStream.La(1)) {
				case FOR:
					{
					State = 2622; for_update_clause();
					}
					break;
				case ORDER:
					{
					State = 2623; order_by_clause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 2628;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_factoring_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public Factoring_elementContext[] factoring_element() {
			return GetRuleContexts<Factoring_elementContext>();
		}
		public Factoring_elementContext factoring_element(int i) {
			return GetRuleContext<Factoring_elementContext>(i);
		}
		public Subquery_factoring_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_factoring_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery_factoring_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery_factoring_clause(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_factoring_clauseContext subquery_factoring_clause() {
		Subquery_factoring_clauseContext _localctx = new Subquery_factoring_clauseContext(Context, State);
		EnterRule(_localctx, 310, RULE_subquery_factoring_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2629; Match(WITH);
			State = 2630; factoring_element();
			State = 2635;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2631; Match(COMMA);
				State = 2632; factoring_element();
				}
				}
				State = 2637;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Factoring_elementContext : ParserRuleContext {
		public Query_nameContext query_name() {
			return GetRuleContext<Query_nameContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Search_clauseContext search_clause() {
			return GetRuleContext<Search_clauseContext>(0);
		}
		public Cycle_clauseContext cycle_clause() {
			return GetRuleContext<Cycle_clauseContext>(0);
		}
		public Factoring_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_factoring_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFactoring_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFactoring_element(this);
		}
	}

	[RuleVersion(0)]
	public Factoring_elementContext factoring_element() {
		Factoring_elementContext _localctx = new Factoring_elementContext(Context, State);
		EnterRule(_localctx, 312, RULE_factoring_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2638; query_name();
			State = 2650;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2639; Match(LEFT_PAREN);
				State = 2640; column_name();
				State = 2645;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2641; Match(COMMA);
					State = 2642; column_name();
					}
					}
					State = 2647;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 2648; Match(RIGHT_PAREN);
				}
			}

			State = 2652; Match(AS);
			State = 2653; Match(LEFT_PAREN);
			State = 2654; subquery();
			State = 2656;
			_la = TokenStream.La(1);
			if (_la==ORDER) {
				{
				State = 2655; order_by_clause();
				}
			}

			State = 2658; Match(RIGHT_PAREN);
			State = 2660;
			_la = TokenStream.La(1);
			if (_la==SEARCH) {
				{
				State = 2659; search_clause();
				}
			}

			State = 2663;
			_la = TokenStream.La(1);
			if (_la==CYCLE) {
				{
				State = 2662; cycle_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Search_clauseContext : ParserRuleContext {
		public ITerminalNode SEARCH() { return GetToken(plsqlParser.SEARCH, 0); }
		public ITerminalNode[] FIRST() { return GetTokens(plsqlParser.FIRST); }
		public ITerminalNode FIRST(int i) {
			return GetToken(plsqlParser.FIRST, i);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode DEPTH() { return GetToken(plsqlParser.DEPTH, 0); }
		public ITerminalNode BREADTH() { return GetToken(plsqlParser.BREADTH, 0); }
		public ITerminalNode[] ASC() { return GetTokens(plsqlParser.ASC); }
		public ITerminalNode ASC(int i) {
			return GetToken(plsqlParser.ASC, i);
		}
		public ITerminalNode[] DESC() { return GetTokens(plsqlParser.DESC); }
		public ITerminalNode DESC(int i) {
			return GetToken(plsqlParser.DESC, i);
		}
		public ITerminalNode[] NULLS() { return GetTokens(plsqlParser.NULLS); }
		public ITerminalNode NULLS(int i) {
			return GetToken(plsqlParser.NULLS, i);
		}
		public ITerminalNode[] LAST() { return GetTokens(plsqlParser.LAST); }
		public ITerminalNode LAST(int i) {
			return GetToken(plsqlParser.LAST, i);
		}
		public Search_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_search_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSearch_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSearch_clause(this);
		}
	}

	[RuleVersion(0)]
	public Search_clauseContext search_clause() {
		Search_clauseContext _localctx = new Search_clauseContext(Context, State);
		EnterRule(_localctx, 314, RULE_search_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2665; Match(SEARCH);
			State = 2666;
			_la = TokenStream.La(1);
			if ( !(_la==BREADTH || _la==DEPTH) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 2667; Match(FIRST);
			State = 2668; Match(BY);
			State = 2669; column_name();
			State = 2671;
			_la = TokenStream.La(1);
			if (_la==ASC) {
				{
				State = 2670; Match(ASC);
				}
			}

			State = 2674;
			_la = TokenStream.La(1);
			if (_la==DESC) {
				{
				State = 2673; Match(DESC);
				}
			}

			State = 2678;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,280,Context) ) {
			case 1:
				{
				State = 2676; Match(NULLS);
				State = 2677; Match(FIRST);
				}
				break;
			}
			State = 2682;
			_la = TokenStream.La(1);
			if (_la==NULLS) {
				{
				State = 2680; Match(NULLS);
				State = 2681; Match(LAST);
				}
			}

			State = 2702;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2684; Match(COMMA);
				State = 2685; column_name();
				State = 2687;
				_la = TokenStream.La(1);
				if (_la==ASC) {
					{
					State = 2686; Match(ASC);
					}
				}

				State = 2690;
				_la = TokenStream.La(1);
				if (_la==DESC) {
					{
					State = 2689; Match(DESC);
					}
				}

				State = 2694;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,284,Context) ) {
				case 1:
					{
					State = 2692; Match(NULLS);
					State = 2693; Match(FIRST);
					}
					break;
				}
				State = 2698;
				_la = TokenStream.La(1);
				if (_la==NULLS) {
					{
					State = 2696; Match(NULLS);
					State = 2697; Match(LAST);
					}
				}

				}
				}
				State = 2704;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 2705; Match(SET);
			State = 2706; column_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cycle_clauseContext : ParserRuleContext {
		public ITerminalNode CYCLE() { return GetToken(plsqlParser.CYCLE, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Cycle_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cycle_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCycle_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCycle_clause(this);
		}
	}

	[RuleVersion(0)]
	public Cycle_clauseContext cycle_clause() {
		Cycle_clauseContext _localctx = new Cycle_clauseContext(Context, State);
		EnterRule(_localctx, 316, RULE_cycle_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2708; Match(CYCLE);
			State = 2709; column_name();
			State = 2714;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2710; Match(COMMA);
				State = 2711; column_name();
				}
				}
				State = 2716;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 2717; Match(SET);
			State = 2718; column_name();
			State = 2719; Match(TO);
			State = 2720; expression();
			State = 2721; Match(DEFAULT);
			State = 2722; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryContext : ParserRuleContext {
		public Subquery_basic_elementsContext subquery_basic_elements() {
			return GetRuleContext<Subquery_basic_elementsContext>(0);
		}
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public SubqueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryContext subquery() {
		SubqueryContext _localctx = new SubqueryContext(Context, State);
		EnterRule(_localctx, 318, RULE_subquery);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2724; subquery_basic_elements();
			State = 2728;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==INTERSECT || _la==MINUS || _la==UNION) {
				{
				{
				State = 2725; subquery_operation_part();
				}
				}
				State = 2730;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_operation_partContext : ParserRuleContext {
		public Subquery_basic_elementsContext subquery_basic_elements() {
			return GetRuleContext<Subquery_basic_elementsContext>(0);
		}
		public ITerminalNode UNION() { return GetToken(plsqlParser.UNION, 0); }
		public ITerminalNode INTERSECT() { return GetToken(plsqlParser.INTERSECT, 0); }
		public ITerminalNode MINUS() { return GetToken(plsqlParser.MINUS, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Subquery_operation_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_operation_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery_operation_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery_operation_part(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_operation_partContext subquery_operation_part() {
		Subquery_operation_partContext _localctx = new Subquery_operation_partContext(Context, State);
		EnterRule(_localctx, 320, RULE_subquery_operation_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2737;
			switch (TokenStream.La(1)) {
			case UNION:
				{
				State = 2731; Match(UNION);
				State = 2733;
				_la = TokenStream.La(1);
				if (_la==ALL) {
					{
					State = 2732; Match(ALL);
					}
				}

				}
				break;
			case INTERSECT:
				{
				State = 2735; Match(INTERSECT);
				}
				break;
			case MINUS:
				{
				State = 2736; Match(MINUS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2739; subquery_basic_elements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_basic_elementsContext : ParserRuleContext {
		public Query_blockContext query_block() {
			return GetRuleContext<Query_blockContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Subquery_basic_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_basic_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery_basic_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery_basic_elements(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_basic_elementsContext subquery_basic_elements() {
		Subquery_basic_elementsContext _localctx = new Subquery_basic_elementsContext(Context, State);
		EnterRule(_localctx, 322, RULE_subquery_basic_elements);
		try {
			State = 2746;
			switch (TokenStream.La(1)) {
			case SELECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2741; query_block();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2742; Match(LEFT_PAREN);
				State = 2743; subquery();
				State = 2744; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_blockContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(plsqlParser.SELECT, 0); }
		public From_clauseContext from_clause() {
			return GetRuleContext<From_clauseContext>(0);
		}
		public Selected_elementContext[] selected_element() {
			return GetRuleContexts<Selected_elementContext>();
		}
		public Selected_elementContext selected_element(int i) {
			return GetRuleContext<Selected_elementContext>(i);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Hierarchical_query_clauseContext hierarchical_query_clause() {
			return GetRuleContext<Hierarchical_query_clauseContext>(0);
		}
		public Group_by_clauseContext group_by_clause() {
			return GetRuleContext<Group_by_clauseContext>(0);
		}
		public Model_clauseContext model_clause() {
			return GetRuleContext<Model_clauseContext>(0);
		}
		public ITerminalNode DISTINCT() { return GetToken(plsqlParser.DISTINCT, 0); }
		public ITerminalNode UNIQUE() { return GetToken(plsqlParser.UNIQUE, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Query_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuery_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuery_block(this);
		}
	}

	[RuleVersion(0)]
	public Query_blockContext query_block() {
		Query_blockContext _localctx = new Query_blockContext(Context, State);
		EnterRule(_localctx, 324, RULE_query_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2748; Match(SELECT);
			State = 2750;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,292,Context) ) {
			case 1:
				{
				State = 2749;
				_la = TokenStream.La(1);
				if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			}
			State = 2761;
			switch (TokenStream.La(1)) {
			case ASTERISK:
				{
				State = 2752; Match(ASTERISK);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2753; selected_element();
				State = 2758;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2754; Match(COMMA);
					State = 2755; selected_element();
					}
					}
					State = 2760;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2764;
			_la = TokenStream.La(1);
			if (_la==BULK || _la==INTO) {
				{
				State = 2763; into_clause();
				}
			}

			State = 2766; from_clause();
			State = 2768;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,296,Context) ) {
			case 1:
				{
				State = 2767; where_clause();
				}
				break;
			}
			State = 2771;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,297,Context) ) {
			case 1:
				{
				State = 2770; hierarchical_query_clause();
				}
				break;
			}
			State = 2774;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,298,Context) ) {
			case 1:
				{
				State = 2773; group_by_clause();
				}
				break;
			}
			State = 2777;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,299,Context) ) {
			case 1:
				{
				State = 2776; model_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selected_elementContext : ParserRuleContext {
		public Select_list_elementsContext select_list_elements() {
			return GetRuleContext<Select_list_elementsContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Selected_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selected_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSelected_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSelected_element(this);
		}
	}

	[RuleVersion(0)]
	public Selected_elementContext selected_element() {
		Selected_elementContext _localctx = new Selected_elementContext(Context, State);
		EnterRule(_localctx, 326, RULE_selected_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2779; select_list_elements();
			State = 2781;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,300,Context) ) {
			case 1:
				{
				State = 2780; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class From_clauseContext : ParserRuleContext {
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public Table_ref_listContext table_ref_list() {
			return GetRuleContext<Table_ref_listContext>(0);
		}
		public From_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_from_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFrom_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFrom_clause(this);
		}
	}

	[RuleVersion(0)]
	public From_clauseContext from_clause() {
		From_clauseContext _localctx = new From_clauseContext(Context, State);
		EnterRule(_localctx, 328, RULE_from_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2783; Match(FROM);
			State = 2784; table_ref_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_list_elementsContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Select_list_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_list_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSelect_list_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSelect_list_elements(this);
		}
	}

	[RuleVersion(0)]
	public Select_list_elementsContext select_list_elements() {
		Select_list_elementsContext _localctx = new Select_list_elementsContext(Context, State);
		EnterRule(_localctx, 330, RULE_select_list_elements);
		try {
			State = 2791;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,301,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2786; tableview_name();
				State = 2787; Match(PERIOD);
				State = 2788; Match(ASTERISK);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2790; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_listContext : ParserRuleContext {
		public Table_refContext[] table_ref() {
			return GetRuleContexts<Table_refContext>();
		}
		public Table_refContext table_ref(int i) {
			return GetRuleContext<Table_refContext>(i);
		}
		public Table_ref_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_list(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_listContext table_ref_list() {
		Table_ref_listContext _localctx = new Table_ref_listContext(Context, State);
		EnterRule(_localctx, 332, RULE_table_ref_list);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2793; table_ref();
			State = 2798;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,302,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2794; Match(COMMA);
					State = 2795; table_ref();
					}
					} 
				}
				State = 2800;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,302,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_refContext : ParserRuleContext {
		public Table_ref_auxContext table_ref_aux() {
			return GetRuleContext<Table_ref_auxContext>(0);
		}
		public Join_clauseContext[] join_clause() {
			return GetRuleContexts<Join_clauseContext>();
		}
		public Join_clauseContext join_clause(int i) {
			return GetRuleContext<Join_clauseContext>(i);
		}
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Table_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref(this);
		}
	}

	[RuleVersion(0)]
	public Table_refContext table_ref() {
		Table_refContext _localctx = new Table_refContext(Context, State);
		EnterRule(_localctx, 334, RULE_table_ref);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2801; table_ref_aux();
			State = 2805;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,303,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2802; join_clause();
					}
					} 
				}
				State = 2807;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,303,Context);
			}
			State = 2810;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,304,Context) ) {
			case 1:
				{
				State = 2808; pivot_clause();
				}
				break;
			case 2:
				{
				State = 2809; unpivot_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_auxContext : ParserRuleContext {
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public Table_refContext table_ref() {
			return GetRuleContext<Table_refContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public Flashback_query_clauseContext[] flashback_query_clause() {
			return GetRuleContexts<Flashback_query_clauseContext>();
		}
		public Flashback_query_clauseContext flashback_query_clause(int i) {
			return GetRuleContext<Flashback_query_clauseContext>(i);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public Table_ref_auxContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_aux; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_aux(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_aux(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_auxContext table_ref_aux() {
		Table_ref_auxContext _localctx = new Table_ref_auxContext(Context, State);
		EnterRule(_localctx, 336, RULE_table_ref_aux);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2840;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,309,Context) ) {
			case 1:
				{
				State = 2812; dml_table_expression_clause();
				State = 2815;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,305,Context) ) {
				case 1:
					{
					State = 2813; pivot_clause();
					}
					break;
				case 2:
					{
					State = 2814; unpivot_clause();
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 2817; Match(LEFT_PAREN);
				State = 2818; table_ref();
				State = 2822;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==INTERSECT || _la==MINUS || _la==UNION) {
					{
					{
					State = 2819; subquery_operation_part();
					}
					}
					State = 2824;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 2825; Match(RIGHT_PAREN);
				State = 2828;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,307,Context) ) {
				case 1:
					{
					State = 2826; pivot_clause();
					}
					break;
				case 2:
					{
					State = 2827; unpivot_clause();
					}
					break;
				}
				}
				break;
			case 3:
				{
				State = 2830; Match(ONLY);
				State = 2831; Match(LEFT_PAREN);
				State = 2832; dml_table_expression_clause();
				State = 2833; Match(RIGHT_PAREN);
				}
				break;
			case 4:
				{
				State = 2835; dml_table_expression_clause();
				State = 2838;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,308,Context) ) {
				case 1:
					{
					State = 2836; pivot_clause();
					}
					break;
				case 2:
					{
					State = 2837; unpivot_clause();
					}
					break;
				}
				}
				break;
			}
			State = 2845;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,310,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2842; flashback_query_clause();
					}
					} 
				}
				State = 2847;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,310,Context);
			}
			State = 2849;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,311,Context) ) {
			case 1:
				{
				State = 2848; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_clauseContext : ParserRuleContext {
		public ITerminalNode JOIN() { return GetToken(plsqlParser.JOIN, 0); }
		public Table_ref_auxContext table_ref_aux() {
			return GetRuleContext<Table_ref_auxContext>(0);
		}
		public Query_partition_clauseContext[] query_partition_clause() {
			return GetRuleContexts<Query_partition_clauseContext>();
		}
		public Query_partition_clauseContext query_partition_clause(int i) {
			return GetRuleContext<Query_partition_clauseContext>(i);
		}
		public ITerminalNode INNER() { return GetToken(plsqlParser.INNER, 0); }
		public Outer_join_typeContext outer_join_type() {
			return GetRuleContext<Outer_join_typeContext>(0);
		}
		public Join_on_partContext[] join_on_part() {
			return GetRuleContexts<Join_on_partContext>();
		}
		public Join_on_partContext join_on_part(int i) {
			return GetRuleContext<Join_on_partContext>(i);
		}
		public Join_using_partContext[] join_using_part() {
			return GetRuleContexts<Join_using_partContext>();
		}
		public Join_using_partContext join_using_part(int i) {
			return GetRuleContext<Join_using_partContext>(i);
		}
		public ITerminalNode CROSS() { return GetToken(plsqlParser.CROSS, 0); }
		public ITerminalNode NATURAL() { return GetToken(plsqlParser.NATURAL, 0); }
		public Join_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterJoin_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitJoin_clause(this);
		}
	}

	[RuleVersion(0)]
	public Join_clauseContext join_clause() {
		Join_clauseContext _localctx = new Join_clauseContext(Context, State);
		EnterRule(_localctx, 338, RULE_join_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2852;
			_la = TokenStream.La(1);
			if (_la==PARTITION) {
				{
				State = 2851; query_partition_clause();
				}
			}

			State = 2855;
			_la = TokenStream.La(1);
			if (_la==CROSS || _la==NATURAL) {
				{
				State = 2854;
				_la = TokenStream.La(1);
				if ( !(_la==CROSS || _la==NATURAL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			State = 2859;
			switch (TokenStream.La(1)) {
			case INNER:
				{
				State = 2857; Match(INNER);
				}
				break;
			case FULL:
			case LEFT:
			case RIGHT:
				{
				State = 2858; outer_join_type();
				}
				break;
			case JOIN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2861; Match(JOIN);
			State = 2862; table_ref_aux();
			State = 2864;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,315,Context) ) {
			case 1:
				{
				State = 2863; query_partition_clause();
				}
				break;
			}
			State = 2870;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,317,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					State = 2868;
					switch (TokenStream.La(1)) {
					case ON:
						{
						State = 2866; join_on_part();
						}
						break;
					case USING:
						{
						State = 2867; join_using_part();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 2872;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,317,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_on_partContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Join_on_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_on_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterJoin_on_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitJoin_on_part(this);
		}
	}

	[RuleVersion(0)]
	public Join_on_partContext join_on_part() {
		Join_on_partContext _localctx = new Join_on_partContext(Context, State);
		EnterRule(_localctx, 340, RULE_join_on_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2873; Match(ON);
			State = 2874; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_using_partContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Join_using_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_using_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterJoin_using_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitJoin_using_part(this);
		}
	}

	[RuleVersion(0)]
	public Join_using_partContext join_using_part() {
		Join_using_partContext _localctx = new Join_using_partContext(Context, State);
		EnterRule(_localctx, 342, RULE_join_using_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2876; Match(USING);
			State = 2877; Match(LEFT_PAREN);
			State = 2878; column_name();
			State = 2883;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2879; Match(COMMA);
				State = 2880; column_name();
				}
				}
				State = 2885;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 2886; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Outer_join_typeContext : ParserRuleContext {
		public ITerminalNode FULL() { return GetToken(plsqlParser.FULL, 0); }
		public ITerminalNode LEFT() { return GetToken(plsqlParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(plsqlParser.RIGHT, 0); }
		public ITerminalNode OUTER() { return GetToken(plsqlParser.OUTER, 0); }
		public Outer_join_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outer_join_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOuter_join_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOuter_join_type(this);
		}
	}

	[RuleVersion(0)]
	public Outer_join_typeContext outer_join_type() {
		Outer_join_typeContext _localctx = new Outer_join_typeContext(Context, State);
		EnterRule(_localctx, 344, RULE_outer_join_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2888;
			_la = TokenStream.La(1);
			if ( !(_la==FULL || _la==LEFT || _la==RIGHT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 2890;
			_la = TokenStream.La(1);
			if (_la==OUTER) {
				{
				State = 2889; Match(OUTER);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_partition_clauseContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Query_partition_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_partition_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuery_partition_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuery_partition_clause(this);
		}
	}

	[RuleVersion(0)]
	public Query_partition_clauseContext query_partition_clause() {
		Query_partition_clauseContext _localctx = new Query_partition_clauseContext(Context, State);
		EnterRule(_localctx, 346, RULE_query_partition_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2892; Match(PARTITION);
			State = 2893; Match(BY);
			State = 2907;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,321,Context) ) {
			case 1:
				{
				State = 2894; Match(LEFT_PAREN);
				State = 2895; subquery();
				State = 2896; Match(RIGHT_PAREN);
				}
				break;
			case 2:
				{
				State = 2898; expression_list();
				}
				break;
			case 3:
				{
				State = 2899; expression();
				State = 2904;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,320,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 2900; Match(COMMA);
						State = 2901; expression();
						}
						} 
					}
					State = 2906;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,320,Context);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Flashback_query_clauseContext : ParserRuleContext {
		public ITerminalNode VERSIONS() { return GetToken(plsqlParser.VERSIONS, 0); }
		public ITerminalNode BETWEEN() { return GetToken(plsqlParser.BETWEEN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode SCN() { return GetToken(plsqlParser.SCN, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(plsqlParser.TIMESTAMP, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(plsqlParser.SNAPSHOT, 0); }
		public Flashback_query_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashback_query_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFlashback_query_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFlashback_query_clause(this);
		}
	}

	[RuleVersion(0)]
	public Flashback_query_clauseContext flashback_query_clause() {
		Flashback_query_clauseContext _localctx = new Flashback_query_clauseContext(Context, State);
		EnterRule(_localctx, 348, RULE_flashback_query_clause);
		int _la;
		try {
			State = 2917;
			switch (TokenStream.La(1)) {
			case VERSIONS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2909; Match(VERSIONS);
				State = 2910; Match(BETWEEN);
				State = 2911;
				_la = TokenStream.La(1);
				if ( !(_la==SCN || _la==TIMESTAMP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 2912; expression();
				}
				break;
			case AS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2913; Match(AS);
				State = 2914; Match(OF);
				State = 2915;
				_la = TokenStream.La(1);
				if ( !(((((_la - 329)) & ~0x3f) == 0 && ((1L << (_la - 329)) & ((1L << (SCN - 329)) | (1L << (SNAPSHOT - 329)) | (1L << (TIMESTAMP - 329)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 2916; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_clauseContext : ParserRuleContext {
		public ITerminalNode PIVOT() { return GetToken(plsqlParser.PIVOT, 0); }
		public Pivot_elementContext[] pivot_element() {
			return GetRuleContexts<Pivot_elementContext>();
		}
		public Pivot_elementContext pivot_element(int i) {
			return GetRuleContext<Pivot_elementContext>(i);
		}
		public Pivot_for_clauseContext pivot_for_clause() {
			return GetRuleContext<Pivot_for_clauseContext>(0);
		}
		public Pivot_in_clauseContext pivot_in_clause() {
			return GetRuleContext<Pivot_in_clauseContext>(0);
		}
		public ITerminalNode XML() { return GetToken(plsqlParser.XML, 0); }
		public Pivot_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_clause(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_clauseContext pivot_clause() {
		Pivot_clauseContext _localctx = new Pivot_clauseContext(Context, State);
		EnterRule(_localctx, 350, RULE_pivot_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2919; Match(PIVOT);
			State = 2921;
			_la = TokenStream.La(1);
			if (_la==XML) {
				{
				State = 2920; Match(XML);
				}
			}

			State = 2923; Match(LEFT_PAREN);
			State = 2924; pivot_element();
			State = 2929;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2925; Match(COMMA);
				State = 2926; pivot_element();
				}
				}
				State = 2931;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 2932; pivot_for_clause();
			State = 2933; pivot_in_clause();
			State = 2934; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_elementContext : ParserRuleContext {
		public Aggregate_function_nameContext aggregate_function_name() {
			return GetRuleContext<Aggregate_function_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Pivot_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_element(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_elementContext pivot_element() {
		Pivot_elementContext _localctx = new Pivot_elementContext(Context, State);
		EnterRule(_localctx, 352, RULE_pivot_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2936; aggregate_function_name();
			State = 2937; Match(LEFT_PAREN);
			State = 2938; expression();
			State = 2939; Match(RIGHT_PAREN);
			State = 2941;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2940; column_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_for_clauseContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Pivot_for_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_for_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_for_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_for_clause(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_for_clauseContext pivot_for_clause() {
		Pivot_for_clauseContext _localctx = new Pivot_for_clauseContext(Context, State);
		EnterRule(_localctx, 354, RULE_pivot_for_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2943; Match(FOR);
			State = 2956;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2944; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 2945; Match(LEFT_PAREN);
				State = 2946; column_name();
				State = 2951;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2947; Match(COMMA);
					State = 2948; column_name();
					}
					}
					State = 2953;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 2954; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clauseContext : ParserRuleContext {
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode[] ANY() { return GetTokens(plsqlParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(plsqlParser.ANY, i);
		}
		public Pivot_in_clause_elementContext[] pivot_in_clause_element() {
			return GetRuleContexts<Pivot_in_clause_elementContext>();
		}
		public Pivot_in_clause_elementContext pivot_in_clause_element(int i) {
			return GetRuleContext<Pivot_in_clause_elementContext>(i);
		}
		public Pivot_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clauseContext pivot_in_clause() {
		Pivot_in_clauseContext _localctx = new Pivot_in_clauseContext(Context, State);
		EnterRule(_localctx, 356, RULE_pivot_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2958; Match(IN);
			State = 2959; Match(LEFT_PAREN);
			State = 2977;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,330,Context) ) {
			case 1:
				{
				State = 2960; subquery();
				}
				break;
			case 2:
				{
				State = 2961; Match(ANY);
				State = 2966;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2962; Match(COMMA);
					State = 2963; Match(ANY);
					}
					}
					State = 2968;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			case 3:
				{
				State = 2969; pivot_in_clause_element();
				State = 2974;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2970; Match(COMMA);
					State = 2971; pivot_in_clause_element();
					}
					}
					State = 2976;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			}
			State = 2979; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clause_elementContext : ParserRuleContext {
		public Pivot_in_clause_elementsContext pivot_in_clause_elements() {
			return GetRuleContext<Pivot_in_clause_elementsContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Pivot_in_clause_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause_element(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clause_elementContext pivot_in_clause_element() {
		Pivot_in_clause_elementContext _localctx = new Pivot_in_clause_elementContext(Context, State);
		EnterRule(_localctx, 358, RULE_pivot_in_clause_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2981; pivot_in_clause_elements();
			State = 2983;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2982; column_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clause_elementsContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Pivot_in_clause_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause_elements(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clause_elementsContext pivot_in_clause_elements() {
		Pivot_in_clause_elementsContext _localctx = new Pivot_in_clause_elementsContext(Context, State);
		EnterRule(_localctx, 360, RULE_pivot_in_clause_elements);
		try {
			State = 2987;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,332,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2985; expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2986; expression_list();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_clauseContext : ParserRuleContext {
		public ITerminalNode UNPIVOT() { return GetToken(plsqlParser.UNPIVOT, 0); }
		public Pivot_for_clauseContext pivot_for_clause() {
			return GetRuleContext<Pivot_for_clauseContext>(0);
		}
		public Unpivot_in_clauseContext unpivot_in_clause() {
			return GetRuleContext<Unpivot_in_clauseContext>(0);
		}
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode NULLS() { return GetToken(plsqlParser.NULLS, 0); }
		public ITerminalNode INCLUDE() { return GetToken(plsqlParser.INCLUDE, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(plsqlParser.EXCLUDE, 0); }
		public Unpivot_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_clause(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_clauseContext unpivot_clause() {
		Unpivot_clauseContext _localctx = new Unpivot_clauseContext(Context, State);
		EnterRule(_localctx, 362, RULE_unpivot_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2989; Match(UNPIVOT);
			State = 2992;
			_la = TokenStream.La(1);
			if (_la==EXCLUDE || _la==INCLUDE) {
				{
				State = 2990;
				_la = TokenStream.La(1);
				if ( !(_la==EXCLUDE || _la==INCLUDE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 2991; Match(NULLS);
				}
			}

			State = 2994; Match(LEFT_PAREN);
			State = 3007;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2995; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 2996; Match(LEFT_PAREN);
				State = 2997; column_name();
				State = 3002;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2998; Match(COMMA);
					State = 2999; column_name();
					}
					}
					State = 3004;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 3005; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3009; pivot_for_clause();
			State = 3010; unpivot_in_clause();
			State = 3011; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_in_clauseContext : ParserRuleContext {
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Unpivot_in_elementsContext[] unpivot_in_elements() {
			return GetRuleContexts<Unpivot_in_elementsContext>();
		}
		public Unpivot_in_elementsContext unpivot_in_elements(int i) {
			return GetRuleContext<Unpivot_in_elementsContext>(i);
		}
		public Unpivot_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_in_clause(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_in_clauseContext unpivot_in_clause() {
		Unpivot_in_clauseContext _localctx = new Unpivot_in_clauseContext(Context, State);
		EnterRule(_localctx, 364, RULE_unpivot_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3013; Match(IN);
			State = 3014; Match(LEFT_PAREN);
			State = 3015; unpivot_in_elements();
			State = 3020;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3016; Match(COMMA);
				State = 3017; unpivot_in_elements();
				}
				}
				State = 3022;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3023; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_in_elementsContext : ParserRuleContext {
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		public Unpivot_in_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_in_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_in_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_in_elements(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_in_elementsContext unpivot_in_elements() {
		Unpivot_in_elementsContext _localctx = new Unpivot_in_elementsContext(Context, State);
		EnterRule(_localctx, 366, RULE_unpivot_in_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3037;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3025; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3026; Match(LEFT_PAREN);
				State = 3027; column_name();
				State = 3032;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3028; Match(COMMA);
					State = 3029; column_name();
					}
					}
					State = 3034;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 3035; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3054;
			_la = TokenStream.La(1);
			if (_la==AS) {
				{
				State = 3039; Match(AS);
				State = 3052;
				switch (TokenStream.La(1)) {
				case DATE:
				case DBTIMEZONE:
				case DEFAULT:
				case FALSE:
				case INTERVAL:
				case MAXVALUE:
				case MINVALUE:
				case NULL:
				case SESSIONTIMEZONE:
				case TIMESTAMP:
				case TRUE:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
					{
					State = 3040; constant();
					}
					break;
				case LEFT_PAREN:
					{
					State = 3041; Match(LEFT_PAREN);
					State = 3042; constant();
					State = 3047;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
					while (_la==COMMA) {
						{
						{
						State = 3043; Match(COMMA);
						State = 3044; constant();
						}
						}
						State = 3049;
						ErrorHandler.Sync(this);
						_la = TokenStream.La(1);
					}
					State = 3050; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Hierarchical_query_clauseContext : ParserRuleContext {
		public ITerminalNode CONNECT() { return GetToken(plsqlParser.CONNECT, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode NOCYCLE() { return GetToken(plsqlParser.NOCYCLE, 0); }
		public Start_partContext start_part() {
			return GetRuleContext<Start_partContext>(0);
		}
		public Hierarchical_query_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hierarchical_query_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterHierarchical_query_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitHierarchical_query_clause(this);
		}
	}

	[RuleVersion(0)]
	public Hierarchical_query_clauseContext hierarchical_query_clause() {
		Hierarchical_query_clauseContext _localctx = new Hierarchical_query_clauseContext(Context, State);
		EnterRule(_localctx, 368, RULE_hierarchical_query_clause);
		try {
			State = 3073;
			switch (TokenStream.La(1)) {
			case CONNECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3056; Match(CONNECT);
				State = 3057; Match(BY);
				State = 3059;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,342,Context) ) {
				case 1:
					{
					State = 3058; Match(NOCYCLE);
					}
					break;
				}
				State = 3061; condition();
				State = 3063;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,343,Context) ) {
				case 1:
					{
					State = 3062; start_part();
					}
					break;
				}
				}
				break;
			case START:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3065; start_part();
				State = 3066; Match(CONNECT);
				State = 3067; Match(BY);
				State = 3069;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,344,Context) ) {
				case 1:
					{
					State = 3068; Match(NOCYCLE);
					}
					break;
				}
				State = 3071; condition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Start_partContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(plsqlParser.START, 0); }
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Start_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStart_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStart_part(this);
		}
	}

	[RuleVersion(0)]
	public Start_partContext start_part() {
		Start_partContext _localctx = new Start_partContext(Context, State);
		EnterRule(_localctx, 370, RULE_start_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3075; Match(START);
			State = 3076; Match(WITH);
			State = 3077; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_by_clauseContext : ParserRuleContext {
		public ITerminalNode GROUP() { return GetToken(plsqlParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Group_by_elementsContext[] group_by_elements() {
			return GetRuleContexts<Group_by_elementsContext>();
		}
		public Group_by_elementsContext group_by_elements(int i) {
			return GetRuleContext<Group_by_elementsContext>(i);
		}
		public Having_clauseContext having_clause() {
			return GetRuleContext<Having_clauseContext>(0);
		}
		public Group_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGroup_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGroup_by_clause(this);
		}
	}

	[RuleVersion(0)]
	public Group_by_clauseContext group_by_clause() {
		Group_by_clauseContext _localctx = new Group_by_clauseContext(Context, State);
		EnterRule(_localctx, 372, RULE_group_by_clause);
		try {
			int _alt;
			State = 3105;
			switch (TokenStream.La(1)) {
			case GROUP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3079; Match(GROUP);
				State = 3080; Match(BY);
				State = 3081; group_by_elements();
				State = 3086;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,346,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 3082; Match(COMMA);
						State = 3083; group_by_elements();
						}
						} 
					}
					State = 3088;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,346,Context);
				}
				State = 3090;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,347,Context) ) {
				case 1:
					{
					State = 3089; having_clause();
					}
					break;
				}
				}
				break;
			case HAVING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3092; having_clause();
				State = 3103;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,349,Context) ) {
				case 1:
					{
					State = 3093; Match(GROUP);
					State = 3094; Match(BY);
					State = 3095; group_by_elements();
					State = 3100;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,348,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 3096; Match(COMMA);
							State = 3097; group_by_elements();
							}
							} 
						}
						State = 3102;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,348,Context);
					}
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_by_elementsContext : ParserRuleContext {
		public Grouping_sets_clauseContext grouping_sets_clause() {
			return GetRuleContext<Grouping_sets_clauseContext>(0);
		}
		public Rollup_cube_clauseContext rollup_cube_clause() {
			return GetRuleContext<Rollup_cube_clauseContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Group_by_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_by_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGroup_by_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGroup_by_elements(this);
		}
	}

	[RuleVersion(0)]
	public Group_by_elementsContext group_by_elements() {
		Group_by_elementsContext _localctx = new Group_by_elementsContext(Context, State);
		EnterRule(_localctx, 374, RULE_group_by_elements);
		try {
			State = 3110;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,351,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3107; grouping_sets_clause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3108; rollup_cube_clause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3109; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollup_cube_clauseContext : ParserRuleContext {
		public Grouping_sets_elementsContext[] grouping_sets_elements() {
			return GetRuleContexts<Grouping_sets_elementsContext>();
		}
		public Grouping_sets_elementsContext grouping_sets_elements(int i) {
			return GetRuleContext<Grouping_sets_elementsContext>(i);
		}
		public ITerminalNode ROLLUP() { return GetToken(plsqlParser.ROLLUP, 0); }
		public ITerminalNode CUBE() { return GetToken(plsqlParser.CUBE, 0); }
		public Rollup_cube_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollup_cube_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRollup_cube_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRollup_cube_clause(this);
		}
	}

	[RuleVersion(0)]
	public Rollup_cube_clauseContext rollup_cube_clause() {
		Rollup_cube_clauseContext _localctx = new Rollup_cube_clauseContext(Context, State);
		EnterRule(_localctx, 376, RULE_rollup_cube_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3112;
			_la = TokenStream.La(1);
			if ( !(_la==CUBE || _la==ROLLUP) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 3113; Match(LEFT_PAREN);
			State = 3114; grouping_sets_elements();
			State = 3119;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3115; Match(COMMA);
				State = 3116; grouping_sets_elements();
				}
				}
				State = 3121;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3122; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_sets_clauseContext : ParserRuleContext {
		public ITerminalNode GROUPING() { return GetToken(plsqlParser.GROUPING, 0); }
		public ITerminalNode SETS() { return GetToken(plsqlParser.SETS, 0); }
		public Grouping_sets_elementsContext[] grouping_sets_elements() {
			return GetRuleContexts<Grouping_sets_elementsContext>();
		}
		public Grouping_sets_elementsContext grouping_sets_elements(int i) {
			return GetRuleContext<Grouping_sets_elementsContext>(i);
		}
		public Grouping_sets_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_sets_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGrouping_sets_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGrouping_sets_clause(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_sets_clauseContext grouping_sets_clause() {
		Grouping_sets_clauseContext _localctx = new Grouping_sets_clauseContext(Context, State);
		EnterRule(_localctx, 378, RULE_grouping_sets_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3124; Match(GROUPING);
			State = 3125; Match(SETS);
			State = 3126; Match(LEFT_PAREN);
			State = 3127; grouping_sets_elements();
			State = 3132;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3128; Match(COMMA);
				State = 3129; grouping_sets_elements();
				}
				}
				State = 3134;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3135; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_sets_elementsContext : ParserRuleContext {
		public Rollup_cube_clauseContext rollup_cube_clause() {
			return GetRuleContext<Rollup_cube_clauseContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Grouping_sets_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_sets_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGrouping_sets_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGrouping_sets_elements(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_sets_elementsContext grouping_sets_elements() {
		Grouping_sets_elementsContext _localctx = new Grouping_sets_elementsContext(Context, State);
		EnterRule(_localctx, 380, RULE_grouping_sets_elements);
		try {
			State = 3140;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,354,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3137; rollup_cube_clause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3138; expression_list();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3139; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Having_clauseContext : ParserRuleContext {
		public ITerminalNode HAVING() { return GetToken(plsqlParser.HAVING, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Having_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_having_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterHaving_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitHaving_clause(this);
		}
	}

	[RuleVersion(0)]
	public Having_clauseContext having_clause() {
		Having_clauseContext _localctx = new Having_clauseContext(Context, State);
		EnterRule(_localctx, 382, RULE_having_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3142; Match(HAVING);
			State = 3143; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_clauseContext : ParserRuleContext {
		public ITerminalNode MODEL() { return GetToken(plsqlParser.MODEL, 0); }
		public Main_modelContext main_model() {
			return GetRuleContext<Main_modelContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Return_rows_clauseContext return_rows_clause() {
			return GetRuleContext<Return_rows_clauseContext>(0);
		}
		public Reference_modelContext[] reference_model() {
			return GetRuleContexts<Reference_modelContext>();
		}
		public Reference_modelContext reference_model(int i) {
			return GetRuleContext<Reference_modelContext>(i);
		}
		public Model_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_clause(this);
		}
	}

	[RuleVersion(0)]
	public Model_clauseContext model_clause() {
		Model_clauseContext _localctx = new Model_clauseContext(Context, State);
		EnterRule(_localctx, 384, RULE_model_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3145; Match(MODEL);
			State = 3149;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3146; cell_reference_options();
				}
				}
				State = 3151;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3153;
			_la = TokenStream.La(1);
			if (_la==RETURN) {
				{
				State = 3152; return_rows_clause();
				}
			}

			State = 3158;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==REFERENCE) {
				{
				{
				State = 3155; reference_model();
				}
				}
				State = 3160;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3161; main_model();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cell_reference_optionsContext : ParserRuleContext {
		public ITerminalNode NAV() { return GetToken(plsqlParser.NAV, 0); }
		public ITerminalNode IGNORE() { return GetToken(plsqlParser.IGNORE, 0); }
		public ITerminalNode KEEP() { return GetToken(plsqlParser.KEEP, 0); }
		public ITerminalNode UNIQUE() { return GetToken(plsqlParser.UNIQUE, 0); }
		public ITerminalNode DIMENSION() { return GetToken(plsqlParser.DIMENSION, 0); }
		public ITerminalNode SINGLE() { return GetToken(plsqlParser.SINGLE, 0); }
		public ITerminalNode REFERENCE() { return GetToken(plsqlParser.REFERENCE, 0); }
		public Cell_reference_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cell_reference_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCell_reference_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCell_reference_options(this);
		}
	}

	[RuleVersion(0)]
	public Cell_reference_optionsContext cell_reference_options() {
		Cell_reference_optionsContext _localctx = new Cell_reference_optionsContext(Context, State);
		EnterRule(_localctx, 386, RULE_cell_reference_options);
		int _la;
		try {
			State = 3171;
			switch (TokenStream.La(1)) {
			case IGNORE:
			case KEEP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3163;
				_la = TokenStream.La(1);
				if ( !(_la==IGNORE || _la==KEEP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 3164; Match(NAV);
				}
				break;
			case UNIQUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3165; Match(UNIQUE);
				State = 3169;
				switch (TokenStream.La(1)) {
				case DIMENSION:
					{
					State = 3166; Match(DIMENSION);
					}
					break;
				case SINGLE:
					{
					State = 3167; Match(SINGLE);
					State = 3168; Match(REFERENCE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_rows_clauseContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode ROWS() { return GetToken(plsqlParser.ROWS, 0); }
		public ITerminalNode UPDATED() { return GetToken(plsqlParser.UPDATED, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Return_rows_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_rows_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReturn_rows_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReturn_rows_clause(this);
		}
	}

	[RuleVersion(0)]
	public Return_rows_clauseContext return_rows_clause() {
		Return_rows_clauseContext _localctx = new Return_rows_clauseContext(Context, State);
		EnterRule(_localctx, 388, RULE_return_rows_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3173; Match(RETURN);
			State = 3174;
			_la = TokenStream.La(1);
			if ( !(_la==ALL || _la==UPDATED) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 3175; Match(ROWS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_modelContext : ParserRuleContext {
		public ITerminalNode REFERENCE() { return GetToken(plsqlParser.REFERENCE, 0); }
		public Reference_model_nameContext reference_model_name() {
			return GetRuleContext<Reference_model_nameContext>(0);
		}
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Model_column_clausesContext model_column_clauses() {
			return GetRuleContext<Model_column_clausesContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Reference_modelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_model; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReference_model(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReference_model(this);
		}
	}

	[RuleVersion(0)]
	public Reference_modelContext reference_model() {
		Reference_modelContext _localctx = new Reference_modelContext(Context, State);
		EnterRule(_localctx, 390, RULE_reference_model);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3177; Match(REFERENCE);
			State = 3178; reference_model_name();
			State = 3179; Match(ON);
			State = 3180; Match(LEFT_PAREN);
			State = 3181; subquery();
			State = 3182; Match(RIGHT_PAREN);
			State = 3183; model_column_clauses();
			State = 3187;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3184; cell_reference_options();
				}
				}
				State = 3189;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Main_modelContext : ParserRuleContext {
		public Model_column_clausesContext model_column_clauses() {
			return GetRuleContext<Model_column_clausesContext>(0);
		}
		public Model_rules_clauseContext model_rules_clause() {
			return GetRuleContext<Model_rules_clauseContext>(0);
		}
		public ITerminalNode MAIN() { return GetToken(plsqlParser.MAIN, 0); }
		public Main_model_nameContext main_model_name() {
			return GetRuleContext<Main_model_nameContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Main_modelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main_model; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMain_model(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMain_model(this);
		}
	}

	[RuleVersion(0)]
	public Main_modelContext main_model() {
		Main_modelContext _localctx = new Main_modelContext(Context, State);
		EnterRule(_localctx, 392, RULE_main_model);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3192;
			_la = TokenStream.La(1);
			if (_la==MAIN) {
				{
				State = 3190; Match(MAIN);
				State = 3191; main_model_name();
				}
			}

			State = 3194; model_column_clauses();
			State = 3198;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3195; cell_reference_options();
				}
				}
				State = 3200;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3201; model_rules_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_clausesContext : ParserRuleContext {
		public ITerminalNode DIMENSION() { return GetToken(plsqlParser.DIMENSION, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Model_column_listContext[] model_column_list() {
			return GetRuleContexts<Model_column_listContext>();
		}
		public Model_column_listContext model_column_list(int i) {
			return GetRuleContext<Model_column_listContext>(i);
		}
		public ITerminalNode MEASURES() { return GetToken(plsqlParser.MEASURES, 0); }
		public Model_column_partition_partContext model_column_partition_part() {
			return GetRuleContext<Model_column_partition_partContext>(0);
		}
		public Model_column_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_clauses; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_column_clauses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_column_clauses(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_clausesContext model_column_clauses() {
		Model_column_clausesContext _localctx = new Model_column_clausesContext(Context, State);
		EnterRule(_localctx, 394, RULE_model_column_clauses);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3204;
			_la = TokenStream.La(1);
			if (_la==PARTITION) {
				{
				State = 3203; model_column_partition_part();
				}
			}

			State = 3206; Match(DIMENSION);
			State = 3207; Match(BY);
			State = 3208; model_column_list();
			State = 3209; Match(MEASURES);
			State = 3210; model_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_partition_partContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Model_column_listContext model_column_list() {
			return GetRuleContext<Model_column_listContext>(0);
		}
		public Model_column_partition_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_partition_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_column_partition_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_column_partition_part(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_partition_partContext model_column_partition_part() {
		Model_column_partition_partContext _localctx = new Model_column_partition_partContext(Context, State);
		EnterRule(_localctx, 396, RULE_model_column_partition_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3212; Match(PARTITION);
			State = 3213; Match(BY);
			State = 3214; model_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_listContext : ParserRuleContext {
		public Model_columnContext[] model_column() {
			return GetRuleContexts<Model_columnContext>();
		}
		public Model_columnContext model_column(int i) {
			return GetRuleContext<Model_columnContext>(i);
		}
		public Model_column_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_column_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_column_list(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_listContext model_column_list() {
		Model_column_listContext _localctx = new Model_column_listContext(Context, State);
		EnterRule(_localctx, 398, RULE_model_column_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3216; Match(LEFT_PAREN);
			State = 3217; model_column();
			State = 3222;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3218; Match(COMMA);
				State = 3219; model_column();
				}
				}
				State = 3224;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3225; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_columnContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Model_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_column(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_column(this);
		}
	}

	[RuleVersion(0)]
	public Model_columnContext model_column() {
		Model_columnContext _localctx = new Model_columnContext(Context, State);
		EnterRule(_localctx, 400, RULE_model_column);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3227; expression();
			State = 3229;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3228; table_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_clauseContext : ParserRuleContext {
		public Model_rules_elementContext[] model_rules_element() {
			return GetRuleContexts<Model_rules_elementContext>();
		}
		public Model_rules_elementContext model_rules_element(int i) {
			return GetRuleContext<Model_rules_elementContext>(i);
		}
		public Model_rules_partContext model_rules_part() {
			return GetRuleContext<Model_rules_partContext>(0);
		}
		public Model_rules_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_clause(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_clauseContext model_rules_clause() {
		Model_rules_clauseContext _localctx = new Model_rules_clauseContext(Context, State);
		EnterRule(_localctx, 402, RULE_model_rules_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3232;
			_la = TokenStream.La(1);
			if (_la==RULES) {
				{
				State = 3231; model_rules_part();
				}
			}

			State = 3234; Match(LEFT_PAREN);
			State = 3235; model_rules_element();
			State = 3240;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3236; Match(COMMA);
				State = 3237; model_rules_element();
				}
				}
				State = 3242;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3243; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_partContext : ParserRuleContext {
		public ITerminalNode RULES() { return GetToken(plsqlParser.RULES, 0); }
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public ITerminalNode UPSERT() { return GetToken(plsqlParser.UPSERT, 0); }
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public Model_iterate_clauseContext model_iterate_clause() {
			return GetRuleContext<Model_iterate_clauseContext>(0);
		}
		public ITerminalNode AUTOMATIC() { return GetToken(plsqlParser.AUTOMATIC, 0); }
		public ITerminalNode SEQUENTIAL() { return GetToken(plsqlParser.SEQUENTIAL, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Model_rules_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_part(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_partContext model_rules_part() {
		Model_rules_partContext _localctx = new Model_rules_partContext(Context, State);
		EnterRule(_localctx, 404, RULE_model_rules_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3245; Match(RULES);
			State = 3251;
			switch (TokenStream.La(1)) {
			case UPDATE:
				{
				State = 3246; Match(UPDATE);
				}
				break;
			case UPSERT:
				{
				State = 3247; Match(UPSERT);
				State = 3249;
				_la = TokenStream.La(1);
				if (_la==ALL) {
					{
					State = 3248; Match(ALL);
					}
				}

				}
				break;
			case AUTOMATIC:
			case ITERATE:
			case SEQUENTIAL:
			case LEFT_PAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3255;
			_la = TokenStream.La(1);
			if (_la==AUTOMATIC || _la==SEQUENTIAL) {
				{
				State = 3253;
				_la = TokenStream.La(1);
				if ( !(_la==AUTOMATIC || _la==SEQUENTIAL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 3254; Match(ORDER);
				}
			}

			State = 3258;
			_la = TokenStream.La(1);
			if (_la==ITERATE) {
				{
				State = 3257; model_iterate_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_elementContext : ParserRuleContext {
		public Cell_assignmentContext cell_assignment() {
			return GetRuleContext<Cell_assignmentContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public ITerminalNode UPSERT() { return GetToken(plsqlParser.UPSERT, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Model_rules_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_element(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_elementContext model_rules_element() {
		Model_rules_elementContext _localctx = new Model_rules_elementContext(Context, State);
		EnterRule(_localctx, 406, RULE_model_rules_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3265;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,373,Context) ) {
			case 1:
				{
				State = 3260; Match(UPDATE);
				}
				break;
			case 2:
				{
				State = 3261; Match(UPSERT);
				State = 3263;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,372,Context) ) {
				case 1:
					{
					State = 3262; Match(ALL);
					}
					break;
				}
				}
				break;
			}
			State = 3267; cell_assignment();
			State = 3269;
			_la = TokenStream.La(1);
			if (_la==ORDER) {
				{
				State = 3268; order_by_clause();
				}
			}

			State = 3271; Match(EQUALS_OP);
			State = 3272; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cell_assignmentContext : ParserRuleContext {
		public Model_expressionContext model_expression() {
			return GetRuleContext<Model_expressionContext>(0);
		}
		public Cell_assignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cell_assignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCell_assignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCell_assignment(this);
		}
	}

	[RuleVersion(0)]
	public Cell_assignmentContext cell_assignment() {
		Cell_assignmentContext _localctx = new Cell_assignmentContext(Context, State);
		EnterRule(_localctx, 408, RULE_cell_assignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3274; model_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_iterate_clauseContext : ParserRuleContext {
		public ITerminalNode ITERATE() { return GetToken(plsqlParser.ITERATE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Until_partContext until_part() {
			return GetRuleContext<Until_partContext>(0);
		}
		public Model_iterate_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_iterate_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_iterate_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_iterate_clause(this);
		}
	}

	[RuleVersion(0)]
	public Model_iterate_clauseContext model_iterate_clause() {
		Model_iterate_clauseContext _localctx = new Model_iterate_clauseContext(Context, State);
		EnterRule(_localctx, 410, RULE_model_iterate_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3276; Match(ITERATE);
			State = 3277; Match(LEFT_PAREN);
			State = 3278; expression();
			State = 3279; Match(RIGHT_PAREN);
			State = 3281;
			_la = TokenStream.La(1);
			if (_la==UNTIL) {
				{
				State = 3280; until_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Until_partContext : ParserRuleContext {
		public ITerminalNode UNTIL() { return GetToken(plsqlParser.UNTIL, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Until_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_until_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUntil_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUntil_part(this);
		}
	}

	[RuleVersion(0)]
	public Until_partContext until_part() {
		Until_partContext _localctx = new Until_partContext(Context, State);
		EnterRule(_localctx, 412, RULE_until_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3283; Match(UNTIL);
			State = 3284; Match(LEFT_PAREN);
			State = 3285; condition();
			State = 3286; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_by_clauseContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Order_by_elementsContext[] order_by_elements() {
			return GetRuleContexts<Order_by_elementsContext>();
		}
		public Order_by_elementsContext order_by_elements(int i) {
			return GetRuleContext<Order_by_elementsContext>(i);
		}
		public ITerminalNode SIBLINGS() { return GetToken(plsqlParser.SIBLINGS, 0); }
		public Order_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOrder_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOrder_by_clause(this);
		}
	}

	[RuleVersion(0)]
	public Order_by_clauseContext order_by_clause() {
		Order_by_clauseContext _localctx = new Order_by_clauseContext(Context, State);
		EnterRule(_localctx, 414, RULE_order_by_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3288; Match(ORDER);
			State = 3290;
			_la = TokenStream.La(1);
			if (_la==SIBLINGS) {
				{
				State = 3289; Match(SIBLINGS);
				}
			}

			State = 3292; Match(BY);
			State = 3293; order_by_elements();
			State = 3298;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3294; Match(COMMA);
				State = 3295; order_by_elements();
				}
				}
				State = 3300;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_by_elementsContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NULLS() { return GetToken(plsqlParser.NULLS, 0); }
		public ITerminalNode ASC() { return GetToken(plsqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(plsqlParser.DESC, 0); }
		public ITerminalNode FIRST() { return GetToken(plsqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(plsqlParser.LAST, 0); }
		public Order_by_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_by_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOrder_by_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOrder_by_elements(this);
		}
	}

	[RuleVersion(0)]
	public Order_by_elementsContext order_by_elements() {
		Order_by_elementsContext _localctx = new Order_by_elementsContext(Context, State);
		EnterRule(_localctx, 416, RULE_order_by_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3301; expression();
			State = 3303;
			_la = TokenStream.La(1);
			if (_la==ASC || _la==DESC) {
				{
				State = 3302;
				_la = TokenStream.La(1);
				if ( !(_la==ASC || _la==DESC) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			State = 3307;
			_la = TokenStream.La(1);
			if (_la==NULLS) {
				{
				State = 3305; Match(NULLS);
				State = 3306;
				_la = TokenStream.La(1);
				if ( !(_la==FIRST || _la==LAST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_clauseContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public For_update_of_partContext for_update_of_part() {
			return GetRuleContext<For_update_of_partContext>(0);
		}
		public For_update_optionsContext for_update_options() {
			return GetRuleContext<For_update_optionsContext>(0);
		}
		public For_update_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_update_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_update_clause(this);
		}
	}

	[RuleVersion(0)]
	public For_update_clauseContext for_update_clause() {
		For_update_clauseContext _localctx = new For_update_clauseContext(Context, State);
		EnterRule(_localctx, 418, RULE_for_update_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3309; Match(FOR);
			State = 3310; Match(UPDATE);
			State = 3312;
			_la = TokenStream.La(1);
			if (_la==OF) {
				{
				State = 3311; for_update_of_part();
				}
			}

			State = 3315;
			_la = TokenStream.La(1);
			if (_la==NOWAIT || _la==SKIP_ || _la==WAIT) {
				{
				State = 3314; for_update_options();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_of_partContext : ParserRuleContext {
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public For_update_of_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_of_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_update_of_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_update_of_part(this);
		}
	}

	[RuleVersion(0)]
	public For_update_of_partContext for_update_of_part() {
		For_update_of_partContext _localctx = new For_update_of_partContext(Context, State);
		EnterRule(_localctx, 420, RULE_for_update_of_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3317; Match(OF);
			State = 3318; column_name();
			State = 3323;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3319; Match(COMMA);
				State = 3320; column_name();
				}
				}
				State = 3325;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_optionsContext : ParserRuleContext {
		public ITerminalNode SKIP_() { return GetToken(plsqlParser.SKIP_, 0); }
		public ITerminalNode LOCKED() { return GetToken(plsqlParser.LOCKED, 0); }
		public ITerminalNode NOWAIT() { return GetToken(plsqlParser.NOWAIT, 0); }
		public ITerminalNode WAIT() { return GetToken(plsqlParser.WAIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public For_update_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_update_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_update_options(this);
		}
	}

	[RuleVersion(0)]
	public For_update_optionsContext for_update_options() {
		For_update_optionsContext _localctx = new For_update_optionsContext(Context, State);
		EnterRule(_localctx, 422, RULE_for_update_options);
		try {
			State = 3331;
			switch (TokenStream.La(1)) {
			case SKIP_:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3326; Match(SKIP_);
				State = 3327; Match(LOCKED);
				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3328; Match(NOWAIT);
				}
				break;
			case WAIT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3329; Match(WAIT);
				State = 3330; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_statementContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Update_set_clauseContext update_set_clause() {
			return GetRuleContext<Update_set_clauseContext>(0);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Update_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUpdate_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUpdate_statement(this);
		}
	}

	[RuleVersion(0)]
	public Update_statementContext update_statement() {
		Update_statementContext _localctx = new Update_statementContext(Context, State);
		EnterRule(_localctx, 424, RULE_update_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3333; Match(UPDATE);
			State = 3334; general_table_ref();
			State = 3335; update_set_clause();
			State = 3337;
			_la = TokenStream.La(1);
			if (_la==WHERE) {
				{
				State = 3336; where_clause();
				}
			}

			State = 3340;
			_la = TokenStream.La(1);
			if (_la==RETURN || _la==RETURNING) {
				{
				State = 3339; static_returning_clause();
				}
			}

			State = 3343;
			_la = TokenStream.La(1);
			if (_la==LOG) {
				{
				State = 3342; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_set_clauseContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Column_based_update_set_clauseContext[] column_based_update_set_clause() {
			return GetRuleContexts<Column_based_update_set_clauseContext>();
		}
		public Column_based_update_set_clauseContext column_based_update_set_clause(int i) {
			return GetRuleContext<Column_based_update_set_clauseContext>(i);
		}
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Update_set_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_set_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUpdate_set_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUpdate_set_clause(this);
		}
	}

	[RuleVersion(0)]
	public Update_set_clauseContext update_set_clause() {
		Update_set_clauseContext _localctx = new Update_set_clauseContext(Context, State);
		EnterRule(_localctx, 426, RULE_update_set_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3345; Match(SET);
			State = 3361;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,388,Context) ) {
			case 1:
				{
				State = 3346; column_based_update_set_clause();
				State = 3351;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3347; Match(COMMA);
					State = 3348; column_based_update_set_clause();
					}
					}
					State = 3353;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			case 2:
				{
				State = 3354; Match(VALUE);
				State = 3355; Match(LEFT_PAREN);
				State = 3356; id();
				State = 3357; Match(RIGHT_PAREN);
				State = 3358; Match(EQUALS_OP);
				State = 3359; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_based_update_set_clauseContext : ParserRuleContext {
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Column_based_update_set_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_based_update_set_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterColumn_based_update_set_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitColumn_based_update_set_clause(this);
		}
	}

	[RuleVersion(0)]
	public Column_based_update_set_clauseContext column_based_update_set_clause() {
		Column_based_update_set_clauseContext _localctx = new Column_based_update_set_clauseContext(Context, State);
		EnterRule(_localctx, 428, RULE_column_based_update_set_clause);
		int _la;
		try {
			State = 3380;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3363; column_name();
				State = 3364; Match(EQUALS_OP);
				State = 3365; expression();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3367; Match(LEFT_PAREN);
				State = 3368; column_name();
				State = 3373;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3369; Match(COMMA);
					State = 3370; column_name();
					}
					}
					State = 3375;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 3376; Match(RIGHT_PAREN);
				State = 3377; Match(EQUALS_OP);
				State = 3378; subquery();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Delete_statementContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(plsqlParser.DELETE, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Delete_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delete_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDelete_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDelete_statement(this);
		}
	}

	[RuleVersion(0)]
	public Delete_statementContext delete_statement() {
		Delete_statementContext _localctx = new Delete_statementContext(Context, State);
		EnterRule(_localctx, 430, RULE_delete_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3382; Match(DELETE);
			State = 3384;
			_la = TokenStream.La(1);
			if (_la==FROM) {
				{
				State = 3383; Match(FROM);
				}
			}

			State = 3386; general_table_ref();
			State = 3388;
			_la = TokenStream.La(1);
			if (_la==WHERE) {
				{
				State = 3387; where_clause();
				}
			}

			State = 3391;
			_la = TokenStream.La(1);
			if (_la==RETURN || _la==RETURNING) {
				{
				State = 3390; static_returning_clause();
				}
			}

			State = 3394;
			_la = TokenStream.La(1);
			if (_la==LOG) {
				{
				State = 3393; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_statementContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(plsqlParser.INSERT, 0); }
		public Single_table_insertContext single_table_insert() {
			return GetRuleContext<Single_table_insertContext>(0);
		}
		public Multi_table_insertContext multi_table_insert() {
			return GetRuleContext<Multi_table_insertContext>(0);
		}
		public Insert_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInsert_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInsert_statement(this);
		}
	}

	[RuleVersion(0)]
	public Insert_statementContext insert_statement() {
		Insert_statementContext _localctx = new Insert_statementContext(Context, State);
		EnterRule(_localctx, 432, RULE_insert_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3396; Match(INSERT);
			State = 3399;
			switch (TokenStream.La(1)) {
			case INTO:
				{
				State = 3397; single_table_insert();
				}
				break;
			case ALL:
			case FIRST:
			case WHEN:
				{
				State = 3398; multi_table_insert();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Single_table_insertContext : ParserRuleContext {
		public Insert_into_clauseContext insert_into_clause() {
			return GetRuleContext<Insert_into_clauseContext>(0);
		}
		public Values_clauseContext values_clause() {
			return GetRuleContext<Values_clauseContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Single_table_insertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_single_table_insert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSingle_table_insert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSingle_table_insert(this);
		}
	}

	[RuleVersion(0)]
	public Single_table_insertContext single_table_insert() {
		Single_table_insertContext _localctx = new Single_table_insertContext(Context, State);
		EnterRule(_localctx, 434, RULE_single_table_insert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3401; insert_into_clause();
			State = 3407;
			switch (TokenStream.La(1)) {
			case VALUES:
				{
				State = 3402; values_clause();
				State = 3404;
				_la = TokenStream.La(1);
				if (_la==RETURN || _la==RETURNING) {
					{
					State = 3403; static_returning_clause();
					}
				}

				}
				break;
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				{
				State = 3406; select_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3410;
			_la = TokenStream.La(1);
			if (_la==LOG) {
				{
				State = 3409; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_table_insertContext : ParserRuleContext {
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Conditional_insert_clauseContext conditional_insert_clause() {
			return GetRuleContext<Conditional_insert_clauseContext>(0);
		}
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Multi_table_insertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_table_insert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMulti_table_insert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMulti_table_insert(this);
		}
	}

	[RuleVersion(0)]
	public Multi_table_insertContext multi_table_insert() {
		Multi_table_insertContext _localctx = new Multi_table_insertContext(Context, State);
		EnterRule(_localctx, 436, RULE_multi_table_insert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3419;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,400,Context) ) {
			case 1:
				{
				State = 3412; Match(ALL);
				State = 3414;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				do {
					{
					{
					State = 3413; multi_table_element();
					}
					}
					State = 3416;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				} while ( _la==INTO );
				}
				break;
			case 2:
				{
				State = 3418; conditional_insert_clause();
				}
				break;
			}
			State = 3421; select_statement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_table_elementContext : ParserRuleContext {
		public Insert_into_clauseContext insert_into_clause() {
			return GetRuleContext<Insert_into_clauseContext>(0);
		}
		public Values_clauseContext values_clause() {
			return GetRuleContext<Values_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Multi_table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMulti_table_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMulti_table_element(this);
		}
	}

	[RuleVersion(0)]
	public Multi_table_elementContext multi_table_element() {
		Multi_table_elementContext _localctx = new Multi_table_elementContext(Context, State);
		EnterRule(_localctx, 438, RULE_multi_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3423; insert_into_clause();
			State = 3425;
			_la = TokenStream.La(1);
			if (_la==VALUES) {
				{
				State = 3424; values_clause();
				}
			}

			State = 3428;
			_la = TokenStream.La(1);
			if (_la==LOG) {
				{
				State = 3427; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_clauseContext : ParserRuleContext {
		public Conditional_insert_when_partContext[] conditional_insert_when_part() {
			return GetRuleContexts<Conditional_insert_when_partContext>();
		}
		public Conditional_insert_when_partContext conditional_insert_when_part(int i) {
			return GetRuleContext<Conditional_insert_when_partContext>(i);
		}
		public Conditional_insert_else_partContext conditional_insert_else_part() {
			return GetRuleContext<Conditional_insert_else_partContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public ITerminalNode FIRST() { return GetToken(plsqlParser.FIRST, 0); }
		public Conditional_insert_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_clause(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_clauseContext conditional_insert_clause() {
		Conditional_insert_clauseContext _localctx = new Conditional_insert_clauseContext(Context, State);
		EnterRule(_localctx, 440, RULE_conditional_insert_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3431;
			_la = TokenStream.La(1);
			if (_la==ALL || _la==FIRST) {
				{
				State = 3430;
				_la = TokenStream.La(1);
				if ( !(_la==ALL || _la==FIRST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			State = 3434;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 3433; conditional_insert_when_part();
				}
				}
				State = 3436;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==WHEN );
			State = 3439;
			_la = TokenStream.La(1);
			if (_la==ELSE) {
				{
				State = 3438; conditional_insert_else_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Conditional_insert_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_when_part(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_when_partContext conditional_insert_when_part() {
		Conditional_insert_when_partContext _localctx = new Conditional_insert_when_partContext(Context, State);
		EnterRule(_localctx, 442, RULE_conditional_insert_when_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3441; Match(WHEN);
			State = 3442; condition();
			State = 3443; Match(THEN);
			State = 3445;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 3444; multi_table_element();
				}
				}
				State = 3447;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(plsqlParser.ELSE, 0); }
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Conditional_insert_else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_else_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_else_part(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_else_partContext conditional_insert_else_part() {
		Conditional_insert_else_partContext _localctx = new Conditional_insert_else_partContext(Context, State);
		EnterRule(_localctx, 444, RULE_conditional_insert_else_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3449; Match(ELSE);
			State = 3451;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 3450; multi_table_element();
				}
				}
				State = 3453;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_into_clauseContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Insert_into_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_into_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInsert_into_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInsert_into_clause(this);
		}
	}

	[RuleVersion(0)]
	public Insert_into_clauseContext insert_into_clause() {
		Insert_into_clauseContext _localctx = new Insert_into_clauseContext(Context, State);
		EnterRule(_localctx, 446, RULE_insert_into_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3455; Match(INTO);
			State = 3456; general_table_ref();
			State = 3468;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,409,Context) ) {
			case 1:
				{
				State = 3457; Match(LEFT_PAREN);
				State = 3458; column_name();
				State = 3463;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3459; Match(COMMA);
					State = 3460; column_name();
					}
					}
					State = 3465;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 3466; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Values_clauseContext : ParserRuleContext {
		public ITerminalNode VALUES() { return GetToken(plsqlParser.VALUES, 0); }
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Values_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_values_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterValues_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitValues_clause(this);
		}
	}

	[RuleVersion(0)]
	public Values_clauseContext values_clause() {
		Values_clauseContext _localctx = new Values_clauseContext(Context, State);
		EnterRule(_localctx, 448, RULE_values_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3470; Match(VALUES);
			State = 3471; expression_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_statementContext : ParserRuleContext {
		public ITerminalNode MERGE() { return GetToken(plsqlParser.MERGE, 0); }
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public Selected_tableviewContext selected_tableview() {
			return GetRuleContext<Selected_tableviewContext>(0);
		}
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Merge_update_clauseContext merge_update_clause() {
			return GetRuleContext<Merge_update_clauseContext>(0);
		}
		public Merge_insert_clauseContext merge_insert_clause() {
			return GetRuleContext<Merge_insert_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Merge_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_statement(this);
		}
	}

	[RuleVersion(0)]
	public Merge_statementContext merge_statement() {
		Merge_statementContext _localctx = new Merge_statementContext(Context, State);
		EnterRule(_localctx, 450, RULE_merge_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3473; Match(MERGE);
			State = 3474; Match(INTO);
			State = 3475; tableview_name();
			State = 3477;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3476; table_alias();
				}
			}

			State = 3479; Match(USING);
			State = 3480; selected_tableview();
			State = 3481; Match(ON);
			State = 3482; Match(LEFT_PAREN);
			State = 3483; condition();
			State = 3484; Match(RIGHT_PAREN);
			State = 3493;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,413,Context) ) {
			case 1:
				{
				State = 3485; merge_update_clause();
				State = 3487;
				_la = TokenStream.La(1);
				if (_la==WHEN) {
					{
					State = 3486; merge_insert_clause();
					}
				}

				}
				break;
			case 2:
				{
				State = 3489; merge_insert_clause();
				State = 3491;
				_la = TokenStream.La(1);
				if (_la==WHEN) {
					{
					State = 3490; merge_update_clause();
					}
				}

				}
				break;
			}
			State = 3496;
			_la = TokenStream.La(1);
			if (_la==LOG) {
				{
				State = 3495; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_update_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ITerminalNode MATCHED() { return GetToken(plsqlParser.MATCHED, 0); }
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Merge_elementContext[] merge_element() {
			return GetRuleContexts<Merge_elementContext>();
		}
		public Merge_elementContext merge_element(int i) {
			return GetRuleContext<Merge_elementContext>(i);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_update_delete_partContext merge_update_delete_part() {
			return GetRuleContext<Merge_update_delete_partContext>(0);
		}
		public Merge_update_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_update_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_update_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_update_clause(this);
		}
	}

	[RuleVersion(0)]
	public Merge_update_clauseContext merge_update_clause() {
		Merge_update_clauseContext _localctx = new Merge_update_clauseContext(Context, State);
		EnterRule(_localctx, 452, RULE_merge_update_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3498; Match(WHEN);
			State = 3499; Match(MATCHED);
			State = 3500; Match(THEN);
			State = 3501; Match(UPDATE);
			State = 3502; Match(SET);
			State = 3503; merge_element();
			State = 3508;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3504; Match(COMMA);
				State = 3505; merge_element();
				}
				}
				State = 3510;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3512;
			_la = TokenStream.La(1);
			if (_la==WHERE) {
				{
				State = 3511; where_clause();
				}
			}

			State = 3515;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,417,Context) ) {
			case 1:
				{
				State = 3514; merge_update_delete_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_elementContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Merge_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_element(this);
		}
	}

	[RuleVersion(0)]
	public Merge_elementContext merge_element() {
		Merge_elementContext _localctx = new Merge_elementContext(Context, State);
		EnterRule(_localctx, 454, RULE_merge_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3517; column_name();
			State = 3518; Match(EQUALS_OP);
			State = 3519; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_update_delete_partContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(plsqlParser.DELETE, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_update_delete_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_update_delete_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_update_delete_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_update_delete_part(this);
		}
	}

	[RuleVersion(0)]
	public Merge_update_delete_partContext merge_update_delete_part() {
		Merge_update_delete_partContext _localctx = new Merge_update_delete_partContext(Context, State);
		EnterRule(_localctx, 456, RULE_merge_update_delete_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3521; Match(DELETE);
			State = 3522; where_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_insert_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public ITerminalNode MATCHED() { return GetToken(plsqlParser.MATCHED, 0); }
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public ITerminalNode INSERT() { return GetToken(plsqlParser.INSERT, 0); }
		public ITerminalNode VALUES() { return GetToken(plsqlParser.VALUES, 0); }
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_insert_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_insert_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMerge_insert_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMerge_insert_clause(this);
		}
	}

	[RuleVersion(0)]
	public Merge_insert_clauseContext merge_insert_clause() {
		Merge_insert_clauseContext _localctx = new Merge_insert_clauseContext(Context, State);
		EnterRule(_localctx, 458, RULE_merge_insert_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3524; Match(WHEN);
			State = 3525; Match(NOT);
			State = 3526; Match(MATCHED);
			State = 3527; Match(THEN);
			State = 3528; Match(INSERT);
			State = 3540;
			_la = TokenStream.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 3529; Match(LEFT_PAREN);
				State = 3530; column_name();
				State = 3535;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3531; Match(COMMA);
					State = 3532; column_name();
					}
					}
					State = 3537;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 3538; Match(RIGHT_PAREN);
				}
			}

			State = 3542; Match(VALUES);
			State = 3543; expression_list();
			State = 3545;
			_la = TokenStream.La(1);
			if (_la==WHERE) {
				{
				State = 3544; where_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selected_tableviewContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Selected_tableviewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selected_tableview; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSelected_tableview(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSelected_tableview(this);
		}
	}

	[RuleVersion(0)]
	public Selected_tableviewContext selected_tableview() {
		Selected_tableviewContext _localctx = new Selected_tableviewContext(Context, State);
		EnterRule(_localctx, 460, RULE_selected_tableview);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3552;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3547; tableview_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3548; Match(LEFT_PAREN);
				State = 3549; select_statement();
				State = 3550; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3555;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3554; table_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_table_statementContext : ParserRuleContext {
		public ITerminalNode LOCK() { return GetToken(plsqlParser.LOCK, 0); }
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public Lock_table_elementContext[] lock_table_element() {
			return GetRuleContexts<Lock_table_elementContext>();
		}
		public Lock_table_elementContext lock_table_element(int i) {
			return GetRuleContext<Lock_table_elementContext>(i);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Lock_modeContext lock_mode() {
			return GetRuleContext<Lock_modeContext>(0);
		}
		public ITerminalNode MODE() { return GetToken(plsqlParser.MODE, 0); }
		public Wait_nowait_partContext wait_nowait_part() {
			return GetRuleContext<Wait_nowait_partContext>(0);
		}
		public Lock_table_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLock_table_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLock_table_statement(this);
		}
	}

	[RuleVersion(0)]
	public Lock_table_statementContext lock_table_statement() {
		Lock_table_statementContext _localctx = new Lock_table_statementContext(Context, State);
		EnterRule(_localctx, 462, RULE_lock_table_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3557; Match(LOCK);
			State = 3558; Match(TABLE);
			State = 3559; lock_table_element();
			State = 3564;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3560; Match(COMMA);
				State = 3561; lock_table_element();
				}
				}
				State = 3566;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3567; Match(IN);
			State = 3568; lock_mode();
			State = 3569; Match(MODE);
			State = 3571;
			_la = TokenStream.La(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 3570; wait_nowait_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Wait_nowait_partContext : ParserRuleContext {
		public ITerminalNode WAIT() { return GetToken(plsqlParser.WAIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NOWAIT() { return GetToken(plsqlParser.NOWAIT, 0); }
		public Wait_nowait_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_wait_nowait_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWait_nowait_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWait_nowait_part(this);
		}
	}

	[RuleVersion(0)]
	public Wait_nowait_partContext wait_nowait_part() {
		Wait_nowait_partContext _localctx = new Wait_nowait_partContext(Context, State);
		EnterRule(_localctx, 464, RULE_wait_nowait_part);
		try {
			State = 3576;
			switch (TokenStream.La(1)) {
			case WAIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3573; Match(WAIT);
				State = 3574; expression();
				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3575; Match(NOWAIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_table_elementContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Partition_extension_clauseContext partition_extension_clause() {
			return GetRuleContext<Partition_extension_clauseContext>(0);
		}
		public Lock_table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLock_table_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLock_table_element(this);
		}
	}

	[RuleVersion(0)]
	public Lock_table_elementContext lock_table_element() {
		Lock_table_elementContext _localctx = new Lock_table_elementContext(Context, State);
		EnterRule(_localctx, 466, RULE_lock_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3578; tableview_name();
			State = 3580;
			_la = TokenStream.La(1);
			if (_la==PARTITION || _la==SUBPARTITION) {
				{
				State = 3579; partition_extension_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_modeContext : ParserRuleContext {
		public ITerminalNode ROW() { return GetToken(plsqlParser.ROW, 0); }
		public ITerminalNode SHARE() { return GetToken(plsqlParser.SHARE, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(plsqlParser.EXCLUSIVE, 0); }
		public ITerminalNode UPDATE() { return GetToken(plsqlParser.UPDATE, 0); }
		public Lock_modeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_mode; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLock_mode(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLock_mode(this);
		}
	}

	[RuleVersion(0)]
	public Lock_modeContext lock_mode() {
		Lock_modeContext _localctx = new Lock_modeContext(Context, State);
		EnterRule(_localctx, 468, RULE_lock_mode);
		int _la;
		try {
			State = 3594;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,428,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3582; Match(ROW);
				State = 3583; Match(SHARE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3584; Match(ROW);
				State = 3585; Match(EXCLUSIVE);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3586; Match(SHARE);
				State = 3588;
				_la = TokenStream.La(1);
				if (_la==UPDATE) {
					{
					State = 3587; Match(UPDATE);
					}
				}

				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3590; Match(SHARE);
				State = 3591; Match(ROW);
				State = 3592; Match(EXCLUSIVE);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3593; Match(EXCLUSIVE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_table_refContext : ParserRuleContext {
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public General_table_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_table_ref; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGeneral_table_ref(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGeneral_table_ref(this);
		}
	}

	[RuleVersion(0)]
	public General_table_refContext general_table_ref() {
		General_table_refContext _localctx = new General_table_refContext(Context, State);
		EnterRule(_localctx, 470, RULE_general_table_ref);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3602;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,429,Context) ) {
			case 1:
				{
				State = 3596; dml_table_expression_clause();
				}
				break;
			case 2:
				{
				State = 3597; Match(ONLY);
				State = 3598; Match(LEFT_PAREN);
				State = 3599; dml_table_expression_clause();
				State = 3600; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 3605;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,430,Context) ) {
			case 1:
				{
				State = 3604; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Static_returning_clauseContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public ITerminalNode RETURNING() { return GetToken(plsqlParser.RETURNING, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public Static_returning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_static_returning_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStatic_returning_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStatic_returning_clause(this);
		}
	}

	[RuleVersion(0)]
	public Static_returning_clauseContext static_returning_clause() {
		Static_returning_clauseContext _localctx = new Static_returning_clauseContext(Context, State);
		EnterRule(_localctx, 472, RULE_static_returning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3607;
			_la = TokenStream.La(1);
			if ( !(_la==RETURN || _la==RETURNING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 3608; expression();
			State = 3613;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3609; Match(COMMA);
				State = 3610; expression();
				}
				}
				State = 3615;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3616; into_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_clauseContext : ParserRuleContext {
		public ITerminalNode LOG() { return GetToken(plsqlParser.LOG, 0); }
		public ITerminalNode ERRORS() { return GetToken(plsqlParser.ERRORS, 0); }
		public Error_logging_into_partContext error_logging_into_part() {
			return GetRuleContext<Error_logging_into_partContext>(0);
		}
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Error_logging_reject_partContext error_logging_reject_part() {
			return GetRuleContext<Error_logging_reject_partContext>(0);
		}
		public Error_logging_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterError_logging_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitError_logging_clause(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_clauseContext error_logging_clause() {
		Error_logging_clauseContext _localctx = new Error_logging_clauseContext(Context, State);
		EnterRule(_localctx, 474, RULE_error_logging_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3618; Match(LOG);
			State = 3619; Match(ERRORS);
			State = 3621;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,432,Context) ) {
			case 1:
				{
				State = 3620; error_logging_into_part();
				}
				break;
			}
			State = 3624;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,433,Context) ) {
			case 1:
				{
				State = 3623; expression_wrapper();
				}
				break;
			}
			State = 3627;
			_la = TokenStream.La(1);
			if (_la==REJECT) {
				{
				State = 3626; error_logging_reject_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_into_partContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Error_logging_into_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_into_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterError_logging_into_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitError_logging_into_part(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_into_partContext error_logging_into_part() {
		Error_logging_into_partContext _localctx = new Error_logging_into_partContext(Context, State);
		EnterRule(_localctx, 476, RULE_error_logging_into_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3629; Match(INTO);
			State = 3630; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_reject_partContext : ParserRuleContext {
		public ITerminalNode REJECT() { return GetToken(plsqlParser.REJECT, 0); }
		public ITerminalNode LIMIT() { return GetToken(plsqlParser.LIMIT, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(plsqlParser.UNLIMITED, 0); }
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Error_logging_reject_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_reject_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterError_logging_reject_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitError_logging_reject_part(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_reject_partContext error_logging_reject_part() {
		Error_logging_reject_partContext _localctx = new Error_logging_reject_partContext(Context, State);
		EnterRule(_localctx, 478, RULE_error_logging_reject_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3632; Match(REJECT);
			State = 3633; Match(LIMIT);
			State = 3636;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,435,Context) ) {
			case 1:
				{
				State = 3634; Match(UNLIMITED);
				}
				break;
			case 2:
				{
				State = 3635; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_table_expression_clauseContext : ParserRuleContext {
		public Table_collection_expressionContext table_collection_expression() {
			return GetRuleContext<Table_collection_expressionContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Subquery_restriction_clauseContext subquery_restriction_clause() {
			return GetRuleContext<Subquery_restriction_clauseContext>(0);
		}
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Sample_clauseContext sample_clause() {
			return GetRuleContext<Sample_clauseContext>(0);
		}
		public Dml_table_expression_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_table_expression_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDml_table_expression_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDml_table_expression_clause(this);
		}
	}

	[RuleVersion(0)]
	public Dml_table_expression_clauseContext dml_table_expression_clause() {
		Dml_table_expression_clauseContext _localctx = new Dml_table_expression_clauseContext(Context, State);
		EnterRule(_localctx, 480, RULE_dml_table_expression_clause);
		int _la;
		try {
			State = 3650;
			switch (TokenStream.La(1)) {
			case TABLE:
			case THE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3638; table_collection_expression();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3639; Match(LEFT_PAREN);
				State = 3640; select_statement();
				State = 3642;
				_la = TokenStream.La(1);
				if (_la==WITH) {
					{
					State = 3641; subquery_restriction_clause();
					}
				}

				State = 3644; Match(RIGHT_PAREN);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3646; tableview_name();
				State = 3648;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,437,Context) ) {
				case 1:
					{
					State = 3647; sample_clause();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_collection_expressionContext : ParserRuleContext {
		public ITerminalNode TABLE() { return GetToken(plsqlParser.TABLE, 0); }
		public ITerminalNode THE() { return GetToken(plsqlParser.THE, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Table_collection_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_collection_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_collection_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_collection_expression(this);
		}
	}

	[RuleVersion(0)]
	public Table_collection_expressionContext table_collection_expression() {
		Table_collection_expressionContext _localctx = new Table_collection_expressionContext(Context, State);
		EnterRule(_localctx, 482, RULE_table_collection_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3652;
			_la = TokenStream.La(1);
			if ( !(_la==TABLE || _la==THE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 3665;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,440,Context) ) {
			case 1:
				{
				State = 3653; Match(LEFT_PAREN);
				State = 3654; subquery();
				State = 3655; Match(RIGHT_PAREN);
				}
				break;
			case 2:
				{
				State = 3657; Match(LEFT_PAREN);
				State = 3658; expression();
				State = 3659; Match(RIGHT_PAREN);
				State = 3663;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,439,Context) ) {
				case 1:
					{
					State = 3660; Match(LEFT_PAREN);
					State = 3661; Match(PLUS_SIGN);
					State = 3662; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_restriction_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode READ() { return GetToken(plsqlParser.READ, 0); }
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public ITerminalNode CHECK() { return GetToken(plsqlParser.CHECK, 0); }
		public ITerminalNode OPTION() { return GetToken(plsqlParser.OPTION, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(plsqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Subquery_restriction_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_restriction_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSubquery_restriction_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSubquery_restriction_clause(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_restriction_clauseContext subquery_restriction_clause() {
		Subquery_restriction_clauseContext _localctx = new Subquery_restriction_clauseContext(Context, State);
		EnterRule(_localctx, 484, RULE_subquery_restriction_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3667; Match(WITH);
			State = 3676;
			switch (TokenStream.La(1)) {
			case READ:
				{
				State = 3668; Match(READ);
				State = 3669; Match(ONLY);
				}
				break;
			case CHECK:
				{
				State = 3670; Match(CHECK);
				State = 3671; Match(OPTION);
				State = 3674;
				_la = TokenStream.La(1);
				if (_la==CONSTRAINT) {
					{
					State = 3672; Match(CONSTRAINT);
					State = 3673; constraint_name();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sample_clauseContext : ParserRuleContext {
		public ITerminalNode SAMPLE() { return GetToken(plsqlParser.SAMPLE, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode BLOCK() { return GetToken(plsqlParser.BLOCK, 0); }
		public Seed_partContext seed_part() {
			return GetRuleContext<Seed_partContext>(0);
		}
		public Sample_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sample_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSample_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSample_clause(this);
		}
	}

	[RuleVersion(0)]
	public Sample_clauseContext sample_clause() {
		Sample_clauseContext _localctx = new Sample_clauseContext(Context, State);
		EnterRule(_localctx, 486, RULE_sample_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3678; Match(SAMPLE);
			State = 3680;
			_la = TokenStream.La(1);
			if (_la==BLOCK) {
				{
				State = 3679; Match(BLOCK);
				}
			}

			State = 3682; Match(LEFT_PAREN);
			State = 3683; expression();
			State = 3686;
			_la = TokenStream.La(1);
			if (_la==COMMA) {
				{
				State = 3684; Match(COMMA);
				State = 3685; expression();
				}
			}

			State = 3688; Match(RIGHT_PAREN);
			State = 3690;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,445,Context) ) {
			case 1:
				{
				State = 3689; seed_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seed_partContext : ParserRuleContext {
		public ITerminalNode SEED() { return GetToken(plsqlParser.SEED, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Seed_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seed_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSeed_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSeed_part(this);
		}
	}

	[RuleVersion(0)]
	public Seed_partContext seed_part() {
		Seed_partContext _localctx = new Seed_partContext(Context, State);
		EnterRule(_localctx, 488, RULE_seed_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3692; Match(SEED);
			State = 3693; Match(LEFT_PAREN);
			State = 3694; expression();
			State = 3695; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_expressionContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(plsqlParser.CURSOR, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Cursor_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_expression(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_expressionContext cursor_expression() {
		Cursor_expressionContext _localctx = new Cursor_expressionContext(Context, State);
		EnterRule(_localctx, 490, RULE_cursor_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3697; Match(CURSOR);
			State = 3698; Match(LEFT_PAREN);
			State = 3699; subquery();
			State = 3700; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_listContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Expression_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExpression_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExpression_list(this);
		}
	}

	[RuleVersion(0)]
	public Expression_listContext expression_list() {
		Expression_listContext _localctx = new Expression_listContext(Context, State);
		EnterRule(_localctx, 492, RULE_expression_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3702; Match(LEFT_PAREN);
			State = 3704;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENTITYESCAPING - 64)) | (1L << (ERR - 64)) | (1L << (ERRORS - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVALNAME - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERVAL - 128)) | (1L << (INVALIDATE - 128)) | (1L << (ISOLATION - 128)) | (1L << (ITERATE - 128)) | (1L << (JAVA - 128)) | (1L << (JOIN - 128)) | (1L << (KEEP - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NONE - 192)) | (1L << (NOSCHEMACHECK - 192)) | (1L << (NOT - 192)) | (1L << (NULL - 192)) | (1L << (NULLS - 192)) | (1L << (NUMBER - 192)) | (1L << (NUMERIC - 192)) | (1L << (NVARCHAR2 - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (OBJECT - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)) | (1L << (RELIES_ON - 256)) | (1L << (RENAME - 256)) | (1L << (REPLACE - 256)) | (1L << (RESPECT - 256)) | (1L << (RESTRICT_REFERENCES - 256)) | (1L << (RESULT - 256)) | (1L << (RESULT_CACHE - 256)) | (1L << (RETURN - 256)) | (1L << (RETURNING - 256)) | (1L << (REUSE - 256)) | (1L << (REVERSE - 256)) | (1L << (RIGHT - 256)) | (1L << (ROLLBACK - 256)) | (1L << (ROLLUP - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (STANDALONE - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)) | (1L << (SUBMULTISET - 320)) | (1L << (SUBPARTITION - 320)) | (1L << (SUBSTITUTABLE - 320)) | (1L << (SUBTYPE - 320)) | (1L << (SUCCESS - 320)) | (1L << (SUSPEND - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_UNCONSTRAINED - 320)) | (1L << (TIMEZONE_ABBR - 320)) | (1L << (TIMEZONE_HOUR - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHILE - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)) | (1L << (XML - 384)) | (1L << (XMLAGG - 384)) | (1L << (XMLATTRIBUTES - 384)) | (1L << (XMLCAST - 384)) | (1L << (XMLCOLATTVAL - 384)) | (1L << (XMLELEMENT - 384)) | (1L << (XMLEXISTS - 384)) | (1L << (XMLFOREST - 384)) | (1L << (XMLNAMESPACES - 384)) | (1L << (XMLPARSE - 384)) | (1L << (XMLPI - 384)) | (1L << (XMLQUERY - 384)) | (1L << (XMLROOT - 384)) | (1L << (XMLSERIALIZE - 384)) | (1L << (XMLTABLE - 384)) | (1L << (YEAR - 384)) | (1L << (YES - 384)) | (1L << (YMINTERVAL_UNCONSTRAINED - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)) | (1L << (PLUS_SIGN - 448)) | (1L << (MINUS_SIGN - 448)) | (1L << (BINDVAR - 448)) | (1L << (COLON - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3703; expression();
				}
			}

			State = 3710;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3706; Match(COMMA);
				State = 3707; expression();
				}
				}
				State = 3712;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3713; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCondition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCondition(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		ConditionContext _localctx = new ConditionContext(Context, State);
		EnterRule(_localctx, 494, RULE_condition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3715; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Condition_wrapperContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Condition_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition_wrapper; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCondition_wrapper(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCondition_wrapper(this);
		}
	}

	[RuleVersion(0)]
	public Condition_wrapperContext condition_wrapper() {
		Condition_wrapperContext _localctx = new Condition_wrapperContext(Context, State);
		EnterRule(_localctx, 496, RULE_condition_wrapper);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3717; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public Cursor_expressionContext cursor_expression() {
			return GetRuleContext<Cursor_expressionContext>(0);
		}
		public Logical_and_expressionContext[] logical_and_expression() {
			return GetRuleContexts<Logical_and_expressionContext>();
		}
		public Logical_and_expressionContext logical_and_expression(int i) {
			return GetRuleContext<Logical_and_expressionContext>(i);
		}
		public ITerminalNode[] OR() { return GetTokens(plsqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(plsqlParser.OR, i);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 498, RULE_expression);
		try {
			int _alt;
			State = 3728;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,449,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3719; cursor_expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3720; logical_and_expression();
				State = 3725;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,448,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 3721; Match(OR);
						State = 3722; logical_and_expression();
						}
						} 
					}
					State = 3727;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,448,Context);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_wrapperContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expression_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_wrapper; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExpression_wrapper(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExpression_wrapper(this);
		}
	}

	[RuleVersion(0)]
	public Expression_wrapperContext expression_wrapper() {
		Expression_wrapperContext _localctx = new Expression_wrapperContext(Context, State);
		EnterRule(_localctx, 500, RULE_expression_wrapper);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3730; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Logical_and_expressionContext : ParserRuleContext {
		public Negated_expressionContext[] negated_expression() {
			return GetRuleContexts<Negated_expressionContext>();
		}
		public Negated_expressionContext negated_expression(int i) {
			return GetRuleContext<Negated_expressionContext>(i);
		}
		public ITerminalNode[] AND() { return GetTokens(plsqlParser.AND); }
		public ITerminalNode AND(int i) {
			return GetToken(plsqlParser.AND, i);
		}
		public Logical_and_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logical_and_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLogical_and_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLogical_and_expression(this);
		}
	}

	[RuleVersion(0)]
	public Logical_and_expressionContext logical_and_expression() {
		Logical_and_expressionContext _localctx = new Logical_and_expressionContext(Context, State);
		EnterRule(_localctx, 502, RULE_logical_and_expression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3732; negated_expression();
			State = 3737;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,450,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3733; Match(AND);
					State = 3734; negated_expression();
					}
					} 
				}
				State = 3739;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,450,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Negated_expressionContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public Negated_expressionContext negated_expression() {
			return GetRuleContext<Negated_expressionContext>(0);
		}
		public Equality_expressionContext equality_expression() {
			return GetRuleContext<Equality_expressionContext>(0);
		}
		public Negated_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_negated_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNegated_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNegated_expression(this);
		}
	}

	[RuleVersion(0)]
	public Negated_expressionContext negated_expression() {
		Negated_expressionContext _localctx = new Negated_expressionContext(Context, State);
		EnterRule(_localctx, 504, RULE_negated_expression);
		try {
			State = 3743;
			switch (TokenStream.La(1)) {
			case NOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3740; Match(NOT);
				State = 3741; negated_expression();
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3742; equality_expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Equality_expressionContext : ParserRuleContext {
		public Multiset_expressionContext multiset_expression() {
			return GetRuleContext<Multiset_expressionContext>(0);
		}
		public ITerminalNode[] IS() { return GetTokens(plsqlParser.IS); }
		public ITerminalNode IS(int i) {
			return GetToken(plsqlParser.IS, i);
		}
		public ITerminalNode[] NULL() { return GetTokens(plsqlParser.NULL); }
		public ITerminalNode NULL(int i) {
			return GetToken(plsqlParser.NULL, i);
		}
		public ITerminalNode[] NAN() { return GetTokens(plsqlParser.NAN); }
		public ITerminalNode NAN(int i) {
			return GetToken(plsqlParser.NAN, i);
		}
		public ITerminalNode[] PRESENT() { return GetTokens(plsqlParser.PRESENT); }
		public ITerminalNode PRESENT(int i) {
			return GetToken(plsqlParser.PRESENT, i);
		}
		public ITerminalNode[] INFINITE() { return GetTokens(plsqlParser.INFINITE); }
		public ITerminalNode INFINITE(int i) {
			return GetToken(plsqlParser.INFINITE, i);
		}
		public ITerminalNode[] A_LETTER() { return GetTokens(plsqlParser.A_LETTER); }
		public ITerminalNode A_LETTER(int i) {
			return GetToken(plsqlParser.A_LETTER, i);
		}
		public ITerminalNode[] SET() { return GetTokens(plsqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(plsqlParser.SET, i);
		}
		public ITerminalNode[] EMPTY() { return GetTokens(plsqlParser.EMPTY); }
		public ITerminalNode EMPTY(int i) {
			return GetToken(plsqlParser.EMPTY, i);
		}
		public ITerminalNode[] OF() { return GetTokens(plsqlParser.OF); }
		public ITerminalNode OF(int i) {
			return GetToken(plsqlParser.OF, i);
		}
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode[] NOT() { return GetTokens(plsqlParser.NOT); }
		public ITerminalNode NOT(int i) {
			return GetToken(plsqlParser.NOT, i);
		}
		public ITerminalNode[] TYPE() { return GetTokens(plsqlParser.TYPE); }
		public ITerminalNode TYPE(int i) {
			return GetToken(plsqlParser.TYPE, i);
		}
		public ITerminalNode[] ONLY() { return GetTokens(plsqlParser.ONLY); }
		public ITerminalNode ONLY(int i) {
			return GetToken(plsqlParser.ONLY, i);
		}
		public Equality_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equality_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterEquality_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitEquality_expression(this);
		}
	}

	[RuleVersion(0)]
	public Equality_expressionContext equality_expression() {
		Equality_expressionContext _localctx = new Equality_expressionContext(Context, State);
		EnterRule(_localctx, 506, RULE_equality_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3745; multiset_expression();
			State = 3779;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,457,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3746; Match(IS);
					State = 3748;
					_la = TokenStream.La(1);
					if (_la==NOT) {
						{
						State = 3747; Match(NOT);
						}
					}

					State = 3775;
					switch (TokenStream.La(1)) {
					case NULL:
						{
						State = 3750; Match(NULL);
						}
						break;
					case NAN:
						{
						State = 3751; Match(NAN);
						}
						break;
					case PRESENT:
						{
						State = 3752; Match(PRESENT);
						}
						break;
					case INFINITE:
						{
						State = 3753; Match(INFINITE);
						}
						break;
					case A_LETTER:
						{
						State = 3754; Match(A_LETTER);
						State = 3755; Match(SET);
						}
						break;
					case EMPTY:
						{
						State = 3756; Match(EMPTY);
						}
						break;
					case OF:
						{
						State = 3757; Match(OF);
						State = 3759;
						_la = TokenStream.La(1);
						if (_la==TYPE) {
							{
							State = 3758; Match(TYPE);
							}
						}

						State = 3761; Match(LEFT_PAREN);
						State = 3763;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,454,Context) ) {
						case 1:
							{
							State = 3762; Match(ONLY);
							}
							break;
						}
						State = 3765; type_spec();
						State = 3770;
						ErrorHandler.Sync(this);
						_la = TokenStream.La(1);
						while (_la==COMMA) {
							{
							{
							State = 3766; Match(COMMA);
							State = 3767; type_spec();
							}
							}
							State = 3772;
							ErrorHandler.Sync(this);
							_la = TokenStream.La(1);
						}
						State = 3773; Match(RIGHT_PAREN);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					} 
				}
				State = 3781;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,457,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiset_expressionContext : ParserRuleContext {
		public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		public Multiset_typeContext multiset_type() {
			return GetRuleContext<Multiset_typeContext>(0);
		}
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Multiset_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiset_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMultiset_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMultiset_expression(this);
		}
	}

	[RuleVersion(0)]
	public Multiset_expressionContext multiset_expression() {
		Multiset_expressionContext _localctx = new Multiset_expressionContext(Context, State);
		EnterRule(_localctx, 508, RULE_multiset_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3782; relational_expression();
			State = 3789;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,459,Context) ) {
			case 1:
				{
				State = 3783; multiset_type();
				State = 3785;
				_la = TokenStream.La(1);
				if (_la==OF) {
					{
					State = 3784; Match(OF);
					}
				}

				State = 3787; concatenation();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiset_typeContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public ITerminalNode SUBMULTISET() { return GetToken(plsqlParser.SUBMULTISET, 0); }
		public Multiset_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiset_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMultiset_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMultiset_type(this);
		}
	}

	[RuleVersion(0)]
	public Multiset_typeContext multiset_type() {
		Multiset_typeContext _localctx = new Multiset_typeContext(Context, State);
		EnterRule(_localctx, 510, RULE_multiset_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3791;
			_la = TokenStream.La(1);
			if ( !(_la==MEMBER || _la==SUBMULTISET) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_expressionContext : ParserRuleContext {
		public Compound_expressionContext[] compound_expression() {
			return GetRuleContexts<Compound_expressionContext>();
		}
		public Compound_expressionContext compound_expression(int i) {
			return GetRuleContext<Compound_expressionContext>(i);
		}
		public Not_equal_opContext[] not_equal_op() {
			return GetRuleContexts<Not_equal_opContext>();
		}
		public Not_equal_opContext not_equal_op(int i) {
			return GetRuleContext<Not_equal_opContext>(i);
		}
		public Less_than_or_equals_opContext[] less_than_or_equals_op() {
			return GetRuleContexts<Less_than_or_equals_opContext>();
		}
		public Less_than_or_equals_opContext less_than_or_equals_op(int i) {
			return GetRuleContext<Less_than_or_equals_opContext>(i);
		}
		public Greater_than_or_equals_opContext[] greater_than_or_equals_op() {
			return GetRuleContexts<Greater_than_or_equals_opContext>();
		}
		public Greater_than_or_equals_opContext greater_than_or_equals_op(int i) {
			return GetRuleContext<Greater_than_or_equals_opContext>(i);
		}
		public Relational_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRelational_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRelational_expression(this);
		}
	}

	[RuleVersion(0)]
	public Relational_expressionContext relational_expression() {
		Relational_expressionContext _localctx = new Relational_expressionContext(Context, State);
		EnterRule(_localctx, 512, RULE_relational_expression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3793; compound_expression();
			State = 3805;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,461,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3800;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,460,Context) ) {
					case 1:
						{
						State = 3794; Match(EQUALS_OP);
						}
						break;
					case 2:
						{
						State = 3795; not_equal_op();
						}
						break;
					case 3:
						{
						State = 3796; Match(LESS_THAN_OP);
						}
						break;
					case 4:
						{
						State = 3797; Match(GREATER_THAN_OP);
						}
						break;
					case 5:
						{
						State = 3798; less_than_or_equals_op();
						}
						break;
					case 6:
						{
						State = 3799; greater_than_or_equals_op();
						}
						break;
					}
					State = 3802; compound_expression();
					}
					} 
				}
				State = 3807;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,461,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_expressionContext : ParserRuleContext {
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public In_elementsContext in_elements() {
			return GetRuleContext<In_elementsContext>(0);
		}
		public ITerminalNode BETWEEN() { return GetToken(plsqlParser.BETWEEN, 0); }
		public Between_elementsContext between_elements() {
			return GetRuleContext<Between_elementsContext>(0);
		}
		public Like_typeContext like_type() {
			return GetRuleContext<Like_typeContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(plsqlParser.NOT, 0); }
		public Like_escape_partContext like_escape_part() {
			return GetRuleContext<Like_escape_partContext>(0);
		}
		public Compound_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCompound_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCompound_expression(this);
		}
	}

	[RuleVersion(0)]
	public Compound_expressionContext compound_expression() {
		Compound_expressionContext _localctx = new Compound_expressionContext(Context, State);
		EnterRule(_localctx, 514, RULE_compound_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3808; concatenation();
			State = 3823;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,465,Context) ) {
			case 1:
				{
				State = 3810;
				_la = TokenStream.La(1);
				if (_la==NOT) {
					{
					State = 3809; Match(NOT);
					}
				}

				State = 3821;
				switch (TokenStream.La(1)) {
				case IN:
					{
					State = 3812; Match(IN);
					State = 3813; in_elements();
					}
					break;
				case BETWEEN:
					{
					State = 3814; Match(BETWEEN);
					State = 3815; between_elements();
					}
					break;
				case LIKE:
				case LIKE2:
				case LIKE4:
				case LIKEC:
					{
					State = 3816; like_type();
					State = 3817; concatenation();
					State = 3819;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,463,Context) ) {
					case 1:
						{
						State = 3818; like_escape_part();
						}
						break;
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Like_typeContext : ParserRuleContext {
		public ITerminalNode LIKE() { return GetToken(plsqlParser.LIKE, 0); }
		public ITerminalNode LIKEC() { return GetToken(plsqlParser.LIKEC, 0); }
		public ITerminalNode LIKE2() { return GetToken(plsqlParser.LIKE2, 0); }
		public ITerminalNode LIKE4() { return GetToken(plsqlParser.LIKE4, 0); }
		public Like_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_like_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLike_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLike_type(this);
		}
	}

	[RuleVersion(0)]
	public Like_typeContext like_type() {
		Like_typeContext _localctx = new Like_typeContext(Context, State);
		EnterRule(_localctx, 516, RULE_like_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3825;
			_la = TokenStream.La(1);
			if ( !(((((_la - 199)) & ~0x3f) == 0 && ((1L << (_la - 199)) & ((1L << (LIKE - 199)) | (1L << (LIKE2 - 199)) | (1L << (LIKE4 - 199)) | (1L << (LIKEC - 199)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Like_escape_partContext : ParserRuleContext {
		public ITerminalNode ESCAPE() { return GetToken(plsqlParser.ESCAPE, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Like_escape_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_like_escape_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLike_escape_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLike_escape_part(this);
		}
	}

	[RuleVersion(0)]
	public Like_escape_partContext like_escape_part() {
		Like_escape_partContext _localctx = new Like_escape_partContext(Context, State);
		EnterRule(_localctx, 518, RULE_like_escape_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3827; Match(ESCAPE);
			State = 3828; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class In_elementsContext : ParserRuleContext {
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Concatenation_wrapperContext[] concatenation_wrapper() {
			return GetRuleContexts<Concatenation_wrapperContext>();
		}
		public Concatenation_wrapperContext concatenation_wrapper(int i) {
			return GetRuleContext<Concatenation_wrapperContext>(i);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public In_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_in_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterIn_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitIn_elements(this);
		}
	}

	[RuleVersion(0)]
	public In_elementsContext in_elements() {
		In_elementsContext _localctx = new In_elementsContext(Context, State);
		EnterRule(_localctx, 520, RULE_in_elements);
		int _la;
		try {
			State = 3848;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,467,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3830; Match(LEFT_PAREN);
				State = 3831; subquery();
				State = 3832; Match(RIGHT_PAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3834; Match(LEFT_PAREN);
				State = 3835; concatenation_wrapper();
				State = 3840;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3836; Match(COMMA);
					State = 3837; concatenation_wrapper();
					}
					}
					State = 3842;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 3843; Match(RIGHT_PAREN);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3845; constant();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3846; bind_variable();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3847; general_element();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Between_elementsContext : ParserRuleContext {
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode AND() { return GetToken(plsqlParser.AND, 0); }
		public Between_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_between_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBetween_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBetween_elements(this);
		}
	}

	[RuleVersion(0)]
	public Between_elementsContext between_elements() {
		Between_elementsContext _localctx = new Between_elementsContext(Context, State);
		EnterRule(_localctx, 522, RULE_between_elements);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3850; concatenation();
			State = 3851; Match(AND);
			State = 3852; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConcatenationContext : ParserRuleContext {
		public Additive_expressionContext[] additive_expression() {
			return GetRuleContexts<Additive_expressionContext>();
		}
		public Additive_expressionContext additive_expression(int i) {
			return GetRuleContext<Additive_expressionContext>(i);
		}
		public Concatenation_opContext[] concatenation_op() {
			return GetRuleContexts<Concatenation_opContext>();
		}
		public Concatenation_opContext concatenation_op(int i) {
			return GetRuleContext<Concatenation_opContext>(i);
		}
		public ConcatenationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConcatenation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConcatenation(this);
		}
	}

	[RuleVersion(0)]
	public ConcatenationContext concatenation() {
		ConcatenationContext _localctx = new ConcatenationContext(Context, State);
		EnterRule(_localctx, 524, RULE_concatenation);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3854; additive_expression();
			State = 3860;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,468,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3855; concatenation_op();
					State = 3856; additive_expression();
					}
					} 
				}
				State = 3862;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,468,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Concatenation_wrapperContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Concatenation_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation_wrapper; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConcatenation_wrapper(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConcatenation_wrapper(this);
		}
	}

	[RuleVersion(0)]
	public Concatenation_wrapperContext concatenation_wrapper() {
		Concatenation_wrapperContext _localctx = new Concatenation_wrapperContext(Context, State);
		EnterRule(_localctx, 526, RULE_concatenation_wrapper);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3863; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Additive_expressionContext : ParserRuleContext {
		public Multiply_expressionContext[] multiply_expression() {
			return GetRuleContexts<Multiply_expressionContext>();
		}
		public Multiply_expressionContext multiply_expression(int i) {
			return GetRuleContext<Multiply_expressionContext>(i);
		}
		public Additive_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additive_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAdditive_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAdditive_expression(this);
		}
	}

	[RuleVersion(0)]
	public Additive_expressionContext additive_expression() {
		Additive_expressionContext _localctx = new Additive_expressionContext(Context, State);
		EnterRule(_localctx, 528, RULE_additive_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3865; multiply_expression();
			State = 3870;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,469,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3866;
					_la = TokenStream.La(1);
					if ( !(_la==PLUS_SIGN || _la==MINUS_SIGN) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 3867; multiply_expression();
					}
					} 
				}
				State = 3872;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,469,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiply_expressionContext : ParserRuleContext {
		public Datetime_expressionContext[] datetime_expression() {
			return GetRuleContexts<Datetime_expressionContext>();
		}
		public Datetime_expressionContext datetime_expression(int i) {
			return GetRuleContext<Datetime_expressionContext>(i);
		}
		public Multiply_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiply_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMultiply_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMultiply_expression(this);
		}
	}

	[RuleVersion(0)]
	public Multiply_expressionContext multiply_expression() {
		Multiply_expressionContext _localctx = new Multiply_expressionContext(Context, State);
		EnterRule(_localctx, 530, RULE_multiply_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3873; datetime_expression();
			State = 3878;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,470,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3874;
					_la = TokenStream.La(1);
					if ( !(_la==ASTERISK || _la==SOLIDUS) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 3875; datetime_expression();
					}
					} 
				}
				State = 3880;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,470,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Datetime_expressionContext : ParserRuleContext {
		public Model_expressionContext model_expression() {
			return GetRuleContext<Model_expressionContext>(0);
		}
		public ITerminalNode AT() { return GetToken(plsqlParser.AT, 0); }
		public Interval_expressionContext interval_expression() {
			return GetRuleContext<Interval_expressionContext>(0);
		}
		public ITerminalNode LOCAL() { return GetToken(plsqlParser.LOCAL, 0); }
		public ITerminalNode TIME() { return GetToken(plsqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(plsqlParser.ZONE, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Datetime_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datetime_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDatetime_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDatetime_expression(this);
		}
	}

	[RuleVersion(0)]
	public Datetime_expressionContext datetime_expression() {
		Datetime_expressionContext _localctx = new Datetime_expressionContext(Context, State);
		EnterRule(_localctx, 532, RULE_datetime_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3881; model_expression();
			State = 3890;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,472,Context) ) {
			case 1:
				{
				State = 3882; Match(AT);
				State = 3887;
				switch (TokenStream.La(1)) {
				case LOCAL:
					{
					State = 3883; Match(LOCAL);
					}
					break;
				case TIME:
					{
					State = 3884; Match(TIME);
					State = 3885; Match(ZONE);
					State = 3886; concatenation_wrapper();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				{
				State = 3889; interval_expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Interval_expressionContext : ParserRuleContext {
		public ITerminalNode DAY() { return GetToken(plsqlParser.DAY, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode SECOND() { return GetToken(plsqlParser.SECOND, 0); }
		public Concatenation_wrapperContext[] concatenation_wrapper() {
			return GetRuleContexts<Concatenation_wrapperContext>();
		}
		public Concatenation_wrapperContext concatenation_wrapper(int i) {
			return GetRuleContext<Concatenation_wrapperContext>(i);
		}
		public ITerminalNode YEAR() { return GetToken(plsqlParser.YEAR, 0); }
		public ITerminalNode MONTH() { return GetToken(plsqlParser.MONTH, 0); }
		public Interval_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interval_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInterval_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInterval_expression(this);
		}
	}

	[RuleVersion(0)]
	public Interval_expressionContext interval_expression() {
		Interval_expressionContext _localctx = new Interval_expressionContext(Context, State);
		EnterRule(_localctx, 534, RULE_interval_expression);
		int _la;
		try {
			State = 3916;
			switch (TokenStream.La(1)) {
			case DAY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3892; Match(DAY);
				State = 3897;
				_la = TokenStream.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 3893; Match(LEFT_PAREN);
					State = 3894; concatenation_wrapper();
					State = 3895; Match(RIGHT_PAREN);
					}
				}

				State = 3899; Match(TO);
				State = 3900; Match(SECOND);
				State = 3905;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,474,Context) ) {
				case 1:
					{
					State = 3901; Match(LEFT_PAREN);
					State = 3902; concatenation_wrapper();
					State = 3903; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3907; Match(YEAR);
				State = 3912;
				_la = TokenStream.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 3908; Match(LEFT_PAREN);
					State = 3909; concatenation_wrapper();
					State = 3910; Match(RIGHT_PAREN);
					}
				}

				State = 3914; Match(TO);
				State = 3915; Match(MONTH);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_expressionContext : ParserRuleContext {
		public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public Model_expression_elementContext model_expression_element() {
			return GetRuleContext<Model_expression_elementContext>(0);
		}
		public Model_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_expression(this);
		}
	}

	[RuleVersion(0)]
	public Model_expressionContext model_expression() {
		Model_expressionContext _localctx = new Model_expressionContext(Context, State);
		EnterRule(_localctx, 536, RULE_model_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3918; unary_expression();
			State = 3923;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,477,Context) ) {
			case 1:
				{
				State = 3919; Match(LEFT_BRACKET);
				State = 3920; model_expression_element();
				State = 3921; Match(RIGHT_BRACKET);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_expression_elementContext : ParserRuleContext {
		public ITerminalNode[] ANY() { return GetTokens(plsqlParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(plsqlParser.ANY, i);
		}
		public Condition_wrapperContext[] condition_wrapper() {
			return GetRuleContexts<Condition_wrapperContext>();
		}
		public Condition_wrapperContext condition_wrapper(int i) {
			return GetRuleContext<Condition_wrapperContext>(i);
		}
		public Single_column_for_loopContext[] single_column_for_loop() {
			return GetRuleContexts<Single_column_for_loopContext>();
		}
		public Single_column_for_loopContext single_column_for_loop(int i) {
			return GetRuleContext<Single_column_for_loopContext>(i);
		}
		public Multi_column_for_loopContext multi_column_for_loop() {
			return GetRuleContext<Multi_column_for_loopContext>(0);
		}
		public Model_expression_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_expression_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterModel_expression_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitModel_expression_element(this);
		}
	}

	[RuleVersion(0)]
	public Model_expression_elementContext model_expression_element() {
		Model_expression_elementContext _localctx = new Model_expression_elementContext(Context, State);
		EnterRule(_localctx, 538, RULE_model_expression_element);
		int _la;
		try {
			State = 3948;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,482,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3927;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,478,Context) ) {
				case 1:
					{
					State = 3925; Match(ANY);
					}
					break;
				case 2:
					{
					State = 3926; condition_wrapper();
					}
					break;
				}
				State = 3936;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3929; Match(COMMA);
					State = 3932;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,479,Context) ) {
					case 1:
						{
						State = 3930; Match(ANY);
						}
						break;
					case 2:
						{
						State = 3931; condition_wrapper();
						}
						break;
					}
					}
					}
					State = 3938;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3939; single_column_for_loop();
				State = 3944;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3940; Match(COMMA);
					State = 3941; single_column_for_loop();
					}
					}
					State = 3946;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3947; multi_column_for_loop();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Single_column_for_loopContext : ParserRuleContext {
		public ExpressionContext ex1;
		public ExpressionContext ex2;
		public ExpressionContext ex3;
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public For_increment_decrement_typeContext for_increment_decrement_type() {
			return GetRuleContext<For_increment_decrement_typeContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public For_like_partContext for_like_part() {
			return GetRuleContext<For_like_partContext>(0);
		}
		public Single_column_for_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_single_column_for_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSingle_column_for_loop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSingle_column_for_loop(this);
		}
	}

	[RuleVersion(0)]
	public Single_column_for_loopContext single_column_for_loop() {
		Single_column_for_loopContext _localctx = new Single_column_for_loopContext(Context, State);
		EnterRule(_localctx, 540, RULE_single_column_for_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3950; Match(FOR);
			State = 3951; column_name();
			State = 3964;
			switch (TokenStream.La(1)) {
			case IN:
				{
				State = 3952; Match(IN);
				State = 3953; expression_list();
				}
				break;
			case FROM:
			case LIKE:
				{
				State = 3955;
				_la = TokenStream.La(1);
				if (_la==LIKE) {
					{
					State = 3954; for_like_part();
					}
				}

				State = 3957; Match(FROM);
				State = 3958; _localctx.ex1 = expression();
				State = 3959; Match(TO);
				State = 3960; _localctx.ex2 = expression();
				State = 3961; for_increment_decrement_type();
				State = 3962; _localctx.ex3 = expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_like_partContext : ParserRuleContext {
		public ITerminalNode LIKE() { return GetToken(plsqlParser.LIKE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public For_like_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_like_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_like_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_like_part(this);
		}
	}

	[RuleVersion(0)]
	public For_like_partContext for_like_part() {
		For_like_partContext _localctx = new For_like_partContext(Context, State);
		EnterRule(_localctx, 542, RULE_for_like_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3966; Match(LIKE);
			State = 3967; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_increment_decrement_typeContext : ParserRuleContext {
		public ITerminalNode INCREMENT() { return GetToken(plsqlParser.INCREMENT, 0); }
		public ITerminalNode DECREMENT() { return GetToken(plsqlParser.DECREMENT, 0); }
		public For_increment_decrement_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_increment_decrement_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFor_increment_decrement_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFor_increment_decrement_type(this);
		}
	}

	[RuleVersion(0)]
	public For_increment_decrement_typeContext for_increment_decrement_type() {
		For_increment_decrement_typeContext _localctx = new For_increment_decrement_typeContext(Context, State);
		EnterRule(_localctx, 544, RULE_for_increment_decrement_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3969;
			_la = TokenStream.La(1);
			if ( !(_la==DECREMENT || _la==INCREMENT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_column_for_loopContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Expression_listContext[] expression_list() {
			return GetRuleContexts<Expression_listContext>();
		}
		public Expression_listContext expression_list(int i) {
			return GetRuleContext<Expression_listContext>(i);
		}
		public Multi_column_for_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_column_for_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMulti_column_for_loop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMulti_column_for_loop(this);
		}
	}

	[RuleVersion(0)]
	public Multi_column_for_loopContext multi_column_for_loop() {
		Multi_column_for_loopContext _localctx = new Multi_column_for_loopContext(Context, State);
		EnterRule(_localctx, 546, RULE_multi_column_for_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3971; Match(FOR);
			State = 3972; Match(LEFT_PAREN);
			State = 3973; column_name();
			State = 3978;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3974; Match(COMMA);
				State = 3975; column_name();
				}
				}
				State = 3980;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 3981; Match(RIGHT_PAREN);
			State = 3982; Match(IN);
			State = 3983; Match(LEFT_PAREN);
			State = 3996;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,487,Context) ) {
			case 1:
				{
				State = 3984; subquery();
				}
				break;
			case 2:
				{
				State = 3985; Match(LEFT_PAREN);
				State = 3986; expression_list();
				State = 3991;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3987; Match(COMMA);
					State = 3988; expression_list();
					}
					}
					State = 3993;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 3994; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 3998; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unary_expressionContext : ParserRuleContext {
		public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public ITerminalNode PRIOR() { return GetToken(plsqlParser.PRIOR, 0); }
		public ITerminalNode CONNECT_BY_ROOT() { return GetToken(plsqlParser.CONNECT_BY_ROOT, 0); }
		public ITerminalNode NEW() { return GetToken(plsqlParser.NEW, 0); }
		public ITerminalNode DISTINCT() { return GetToken(plsqlParser.DISTINCT, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Quantified_expressionContext quantified_expression() {
			return GetRuleContext<Quantified_expressionContext>(0);
		}
		public Standard_functionContext standard_function() {
			return GetRuleContext<Standard_functionContext>(0);
		}
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public Unary_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unary_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUnary_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUnary_expression(this);
		}
	}

	[RuleVersion(0)]
	public Unary_expressionContext unary_expression() {
		Unary_expressionContext _localctx = new Unary_expressionContext(Context, State);
		EnterRule(_localctx, 548, RULE_unary_expression);
		try {
			State = 4018;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,488,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4000; Match(MINUS_SIGN);
				State = 4001; unary_expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4002; Match(PLUS_SIGN);
				State = 4003; unary_expression();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4004; Match(PRIOR);
				State = 4005; unary_expression();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4006; Match(CONNECT_BY_ROOT);
				State = 4007; unary_expression();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4008; Match(NEW);
				State = 4009; unary_expression();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4010; Match(DISTINCT);
				State = 4011; unary_expression();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4012; Match(ALL);
				State = 4013; unary_expression();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4014; case_statement();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4015; quantified_expression();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4016; standard_function();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4017; atom();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_statementContext : ParserRuleContext {
		public Searched_case_statementContext searched_case_statement() {
			return GetRuleContext<Searched_case_statementContext>(0);
		}
		public Simple_case_statementContext simple_case_statement() {
			return GetRuleContext<Simple_case_statementContext>(0);
		}
		public Case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCase_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCase_statement(this);
		}
	}

	[RuleVersion(0)]
	public Case_statementContext case_statement() {
		Case_statementContext _localctx = new Case_statementContext(Context, State);
		EnterRule(_localctx, 550, RULE_case_statement);
		try {
			State = 4022;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,489,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4020; searched_case_statement();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4021; simple_case_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_case_statementContext : ParserRuleContext {
		public IToken ck1;
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public ITerminalNode[] CASE() { return GetTokens(plsqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(plsqlParser.CASE, i);
		}
		public Label_nameContext[] label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public Simple_case_when_partContext[] simple_case_when_part() {
			return GetRuleContexts<Simple_case_when_partContext>();
		}
		public Simple_case_when_partContext simple_case_when_part(int i) {
			return GetRuleContext<Simple_case_when_partContext>(i);
		}
		public Case_else_partContext case_else_part() {
			return GetRuleContext<Case_else_partContext>(0);
		}
		public Simple_case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSimple_case_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSimple_case_statement(this);
		}
	}

	[RuleVersion(0)]
	public Simple_case_statementContext simple_case_statement() {
		Simple_case_statementContext _localctx = new Simple_case_statementContext(Context, State);
		EnterRule(_localctx, 552, RULE_simple_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4025;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 4024; label_name();
				}
			}

			State = 4027; _localctx.ck1 = Match(CASE);
			State = 4028; atom();
			State = 4030;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 4029; simple_case_when_part();
				}
				}
				State = 4032;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==WHEN );
			State = 4035;
			_la = TokenStream.La(1);
			if (_la==ELSE) {
				{
				State = 4034; case_else_part();
				}
			}

			State = 4037; Match(END);
			State = 4039;
			_la = TokenStream.La(1);
			if (_la==CASE) {
				{
				State = 4038; Match(CASE);
				}
			}

			State = 4042;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,494,Context) ) {
			case 1:
				{
				State = 4041; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_case_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public Expression_wrapperContext[] expression_wrapper() {
			return GetRuleContexts<Expression_wrapperContext>();
		}
		public Expression_wrapperContext expression_wrapper(int i) {
			return GetRuleContext<Expression_wrapperContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Simple_case_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_case_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSimple_case_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSimple_case_when_part(this);
		}
	}

	[RuleVersion(0)]
	public Simple_case_when_partContext simple_case_when_part() {
		Simple_case_when_partContext _localctx = new Simple_case_when_partContext(Context, State);
		EnterRule(_localctx, 554, RULE_simple_case_when_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4044; Match(WHEN);
			State = 4045; expression_wrapper();
			State = 4046; Match(THEN);
			State = 4049;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,495,Context) ) {
			case 1:
				{
				State = 4047; seq_of_statements();
				}
				break;
			case 2:
				{
				State = 4048; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Searched_case_statementContext : ParserRuleContext {
		public IToken ck1;
		public ITerminalNode END() { return GetToken(plsqlParser.END, 0); }
		public ITerminalNode[] CASE() { return GetTokens(plsqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(plsqlParser.CASE, i);
		}
		public Label_nameContext[] label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public Searched_case_when_partContext[] searched_case_when_part() {
			return GetRuleContexts<Searched_case_when_partContext>();
		}
		public Searched_case_when_partContext searched_case_when_part(int i) {
			return GetRuleContext<Searched_case_when_partContext>(i);
		}
		public Case_else_partContext case_else_part() {
			return GetRuleContext<Case_else_partContext>(0);
		}
		public Searched_case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searched_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSearched_case_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSearched_case_statement(this);
		}
	}

	[RuleVersion(0)]
	public Searched_case_statementContext searched_case_statement() {
		Searched_case_statementContext _localctx = new Searched_case_statementContext(Context, State);
		EnterRule(_localctx, 556, RULE_searched_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4052;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==REGULAR_ID) {
				{
				State = 4051; label_name();
				}
			}

			State = 4054; _localctx.ck1 = Match(CASE);
			State = 4056;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			do {
				{
				{
				State = 4055; searched_case_when_part();
				}
				}
				State = 4058;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			} while ( _la==WHEN );
			State = 4061;
			_la = TokenStream.La(1);
			if (_la==ELSE) {
				{
				State = 4060; case_else_part();
				}
			}

			State = 4063; Match(END);
			State = 4065;
			_la = TokenStream.La(1);
			if (_la==CASE) {
				{
				State = 4064; Match(CASE);
				}
			}

			State = 4068;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,500,Context) ) {
			case 1:
				{
				State = 4067; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Searched_case_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(plsqlParser.WHEN, 0); }
		public Condition_wrapperContext condition_wrapper() {
			return GetRuleContext<Condition_wrapperContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(plsqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Searched_case_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searched_case_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSearched_case_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSearched_case_when_part(this);
		}
	}

	[RuleVersion(0)]
	public Searched_case_when_partContext searched_case_when_part() {
		Searched_case_when_partContext _localctx = new Searched_case_when_partContext(Context, State);
		EnterRule(_localctx, 558, RULE_searched_case_when_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4070; Match(WHEN);
			State = 4071; condition_wrapper();
			State = 4072; Match(THEN);
			State = 4075;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,501,Context) ) {
			case 1:
				{
				State = 4073; seq_of_statements();
				}
				break;
			case 2:
				{
				State = 4074; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(plsqlParser.ELSE, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Case_else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCase_else_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCase_else_part(this);
		}
	}

	[RuleVersion(0)]
	public Case_else_partContext case_else_part() {
		Case_else_partContext _localctx = new Case_else_partContext(Context, State);
		EnterRule(_localctx, 560, RULE_case_else_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4077; Match(ELSE);
			State = 4080;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,502,Context) ) {
			case 1:
				{
				State = 4078; seq_of_statements();
				}
				break;
			case 2:
				{
				State = 4079; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public Table_elementContext table_element() {
			return GetRuleContext<Table_elementContext>(0);
		}
		public Outer_join_signContext outer_join_sign() {
			return GetRuleContext<Outer_join_signContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Expression_or_vectorContext expression_or_vector() {
			return GetRuleContext<Expression_or_vectorContext>(0);
		}
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 562, RULE_atom);
		try {
			int _alt;
			State = 4102;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,505,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4082; table_element();
				State = 4083; outer_join_sign();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4085; bind_variable();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4086; constant();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4087; general_element();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4088; Match(LEFT_PAREN);
				State = 4100;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,504,Context) ) {
				case 1:
					{
					State = 4089; subquery();
					State = 4090; Match(RIGHT_PAREN);
					State = 4094;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,503,Context);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 4091; subquery_operation_part();
							}
							} 
						}
						State = 4096;
						ErrorHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(TokenStream,503,Context);
					}
					}
					break;
				case 2:
					{
					State = 4097; expression_or_vector();
					State = 4098; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_or_vectorContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Vector_exprContext vector_expr() {
			return GetRuleContext<Vector_exprContext>(0);
		}
		public Expression_or_vectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_or_vector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExpression_or_vector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExpression_or_vector(this);
		}
	}

	[RuleVersion(0)]
	public Expression_or_vectorContext expression_or_vector() {
		Expression_or_vectorContext _localctx = new Expression_or_vectorContext(Context, State);
		EnterRule(_localctx, 564, RULE_expression_or_vector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4104; expression();
			State = 4106;
			_la = TokenStream.La(1);
			if (_la==COMMA) {
				{
				State = 4105; vector_expr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Vector_exprContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Vector_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vector_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterVector_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitVector_expr(this);
		}
	}

	[RuleVersion(0)]
	public Vector_exprContext vector_expr() {
		Vector_exprContext _localctx = new Vector_exprContext(Context, State);
		EnterRule(_localctx, 566, RULE_vector_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4108; Match(COMMA);
			State = 4109; expression();
			State = 4114;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4110; Match(COMMA);
				State = 4111; expression();
				}
				}
				State = 4116;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quantified_expressionContext : ParserRuleContext {
		public ITerminalNode SOME() { return GetToken(plsqlParser.SOME, 0); }
		public ITerminalNode EXISTS() { return GetToken(plsqlParser.EXISTS, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public ITerminalNode ANY() { return GetToken(plsqlParser.ANY, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Quantified_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantified_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuantified_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuantified_expression(this);
		}
	}

	[RuleVersion(0)]
	public Quantified_expressionContext quantified_expression() {
		Quantified_expressionContext _localctx = new Quantified_expressionContext(Context, State);
		EnterRule(_localctx, 568, RULE_quantified_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4117;
			_la = TokenStream.La(1);
			if ( !(_la==ALL || _la==ANY || _la==EXISTS || _la==SOME) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 4126;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,508,Context) ) {
			case 1:
				{
				State = 4118; Match(LEFT_PAREN);
				State = 4119; subquery();
				State = 4120; Match(RIGHT_PAREN);
				}
				break;
			case 2:
				{
				State = 4122; Match(LEFT_PAREN);
				State = 4123; expression_wrapper();
				State = 4124; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Standard_functionContext : ParserRuleContext {
		public Over_clause_keywordContext over_clause_keyword() {
			return GetRuleContext<Over_clause_keywordContext>(0);
		}
		public Function_argument_analyticContext function_argument_analytic() {
			return GetRuleContext<Function_argument_analyticContext>(0);
		}
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public Function_argument_modelingContext function_argument_modeling() {
			return GetRuleContext<Function_argument_modelingContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public ITerminalNode COUNT() { return GetToken(plsqlParser.COUNT, 0); }
		public Concatenation_wrapperContext[] concatenation_wrapper() {
			return GetRuleContexts<Concatenation_wrapperContext>();
		}
		public Concatenation_wrapperContext concatenation_wrapper(int i) {
			return GetRuleContext<Concatenation_wrapperContext>(i);
		}
		public ITerminalNode DISTINCT() { return GetToken(plsqlParser.DISTINCT, 0); }
		public ITerminalNode UNIQUE() { return GetToken(plsqlParser.UNIQUE, 0); }
		public ITerminalNode ALL() { return GetToken(plsqlParser.ALL, 0); }
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode CAST() { return GetToken(plsqlParser.CAST, 0); }
		public ITerminalNode XMLCAST() { return GetToken(plsqlParser.XMLCAST, 0); }
		public ITerminalNode MULTISET() { return GetToken(plsqlParser.MULTISET, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode CHR() { return GetToken(plsqlParser.CHR, 0); }
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(plsqlParser.NCHAR_CS, 0); }
		public ITerminalNode COLLECT() { return GetToken(plsqlParser.COLLECT, 0); }
		public Collect_order_by_partContext collect_order_by_part() {
			return GetRuleContext<Collect_order_by_partContext>(0);
		}
		public Within_or_over_clause_keywordContext within_or_over_clause_keyword() {
			return GetRuleContext<Within_or_over_clause_keywordContext>(0);
		}
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public Within_or_over_partContext[] within_or_over_part() {
			return GetRuleContexts<Within_or_over_partContext>();
		}
		public Within_or_over_partContext within_or_over_part(int i) {
			return GetRuleContext<Within_or_over_partContext>(i);
		}
		public ITerminalNode DECOMPOSE() { return GetToken(plsqlParser.DECOMPOSE, 0); }
		public ITerminalNode CANONICAL() { return GetToken(plsqlParser.CANONICAL, 0); }
		public ITerminalNode COMPATIBILITY() { return GetToken(plsqlParser.COMPATIBILITY, 0); }
		public ITerminalNode EXTRACT() { return GetToken(plsqlParser.EXTRACT, 0); }
		public ITerminalNode FROM() { return GetToken(plsqlParser.FROM, 0); }
		public ITerminalNode FIRST_VALUE() { return GetToken(plsqlParser.FIRST_VALUE, 0); }
		public ITerminalNode LAST_VALUE() { return GetToken(plsqlParser.LAST_VALUE, 0); }
		public Respect_or_ignore_nullsContext respect_or_ignore_nulls() {
			return GetRuleContext<Respect_or_ignore_nullsContext>(0);
		}
		public Standard_prediction_function_keywordContext standard_prediction_function_keyword() {
			return GetRuleContext<Standard_prediction_function_keywordContext>(0);
		}
		public Expression_wrapperContext[] expression_wrapper() {
			return GetRuleContexts<Expression_wrapperContext>();
		}
		public Expression_wrapperContext expression_wrapper(int i) {
			return GetRuleContext<Expression_wrapperContext>(i);
		}
		public Cost_matrix_clauseContext cost_matrix_clause() {
			return GetRuleContext<Cost_matrix_clauseContext>(0);
		}
		public ITerminalNode TRANSLATE() { return GetToken(plsqlParser.TRANSLATE, 0); }
		public ITerminalNode CHAR_CS() { return GetToken(plsqlParser.CHAR_CS, 0); }
		public ITerminalNode TREAT() { return GetToken(plsqlParser.TREAT, 0); }
		public ITerminalNode REF() { return GetToken(plsqlParser.REF, 0); }
		public ITerminalNode TRIM() { return GetToken(plsqlParser.TRIM, 0); }
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode LEADING() { return GetToken(plsqlParser.LEADING, 0); }
		public ITerminalNode TRAILING() { return GetToken(plsqlParser.TRAILING, 0); }
		public ITerminalNode BOTH() { return GetToken(plsqlParser.BOTH, 0); }
		public ITerminalNode XMLAGG() { return GetToken(plsqlParser.XMLAGG, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public Xml_multiuse_expression_elementContext[] xml_multiuse_expression_element() {
			return GetRuleContexts<Xml_multiuse_expression_elementContext>();
		}
		public Xml_multiuse_expression_elementContext xml_multiuse_expression_element(int i) {
			return GetRuleContext<Xml_multiuse_expression_elementContext>(i);
		}
		public ITerminalNode XMLCOLATTVAL() { return GetToken(plsqlParser.XMLCOLATTVAL, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(plsqlParser.XMLFOREST, 0); }
		public ITerminalNode XMLELEMENT() { return GetToken(plsqlParser.XMLELEMENT, 0); }
		public Xml_attributes_clauseContext xml_attributes_clause() {
			return GetRuleContext<Xml_attributes_clauseContext>(0);
		}
		public ITerminalNode ENTITYESCAPING() { return GetToken(plsqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(plsqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode EVALNAME() { return GetToken(plsqlParser.EVALNAME, 0); }
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public ITerminalNode XMLEXISTS() { return GetToken(plsqlParser.XMLEXISTS, 0); }
		public Xml_passing_clauseContext xml_passing_clause() {
			return GetRuleContext<Xml_passing_clauseContext>(0);
		}
		public ITerminalNode XMLPARSE() { return GetToken(plsqlParser.XMLPARSE, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(plsqlParser.DOCUMENT, 0); }
		public ITerminalNode CONTENT() { return GetToken(plsqlParser.CONTENT, 0); }
		public ITerminalNode WELLFORMED() { return GetToken(plsqlParser.WELLFORMED, 0); }
		public ITerminalNode XMLPI() { return GetToken(plsqlParser.XMLPI, 0); }
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ITerminalNode XMLQUERY() { return GetToken(plsqlParser.XMLQUERY, 0); }
		public ITerminalNode RETURNING() { return GetToken(plsqlParser.RETURNING, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public ITerminalNode EMPTY() { return GetToken(plsqlParser.EMPTY, 0); }
		public ITerminalNode XMLROOT() { return GetToken(plsqlParser.XMLROOT, 0); }
		public Xmlroot_param_version_partContext xmlroot_param_version_part() {
			return GetRuleContext<Xmlroot_param_version_partContext>(0);
		}
		public Xmlroot_param_standalone_partContext xmlroot_param_standalone_part() {
			return GetRuleContext<Xmlroot_param_standalone_partContext>(0);
		}
		public ITerminalNode XMLSERIALIZE() { return GetToken(plsqlParser.XMLSERIALIZE, 0); }
		public Xmlserialize_param_enconding_partContext xmlserialize_param_enconding_part() {
			return GetRuleContext<Xmlserialize_param_enconding_partContext>(0);
		}
		public Xmlserialize_param_version_partContext xmlserialize_param_version_part() {
			return GetRuleContext<Xmlserialize_param_version_partContext>(0);
		}
		public Xmlserialize_param_ident_partContext xmlserialize_param_ident_part() {
			return GetRuleContext<Xmlserialize_param_ident_partContext>(0);
		}
		public ITerminalNode DEFAULTS() { return GetToken(plsqlParser.DEFAULTS, 0); }
		public ITerminalNode HIDE() { return GetToken(plsqlParser.HIDE, 0); }
		public ITerminalNode SHOW() { return GetToken(plsqlParser.SHOW, 0); }
		public ITerminalNode XMLTABLE() { return GetToken(plsqlParser.XMLTABLE, 0); }
		public Xml_namespaces_clauseContext xml_namespaces_clause() {
			return GetRuleContext<Xml_namespaces_clauseContext>(0);
		}
		public ITerminalNode COLUMNS() { return GetToken(plsqlParser.COLUMNS, 0); }
		public Xml_table_columnContext[] xml_table_column() {
			return GetRuleContexts<Xml_table_columnContext>();
		}
		public Xml_table_columnContext xml_table_column(int i) {
			return GetRuleContext<Xml_table_columnContext>(i);
		}
		public Standard_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_standard_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStandard_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStandard_function(this);
		}
	}

	[RuleVersion(0)]
	public Standard_functionContext standard_function() {
		Standard_functionContext _localctx = new Standard_functionContext(Context, State);
		EnterRule(_localctx, 570, RULE_standard_function);
		int _la;
		try {
			int _alt;
			State = 4442;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,561,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4128; over_clause_keyword();
				State = 4129; function_argument_analytic();
				State = 4131;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,509,Context) ) {
				case 1:
					{
					State = 4130; over_clause();
					}
					break;
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4133; regular_id();
				State = 4134; function_argument_modeling();
				State = 4136;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,510,Context) ) {
				case 1:
					{
					State = 4135; using_clause();
					}
					break;
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4138; Match(COUNT);
				State = 4139; Match(LEFT_PAREN);
				State = 4145;
				switch (TokenStream.La(1)) {
				case ASTERISK:
					{
					State = 4140; Match(ASTERISK);
					}
					break;
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALL:
				case ANALYZE:
				case ANY:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONNECT_BY_ROOT:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DISTINCT:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FALSE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIOR:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNIQUE:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
				case DELIMITED_ID:
				case LEFT_PAREN:
				case PLUS_SIGN:
				case MINUS_SIGN:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 4142;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,511,Context) ) {
					case 1:
						{
						State = 4141;
						_la = TokenStream.La(1);
						if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						}
						break;
					}
					State = 4144; concatenation_wrapper();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4147; Match(RIGHT_PAREN);
				State = 4149;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,513,Context) ) {
				case 1:
					{
					State = 4148; over_clause();
					}
					break;
				}
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4151;
				_la = TokenStream.La(1);
				if ( !(_la==CAST || _la==XMLCAST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 4152; Match(LEFT_PAREN);
				State = 4159;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,514,Context) ) {
				case 1:
					{
					State = 4153; Match(MULTISET);
					State = 4154; Match(LEFT_PAREN);
					State = 4155; subquery();
					State = 4156; Match(RIGHT_PAREN);
					}
					break;
				case 2:
					{
					State = 4158; concatenation_wrapper();
					}
					break;
				}
				State = 4161; Match(AS);
				State = 4162; type_spec();
				State = 4163; Match(RIGHT_PAREN);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4165; Match(CHR);
				State = 4166; Match(LEFT_PAREN);
				State = 4167; concatenation_wrapper();
				State = 4168; Match(USING);
				State = 4169; Match(NCHAR_CS);
				State = 4170; Match(RIGHT_PAREN);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4172; Match(COLLECT);
				State = 4173; Match(LEFT_PAREN);
				State = 4175;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,515,Context) ) {
				case 1:
					{
					State = 4174;
					_la = TokenStream.La(1);
					if ( !(_la==DISTINCT || _la==UNIQUE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					}
					break;
				}
				State = 4177; concatenation_wrapper();
				State = 4179;
				_la = TokenStream.La(1);
				if (_la==ORDER) {
					{
					State = 4178; collect_order_by_part();
					}
				}

				State = 4181; Match(RIGHT_PAREN);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4183; within_or_over_clause_keyword();
				State = 4184; function_argument();
				State = 4186;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 4185; within_or_over_part();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4188;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,517,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4190; Match(DECOMPOSE);
				State = 4191; Match(LEFT_PAREN);
				State = 4192; concatenation_wrapper();
				State = 4194;
				_la = TokenStream.La(1);
				if (_la==CANONICAL || _la==COMPATIBILITY) {
					{
					State = 4193;
					_la = TokenStream.La(1);
					if ( !(_la==CANONICAL || _la==COMPATIBILITY) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					}
				}

				State = 4196; Match(RIGHT_PAREN);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4198; Match(EXTRACT);
				State = 4199; Match(LEFT_PAREN);
				State = 4200; regular_id();
				State = 4201; Match(FROM);
				State = 4202; concatenation_wrapper();
				State = 4203; Match(RIGHT_PAREN);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4205;
				_la = TokenStream.La(1);
				if ( !(_la==FIRST_VALUE || _la==LAST_VALUE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 4206; function_argument_analytic();
				State = 4208;
				_la = TokenStream.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 4207; respect_or_ignore_nulls();
					}
				}

				State = 4210; over_clause();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4212; standard_prediction_function_keyword();
				State = 4213; Match(LEFT_PAREN);
				State = 4214; expression_wrapper();
				State = 4219;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4215; Match(COMMA);
					State = 4216; expression_wrapper();
					}
					}
					State = 4221;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 4223;
				_la = TokenStream.La(1);
				if (_la==COST) {
					{
					State = 4222; cost_matrix_clause();
					}
				}

				State = 4226;
				_la = TokenStream.La(1);
				if (_la==USING) {
					{
					State = 4225; using_clause();
					}
				}

				State = 4228; Match(RIGHT_PAREN);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 4230; Match(TRANSLATE);
				State = 4231; Match(LEFT_PAREN);
				State = 4232; expression_wrapper();
				State = 4235;
				_la = TokenStream.La(1);
				if (_la==USING) {
					{
					State = 4233; Match(USING);
					State = 4234;
					_la = TokenStream.La(1);
					if ( !(_la==CHAR_CS || _la==NCHAR_CS) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					}
				}

				State = 4241;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4237; Match(COMMA);
					State = 4238; expression_wrapper();
					}
					}
					State = 4243;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 4244; Match(RIGHT_PAREN);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 4246; Match(TREAT);
				State = 4247; Match(LEFT_PAREN);
				State = 4248; expression_wrapper();
				State = 4249; Match(AS);
				State = 4251;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,525,Context) ) {
				case 1:
					{
					State = 4250; Match(REF);
					}
					break;
				}
				State = 4253; type_spec();
				State = 4254; Match(RIGHT_PAREN);
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 4256; Match(TRIM);
				State = 4257; Match(LEFT_PAREN);
				State = 4265;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,528,Context) ) {
				case 1:
					{
					State = 4259;
					_la = TokenStream.La(1);
					if (_la==BOTH || _la==LEADING || _la==TRAILING) {
						{
						State = 4258;
						_la = TokenStream.La(1);
						if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						}
					}

					State = 4262;
					_la = TokenStream.La(1);
					if (_la==NATIONAL_CHAR_STRING_LIT || _la==CHAR_STRING) {
						{
						State = 4261; quoted_string();
						}
					}

					State = 4264; Match(FROM);
					}
					break;
				}
				State = 4267; concatenation_wrapper();
				State = 4268; Match(RIGHT_PAREN);
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 4270; Match(XMLAGG);
				State = 4271; Match(LEFT_PAREN);
				State = 4272; expression_wrapper();
				State = 4274;
				_la = TokenStream.La(1);
				if (_la==ORDER) {
					{
					State = 4273; order_by_clause();
					}
				}

				State = 4276; Match(RIGHT_PAREN);
				State = 4279;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4277; Match(PERIOD);
					State = 4278; general_element_part();
					}
				}

				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 4281;
				_la = TokenStream.La(1);
				if ( !(_la==XMLCOLATTVAL || _la==XMLFOREST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 4282; Match(LEFT_PAREN);
				State = 4283; xml_multiuse_expression_element();
				State = 4288;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4284; Match(COMMA);
					State = 4285; xml_multiuse_expression_element();
					}
					}
					State = 4290;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 4291; Match(RIGHT_PAREN);
				State = 4294;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4292; Match(PERIOD);
					State = 4293; general_element_part();
					}
				}

				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 4296; Match(XMLELEMENT);
				State = 4297; Match(LEFT_PAREN);
				State = 4299;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,533,Context) ) {
				case 1:
					{
					State = 4298;
					_la = TokenStream.La(1);
					if ( !(_la==ENTITYESCAPING || _la==NOENTITYESCAPING) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					}
					break;
				}
				State = 4302;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,534,Context) ) {
				case 1:
					{
					State = 4301;
					_la = TokenStream.La(1);
					if ( !(_la==EVALNAME || _la==NAME) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					}
					break;
				}
				State = 4304; expression_wrapper();
				State = 4307;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,535,Context) ) {
				case 1:
					{
					State = 4305; Match(COMMA);
					State = 4306; xml_attributes_clause();
					}
					break;
				}
				State = 4316;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4309; Match(COMMA);
					State = 4310; expression_wrapper();
					State = 4312;
					_la = TokenStream.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 4311; column_alias();
						}
					}

					}
					}
					State = 4318;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 4319; Match(RIGHT_PAREN);
				State = 4322;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4320; Match(PERIOD);
					State = 4321; general_element_part();
					}
				}

				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 4324; Match(XMLEXISTS);
				State = 4325; Match(LEFT_PAREN);
				State = 4326; expression_wrapper();
				State = 4328;
				_la = TokenStream.La(1);
				if (_la==PASSING) {
					{
					State = 4327; xml_passing_clause();
					}
				}

				State = 4330; Match(RIGHT_PAREN);
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 4332; Match(XMLPARSE);
				State = 4333; Match(LEFT_PAREN);
				State = 4334;
				_la = TokenStream.La(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 4335; concatenation_wrapper();
				State = 4337;
				_la = TokenStream.La(1);
				if (_la==WELLFORMED) {
					{
					State = 4336; Match(WELLFORMED);
					}
				}

				State = 4339; Match(RIGHT_PAREN);
				State = 4342;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4340; Match(PERIOD);
					State = 4341; general_element_part();
					}
				}

				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 4344; Match(XMLPI);
				State = 4345; Match(LEFT_PAREN);
				State = 4350;
				switch (TokenStream.La(1)) {
				case NAME:
					{
					State = 4346; Match(NAME);
					State = 4347; id();
					}
					break;
				case EVALNAME:
					{
					State = 4348; Match(EVALNAME);
					State = 4349; concatenation_wrapper();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4354;
				_la = TokenStream.La(1);
				if (_la==COMMA) {
					{
					State = 4352; Match(COMMA);
					State = 4353; concatenation_wrapper();
					}
				}

				State = 4356; Match(RIGHT_PAREN);
				State = 4359;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4357; Match(PERIOD);
					State = 4358; general_element_part();
					}
				}

				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 4361; Match(XMLQUERY);
				State = 4362; Match(LEFT_PAREN);
				State = 4363; concatenation_wrapper();
				State = 4365;
				_la = TokenStream.La(1);
				if (_la==PASSING) {
					{
					State = 4364; xml_passing_clause();
					}
				}

				State = 4367; Match(RETURNING);
				State = 4368; Match(CONTENT);
				State = 4372;
				_la = TokenStream.La(1);
				if (_la==NULL) {
					{
					State = 4369; Match(NULL);
					State = 4370; Match(ON);
					State = 4371; Match(EMPTY);
					}
				}

				State = 4374; Match(RIGHT_PAREN);
				State = 4377;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4375; Match(PERIOD);
					State = 4376; general_element_part();
					}
				}

				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 4379; Match(XMLROOT);
				State = 4380; Match(LEFT_PAREN);
				State = 4381; concatenation_wrapper();
				State = 4384;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,548,Context) ) {
				case 1:
					{
					State = 4382; Match(COMMA);
					State = 4383; xmlroot_param_version_part();
					}
					break;
				}
				State = 4388;
				_la = TokenStream.La(1);
				if (_la==COMMA) {
					{
					State = 4386; Match(COMMA);
					State = 4387; xmlroot_param_standalone_part();
					}
				}

				State = 4390; Match(RIGHT_PAREN);
				State = 4393;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4391; Match(PERIOD);
					State = 4392; general_element_part();
					}
				}

				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 4395; Match(XMLSERIALIZE);
				State = 4396; Match(LEFT_PAREN);
				State = 4397;
				_la = TokenStream.La(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 4398; concatenation_wrapper();
				State = 4401;
				_la = TokenStream.La(1);
				if (_la==AS) {
					{
					State = 4399; Match(AS);
					State = 4400; type_spec();
					}
				}

				State = 4404;
				_la = TokenStream.La(1);
				if (_la==ENCODING) {
					{
					State = 4403; xmlserialize_param_enconding_part();
					}
				}

				State = 4407;
				_la = TokenStream.La(1);
				if (_la==VERSION) {
					{
					State = 4406; xmlserialize_param_version_part();
					}
				}

				State = 4410;
				_la = TokenStream.La(1);
				if (_la==INDENT || _la==NO) {
					{
					State = 4409; xmlserialize_param_ident_part();
					}
				}

				State = 4414;
				_la = TokenStream.La(1);
				if (_la==HIDE || _la==SHOW) {
					{
					State = 4412;
					_la = TokenStream.La(1);
					if ( !(_la==HIDE || _la==SHOW) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					State = 4413; Match(DEFAULTS);
					}
				}

				State = 4416; Match(RIGHT_PAREN);
				State = 4419;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4417; Match(PERIOD);
					State = 4418; general_element_part();
					}
				}

				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 4421; Match(XMLTABLE);
				State = 4422; Match(LEFT_PAREN);
				State = 4424;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,557,Context) ) {
				case 1:
					{
					State = 4423; xml_namespaces_clause();
					}
					break;
				}
				State = 4426; concatenation_wrapper();
				State = 4428;
				_la = TokenStream.La(1);
				if (_la==PASSING) {
					{
					State = 4427; xml_passing_clause();
					}
				}

				State = 4435;
				_la = TokenStream.La(1);
				if (_la==COLUMNS) {
					{
					State = 4430; Match(COLUMNS);
					State = 4431; xml_table_column();
					{
					State = 4432; Match(COMMA);
					State = 4433; xml_table_column();
					}
					}
				}

				State = 4437; Match(RIGHT_PAREN);
				State = 4440;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4438; Match(PERIOD);
					State = 4439; general_element_part();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Over_clause_keywordContext : ParserRuleContext {
		public ITerminalNode AVG() { return GetToken(plsqlParser.AVG, 0); }
		public ITerminalNode CORR() { return GetToken(plsqlParser.CORR, 0); }
		public ITerminalNode LAG() { return GetToken(plsqlParser.LAG, 0); }
		public ITerminalNode LEAD() { return GetToken(plsqlParser.LEAD, 0); }
		public ITerminalNode MAX() { return GetToken(plsqlParser.MAX, 0); }
		public ITerminalNode MEDIAN() { return GetToken(plsqlParser.MEDIAN, 0); }
		public ITerminalNode MIN() { return GetToken(plsqlParser.MIN, 0); }
		public ITerminalNode NTILE() { return GetToken(plsqlParser.NTILE, 0); }
		public ITerminalNode RATIO_TO_REPORT() { return GetToken(plsqlParser.RATIO_TO_REPORT, 0); }
		public ITerminalNode ROW_NUMBER() { return GetToken(plsqlParser.ROW_NUMBER, 0); }
		public ITerminalNode SUM() { return GetToken(plsqlParser.SUM, 0); }
		public ITerminalNode VARIANCE() { return GetToken(plsqlParser.VARIANCE, 0); }
		public ITerminalNode REGR_() { return GetToken(plsqlParser.REGR_, 0); }
		public ITerminalNode STDDEV() { return GetToken(plsqlParser.STDDEV, 0); }
		public ITerminalNode VAR_() { return GetToken(plsqlParser.VAR_, 0); }
		public ITerminalNode COVAR_() { return GetToken(plsqlParser.COVAR_, 0); }
		public Over_clause_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_over_clause_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOver_clause_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOver_clause_keyword(this);
		}
	}

	[RuleVersion(0)]
	public Over_clause_keywordContext over_clause_keyword() {
		Over_clause_keywordContext _localctx = new Over_clause_keywordContext(Context, State);
		EnterRule(_localctx, 572, RULE_over_clause_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4444;
			_la = TokenStream.La(1);
			if ( !(((((_la - 462)) & ~0x3f) == 0 && ((1L << (_la - 462)) & ((1L << (AVG - 462)) | (1L << (CORR - 462)) | (1L << (LAG - 462)) | (1L << (LEAD - 462)) | (1L << (MAX - 462)) | (1L << (MEDIAN - 462)) | (1L << (MIN - 462)) | (1L << (NTILE - 462)) | (1L << (RATIO_TO_REPORT - 462)) | (1L << (ROW_NUMBER - 462)) | (1L << (SUM - 462)) | (1L << (VARIANCE - 462)) | (1L << (REGR_ - 462)) | (1L << (STDDEV - 462)) | (1L << (VAR_ - 462)) | (1L << (COVAR_ - 462)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Within_or_over_clause_keywordContext : ParserRuleContext {
		public ITerminalNode CUME_DIST() { return GetToken(plsqlParser.CUME_DIST, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(plsqlParser.DENSE_RANK, 0); }
		public ITerminalNode LISTAGG() { return GetToken(plsqlParser.LISTAGG, 0); }
		public ITerminalNode PERCENT_RANK() { return GetToken(plsqlParser.PERCENT_RANK, 0); }
		public ITerminalNode PERCENTILE_CONT() { return GetToken(plsqlParser.PERCENTILE_CONT, 0); }
		public ITerminalNode PERCENTILE_DISC() { return GetToken(plsqlParser.PERCENTILE_DISC, 0); }
		public ITerminalNode RANK() { return GetToken(plsqlParser.RANK, 0); }
		public Within_or_over_clause_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_within_or_over_clause_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWithin_or_over_clause_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWithin_or_over_clause_keyword(this);
		}
	}

	[RuleVersion(0)]
	public Within_or_over_clause_keywordContext within_or_over_clause_keyword() {
		Within_or_over_clause_keywordContext _localctx = new Within_or_over_clause_keywordContext(Context, State);
		EnterRule(_localctx, 574, RULE_within_or_over_clause_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4446;
			_la = TokenStream.La(1);
			if ( !(((((_la - 455)) & ~0x3f) == 0 && ((1L << (_la - 455)) & ((1L << (CUME_DIST - 455)) | (1L << (DENSE_RANK - 455)) | (1L << (LISTAGG - 455)) | (1L << (PERCENT_RANK - 455)) | (1L << (PERCENTILE_CONT - 455)) | (1L << (PERCENTILE_DISC - 455)) | (1L << (RANK - 455)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Standard_prediction_function_keywordContext : ParserRuleContext {
		public ITerminalNode PREDICTION() { return GetToken(plsqlParser.PREDICTION, 0); }
		public ITerminalNode PREDICTION_BOUNDS() { return GetToken(plsqlParser.PREDICTION_BOUNDS, 0); }
		public ITerminalNode PREDICTION_COST() { return GetToken(plsqlParser.PREDICTION_COST, 0); }
		public ITerminalNode PREDICTION_DETAILS() { return GetToken(plsqlParser.PREDICTION_DETAILS, 0); }
		public ITerminalNode PREDICTION_PROBABILITY() { return GetToken(plsqlParser.PREDICTION_PROBABILITY, 0); }
		public ITerminalNode PREDICTION_SET() { return GetToken(plsqlParser.PREDICTION_SET, 0); }
		public Standard_prediction_function_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_standard_prediction_function_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterStandard_prediction_function_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitStandard_prediction_function_keyword(this);
		}
	}

	[RuleVersion(0)]
	public Standard_prediction_function_keywordContext standard_prediction_function_keyword() {
		Standard_prediction_function_keywordContext _localctx = new Standard_prediction_function_keywordContext(Context, State);
		EnterRule(_localctx, 576, RULE_standard_prediction_function_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4448;
			_la = TokenStream.La(1);
			if ( !(((((_la - 449)) & ~0x3f) == 0 && ((1L << (_la - 449)) & ((1L << (PREDICTION - 449)) | (1L << (PREDICTION_BOUNDS - 449)) | (1L << (PREDICTION_COST - 449)) | (1L << (PREDICTION_DETAILS - 449)) | (1L << (PREDICTION_PROBABILITY - 449)) | (1L << (PREDICTION_SET - 449)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Over_clauseContext : ParserRuleContext {
		public ITerminalNode OVER() { return GetToken(plsqlParser.OVER, 0); }
		public Query_partition_clauseContext query_partition_clause() {
			return GetRuleContext<Query_partition_clauseContext>(0);
		}
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Windowing_clauseContext windowing_clause() {
			return GetRuleContext<Windowing_clauseContext>(0);
		}
		public Over_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_over_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOver_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOver_clause(this);
		}
	}

	[RuleVersion(0)]
	public Over_clauseContext over_clause() {
		Over_clauseContext _localctx = new Over_clauseContext(Context, State);
		EnterRule(_localctx, 578, RULE_over_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4450; Match(OVER);
			State = 4451; Match(LEFT_PAREN);
			State = 4453;
			_la = TokenStream.La(1);
			if (_la==PARTITION) {
				{
				State = 4452; query_partition_clause();
				}
			}

			State = 4459;
			_la = TokenStream.La(1);
			if (_la==ORDER) {
				{
				State = 4455; order_by_clause();
				State = 4457;
				_la = TokenStream.La(1);
				if (_la==RANGE || _la==ROWS) {
					{
					State = 4456; windowing_clause();
					}
				}

				}
			}

			State = 4461; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_clauseContext : ParserRuleContext {
		public Windowing_typeContext windowing_type() {
			return GetRuleContext<Windowing_typeContext>(0);
		}
		public ITerminalNode BETWEEN() { return GetToken(plsqlParser.BETWEEN, 0); }
		public Windowing_elementsContext[] windowing_elements() {
			return GetRuleContexts<Windowing_elementsContext>();
		}
		public Windowing_elementsContext windowing_elements(int i) {
			return GetRuleContext<Windowing_elementsContext>(i);
		}
		public ITerminalNode AND() { return GetToken(plsqlParser.AND, 0); }
		public Windowing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWindowing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWindowing_clause(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_clauseContext windowing_clause() {
		Windowing_clauseContext _localctx = new Windowing_clauseContext(Context, State);
		EnterRule(_localctx, 580, RULE_windowing_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4463; windowing_type();
			State = 4470;
			switch (TokenStream.La(1)) {
			case BETWEEN:
				{
				State = 4464; Match(BETWEEN);
				State = 4465; windowing_elements();
				State = 4466; Match(AND);
				State = 4467; windowing_elements();
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4469; windowing_elements();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_typeContext : ParserRuleContext {
		public ITerminalNode ROWS() { return GetToken(plsqlParser.ROWS, 0); }
		public ITerminalNode RANGE() { return GetToken(plsqlParser.RANGE, 0); }
		public Windowing_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWindowing_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWindowing_type(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_typeContext windowing_type() {
		Windowing_typeContext _localctx = new Windowing_typeContext(Context, State);
		EnterRule(_localctx, 582, RULE_windowing_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4472;
			_la = TokenStream.La(1);
			if ( !(_la==RANGE || _la==ROWS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_elementsContext : ParserRuleContext {
		public ITerminalNode UNBOUNDED() { return GetToken(plsqlParser.UNBOUNDED, 0); }
		public ITerminalNode PRECEDING() { return GetToken(plsqlParser.PRECEDING, 0); }
		public ITerminalNode CURRENT() { return GetToken(plsqlParser.CURRENT, 0); }
		public ITerminalNode ROW() { return GetToken(plsqlParser.ROW, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public ITerminalNode FOLLOWING() { return GetToken(plsqlParser.FOLLOWING, 0); }
		public Windowing_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWindowing_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWindowing_elements(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_elementsContext windowing_elements() {
		Windowing_elementsContext _localctx = new Windowing_elementsContext(Context, State);
		EnterRule(_localctx, 584, RULE_windowing_elements);
		int _la;
		try {
			State = 4481;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,566,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4474; Match(UNBOUNDED);
				State = 4475; Match(PRECEDING);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4476; Match(CURRENT);
				State = 4477; Match(ROW);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4478; concatenation_wrapper();
				State = 4479;
				_la = TokenStream.La(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_clauseContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public Using_elementContext[] using_element() {
			return GetRuleContexts<Using_elementContext>();
		}
		public Using_elementContext using_element(int i) {
			return GetRuleContext<Using_elementContext>(i);
		}
		public Using_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUsing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUsing_clause(this);
		}
	}

	[RuleVersion(0)]
	public Using_clauseContext using_clause() {
		Using_clauseContext _localctx = new Using_clauseContext(Context, State);
		EnterRule(_localctx, 586, RULE_using_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4483; Match(USING);
			State = 4493;
			switch (TokenStream.La(1)) {
			case ASTERISK:
				{
				State = 4484; Match(ASTERISK);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4485; using_element();
				State = 4490;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,567,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 4486; Match(COMMA);
						State = 4487; using_element();
						}
						} 
					}
					State = 4492;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,567,Context);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_elementContext : ParserRuleContext {
		public Select_list_elementsContext select_list_elements() {
			return GetRuleContext<Select_list_elementsContext>(0);
		}
		public ITerminalNode IN() { return GetToken(plsqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(plsqlParser.OUT, 0); }
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Using_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterUsing_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitUsing_element(this);
		}
	}

	[RuleVersion(0)]
	public Using_elementContext using_element() {
		Using_elementContext _localctx = new Using_elementContext(Context, State);
		EnterRule(_localctx, 588, RULE_using_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4500;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,570,Context) ) {
			case 1:
				{
				State = 4495; Match(IN);
				State = 4497;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,569,Context) ) {
				case 1:
					{
					State = 4496; Match(OUT);
					}
					break;
				}
				}
				break;
			case 2:
				{
				State = 4499; Match(OUT);
				}
				break;
			}
			State = 4502; select_list_elements();
			State = 4504;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,571,Context) ) {
			case 1:
				{
				State = 4503; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collect_order_by_partContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(plsqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Collect_order_by_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collect_order_by_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCollect_order_by_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCollect_order_by_part(this);
		}
	}

	[RuleVersion(0)]
	public Collect_order_by_partContext collect_order_by_part() {
		Collect_order_by_partContext _localctx = new Collect_order_by_partContext(Context, State);
		EnterRule(_localctx, 590, RULE_collect_order_by_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4506; Match(ORDER);
			State = 4507; Match(BY);
			State = 4508; concatenation_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Within_or_over_partContext : ParserRuleContext {
		public ITerminalNode WITHIN() { return GetToken(plsqlParser.WITHIN, 0); }
		public ITerminalNode GROUP() { return GetToken(plsqlParser.GROUP, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Within_or_over_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_within_or_over_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWithin_or_over_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWithin_or_over_part(this);
		}
	}

	[RuleVersion(0)]
	public Within_or_over_partContext within_or_over_part() {
		Within_or_over_partContext _localctx = new Within_or_over_partContext(Context, State);
		EnterRule(_localctx, 592, RULE_within_or_over_part);
		try {
			State = 4517;
			switch (TokenStream.La(1)) {
			case WITHIN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4510; Match(WITHIN);
				State = 4511; Match(GROUP);
				State = 4512; Match(LEFT_PAREN);
				State = 4513; order_by_clause();
				State = 4514; Match(RIGHT_PAREN);
				}
				break;
			case OVER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4516; over_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cost_matrix_clauseContext : ParserRuleContext {
		public ITerminalNode COST() { return GetToken(plsqlParser.COST, 0); }
		public ITerminalNode MODEL() { return GetToken(plsqlParser.MODEL, 0); }
		public Cost_class_nameContext[] cost_class_name() {
			return GetRuleContexts<Cost_class_nameContext>();
		}
		public Cost_class_nameContext cost_class_name(int i) {
			return GetRuleContext<Cost_class_nameContext>(i);
		}
		public ITerminalNode VALUES() { return GetToken(plsqlParser.VALUES, 0); }
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode AUTO() { return GetToken(plsqlParser.AUTO, 0); }
		public Cost_matrix_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cost_matrix_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCost_matrix_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCost_matrix_clause(this);
		}
	}

	[RuleVersion(0)]
	public Cost_matrix_clauseContext cost_matrix_clause() {
		Cost_matrix_clauseContext _localctx = new Cost_matrix_clauseContext(Context, State);
		EnterRule(_localctx, 594, RULE_cost_matrix_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4519; Match(COST);
			State = 4537;
			switch (TokenStream.La(1)) {
			case MODEL:
				{
				State = 4520; Match(MODEL);
				State = 4522;
				_la = TokenStream.La(1);
				if (_la==AUTO) {
					{
					State = 4521; Match(AUTO);
					}
				}

				}
				break;
			case LEFT_PAREN:
				{
				State = 4524; Match(LEFT_PAREN);
				State = 4525; cost_class_name();
				State = 4530;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4526; Match(COMMA);
					State = 4527; cost_class_name();
					}
					}
					State = 4532;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 4533; Match(RIGHT_PAREN);
				State = 4534; Match(VALUES);
				State = 4535; expression_list();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_passing_clauseContext : ParserRuleContext {
		public ITerminalNode PASSING() { return GetToken(plsqlParser.PASSING, 0); }
		public Expression_wrapperContext[] expression_wrapper() {
			return GetRuleContexts<Expression_wrapperContext>();
		}
		public Expression_wrapperContext expression_wrapper(int i) {
			return GetRuleContext<Expression_wrapperContext>(i);
		}
		public ITerminalNode BY() { return GetToken(plsqlParser.BY, 0); }
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public Xml_passing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_passing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_passing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_passing_clause(this);
		}
	}

	[RuleVersion(0)]
	public Xml_passing_clauseContext xml_passing_clause() {
		Xml_passing_clauseContext _localctx = new Xml_passing_clauseContext(Context, State);
		EnterRule(_localctx, 596, RULE_xml_passing_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4539; Match(PASSING);
			State = 4542;
			_la = TokenStream.La(1);
			if (_la==BY) {
				{
				State = 4540; Match(BY);
				State = 4541; Match(VALUE);
				}
			}

			State = 4544; expression_wrapper();
			State = 4546;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 4545; column_alias();
				}
			}

			{
			State = 4548; Match(COMMA);
			State = 4549; expression_wrapper();
			State = 4551;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,578,Context) ) {
			case 1:
				{
				State = 4550; column_alias();
				}
				break;
			}
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_attributes_clauseContext : ParserRuleContext {
		public ITerminalNode XMLATTRIBUTES() { return GetToken(plsqlParser.XMLATTRIBUTES, 0); }
		public Xml_multiuse_expression_elementContext[] xml_multiuse_expression_element() {
			return GetRuleContexts<Xml_multiuse_expression_elementContext>();
		}
		public Xml_multiuse_expression_elementContext xml_multiuse_expression_element(int i) {
			return GetRuleContext<Xml_multiuse_expression_elementContext>(i);
		}
		public ITerminalNode ENTITYESCAPING() { return GetToken(plsqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(plsqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode SCHEMACHECK() { return GetToken(plsqlParser.SCHEMACHECK, 0); }
		public ITerminalNode NOSCHEMACHECK() { return GetToken(plsqlParser.NOSCHEMACHECK, 0); }
		public Xml_attributes_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_attributes_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_attributes_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_attributes_clause(this);
		}
	}

	[RuleVersion(0)]
	public Xml_attributes_clauseContext xml_attributes_clause() {
		Xml_attributes_clauseContext _localctx = new Xml_attributes_clauseContext(Context, State);
		EnterRule(_localctx, 598, RULE_xml_attributes_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4553; Match(XMLATTRIBUTES);
			State = 4554; Match(LEFT_PAREN);
			State = 4556;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,579,Context) ) {
			case 1:
				{
				State = 4555;
				_la = TokenStream.La(1);
				if ( !(_la==ENTITYESCAPING || _la==NOENTITYESCAPING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			}
			State = 4559;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,580,Context) ) {
			case 1:
				{
				State = 4558;
				_la = TokenStream.La(1);
				if ( !(_la==NOSCHEMACHECK || _la==SCHEMACHECK) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			}
			State = 4561; xml_multiuse_expression_element();
			State = 4566;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4562; Match(COMMA);
				State = 4563; xml_multiuse_expression_element();
				}
				}
				State = 4568;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 4569; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_namespaces_clauseContext : ParserRuleContext {
		public ITerminalNode XMLNAMESPACES() { return GetToken(plsqlParser.XMLNAMESPACES, 0); }
		public Concatenation_wrapperContext[] concatenation_wrapper() {
			return GetRuleContexts<Concatenation_wrapperContext>();
		}
		public Concatenation_wrapperContext concatenation_wrapper(int i) {
			return GetRuleContext<Concatenation_wrapperContext>(i);
		}
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public Xml_general_default_partContext xml_general_default_part() {
			return GetRuleContext<Xml_general_default_partContext>(0);
		}
		public Xml_namespaces_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_namespaces_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_namespaces_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_namespaces_clause(this);
		}
	}

	[RuleVersion(0)]
	public Xml_namespaces_clauseContext xml_namespaces_clause() {
		Xml_namespaces_clauseContext _localctx = new Xml_namespaces_clauseContext(Context, State);
		EnterRule(_localctx, 600, RULE_xml_namespaces_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4571; Match(XMLNAMESPACES);
			State = 4572; Match(LEFT_PAREN);
			State = 4576;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,582,Context) ) {
			case 1:
				{
				State = 4573; concatenation_wrapper();
				State = 4574; column_alias();
				}
				break;
			}
			State = 4584;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4578; Match(COMMA);
				State = 4579; concatenation_wrapper();
				State = 4580; column_alias();
				}
				}
				State = 4586;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 4588;
			_la = TokenStream.La(1);
			if (_la==DEFAULT) {
				{
				State = 4587; xml_general_default_part();
				}
			}

			State = 4590; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_table_columnContext : ParserRuleContext {
		public Xml_column_nameContext xml_column_name() {
			return GetRuleContext<Xml_column_nameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(plsqlParser.ORDINALITY, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode PATH() { return GetToken(plsqlParser.PATH, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xml_general_default_partContext xml_general_default_part() {
			return GetRuleContext<Xml_general_default_partContext>(0);
		}
		public Xml_table_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_table_column; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_table_column(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_table_column(this);
		}
	}

	[RuleVersion(0)]
	public Xml_table_columnContext xml_table_column() {
		Xml_table_columnContext _localctx = new Xml_table_columnContext(Context, State);
		EnterRule(_localctx, 602, RULE_xml_table_column);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4592; xml_column_name();
			State = 4603;
			switch (TokenStream.La(1)) {
			case FOR:
				{
				State = 4593; Match(FOR);
				State = 4594; Match(ORDINALITY);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case REGULAR_ID:
				{
				State = 4595; type_spec();
				State = 4598;
				_la = TokenStream.La(1);
				if (_la==PATH) {
					{
					State = 4596; Match(PATH);
					State = 4597; concatenation_wrapper();
					}
				}

				State = 4601;
				_la = TokenStream.La(1);
				if (_la==DEFAULT) {
					{
					State = 4600; xml_general_default_part();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_general_default_partContext : ParserRuleContext {
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xml_general_default_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_general_default_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_general_default_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_general_default_part(this);
		}
	}

	[RuleVersion(0)]
	public Xml_general_default_partContext xml_general_default_part() {
		Xml_general_default_partContext _localctx = new Xml_general_default_partContext(Context, State);
		EnterRule(_localctx, 604, RULE_xml_general_default_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4605; Match(DEFAULT);
			State = 4606; concatenation_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_multiuse_expression_elementContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode EVALNAME() { return GetToken(plsqlParser.EVALNAME, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Xml_multiuse_expression_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_multiuse_expression_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_multiuse_expression_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_multiuse_expression_element(this);
		}
	}

	[RuleVersion(0)]
	public Xml_multiuse_expression_elementContext xml_multiuse_expression_element() {
		Xml_multiuse_expression_elementContext _localctx = new Xml_multiuse_expression_elementContext(Context, State);
		EnterRule(_localctx, 606, RULE_xml_multiuse_expression_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4608; expression();
			State = 4615;
			_la = TokenStream.La(1);
			if (_la==AS) {
				{
				State = 4609; Match(AS);
				State = 4613;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,588,Context) ) {
				case 1:
					{
					State = 4610; id_expression();
					}
					break;
				case 2:
					{
					State = 4611; Match(EVALNAME);
					State = 4612; concatenation();
					}
					break;
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlroot_param_version_partContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(plsqlParser.VERSION, 0); }
		public ITerminalNode NO() { return GetToken(plsqlParser.NO, 0); }
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Xmlroot_param_version_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlroot_param_version_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlroot_param_version_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlroot_param_version_part(this);
		}
	}

	[RuleVersion(0)]
	public Xmlroot_param_version_partContext xmlroot_param_version_part() {
		Xmlroot_param_version_partContext _localctx = new Xmlroot_param_version_partContext(Context, State);
		EnterRule(_localctx, 608, RULE_xmlroot_param_version_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4617; Match(VERSION);
			State = 4621;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,590,Context) ) {
			case 1:
				{
				State = 4618; Match(NO);
				State = 4619; Match(VALUE);
				}
				break;
			case 2:
				{
				State = 4620; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlroot_param_standalone_partContext : ParserRuleContext {
		public ITerminalNode STANDALONE() { return GetToken(plsqlParser.STANDALONE, 0); }
		public ITerminalNode YES() { return GetToken(plsqlParser.YES, 0); }
		public ITerminalNode NO() { return GetToken(plsqlParser.NO, 0); }
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public Xmlroot_param_standalone_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlroot_param_standalone_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlroot_param_standalone_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlroot_param_standalone_part(this);
		}
	}

	[RuleVersion(0)]
	public Xmlroot_param_standalone_partContext xmlroot_param_standalone_part() {
		Xmlroot_param_standalone_partContext _localctx = new Xmlroot_param_standalone_partContext(Context, State);
		EnterRule(_localctx, 610, RULE_xmlroot_param_standalone_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4623; Match(STANDALONE);
			State = 4629;
			switch (TokenStream.La(1)) {
			case YES:
				{
				State = 4624; Match(YES);
				}
				break;
			case NO:
				{
				State = 4625; Match(NO);
				State = 4627;
				_la = TokenStream.La(1);
				if (_la==VALUE) {
					{
					State = 4626; Match(VALUE);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_enconding_partContext : ParserRuleContext {
		public ITerminalNode ENCODING() { return GetToken(plsqlParser.ENCODING, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xmlserialize_param_enconding_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_enconding_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_enconding_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_enconding_part(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_enconding_partContext xmlserialize_param_enconding_part() {
		Xmlserialize_param_enconding_partContext _localctx = new Xmlserialize_param_enconding_partContext(Context, State);
		EnterRule(_localctx, 612, RULE_xmlserialize_param_enconding_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4631; Match(ENCODING);
			State = 4632; concatenation_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_version_partContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(plsqlParser.VERSION, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xmlserialize_param_version_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_version_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_version_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_version_part(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_version_partContext xmlserialize_param_version_part() {
		Xmlserialize_param_version_partContext _localctx = new Xmlserialize_param_version_partContext(Context, State);
		EnterRule(_localctx, 614, RULE_xmlserialize_param_version_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4634; Match(VERSION);
			State = 4635; concatenation_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_ident_partContext : ParserRuleContext {
		public ITerminalNode NO() { return GetToken(plsqlParser.NO, 0); }
		public ITerminalNode INDENT() { return GetToken(plsqlParser.INDENT, 0); }
		public ITerminalNode SIZE() { return GetToken(plsqlParser.SIZE, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xmlserialize_param_ident_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_ident_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_ident_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_ident_part(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_ident_partContext xmlserialize_param_ident_part() {
		Xmlserialize_param_ident_partContext _localctx = new Xmlserialize_param_ident_partContext(Context, State);
		EnterRule(_localctx, 616, RULE_xmlserialize_param_ident_part);
		int _la;
		try {
			State = 4645;
			switch (TokenStream.La(1)) {
			case NO:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4637; Match(NO);
				State = 4638; Match(INDENT);
				}
				break;
			case INDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4639; Match(INDENT);
				State = 4643;
				_la = TokenStream.La(1);
				if (_la==SIZE) {
					{
					State = 4640; Match(SIZE);
					State = 4641; Match(EQUALS_OP);
					State = 4642; concatenation_wrapper();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_plus_commandContext : ParserRuleContext {
		public Whenever_commandContext whenever_command() {
			return GetRuleContext<Whenever_commandContext>(0);
		}
		public Exit_commandContext exit_command() {
			return GetRuleContext<Exit_commandContext>(0);
		}
		public Prompt_commandContext prompt_command() {
			return GetRuleContext<Prompt_commandContext>(0);
		}
		public Set_commandContext set_command() {
			return GetRuleContext<Set_commandContext>(0);
		}
		public Show_errors_commandContext show_errors_command() {
			return GetRuleContext<Show_errors_commandContext>(0);
		}
		public Sql_plus_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_plus_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSql_plus_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSql_plus_command(this);
		}
	}

	[RuleVersion(0)]
	public Sql_plus_commandContext sql_plus_command() {
		Sql_plus_commandContext _localctx = new Sql_plus_commandContext(Context, State);
		EnterRule(_localctx, 618, RULE_sql_plus_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4653;
			switch (TokenStream.La(1)) {
			case SOLIDUS:
				{
				State = 4647; Match(SOLIDUS);
				}
				break;
			case WHENEVER:
				{
				State = 4648; whenever_command();
				}
				break;
			case EXIT:
				{
				State = 4649; exit_command();
				}
				break;
			case PROMPT:
				{
				State = 4650; prompt_command();
				}
				break;
			case SET:
				{
				State = 4651; set_command();
				}
				break;
			case SHOW:
				{
				State = 4652; show_errors_command();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 4656;
			_la = TokenStream.La(1);
			if (_la==SEMICOLON) {
				{
				State = 4655; Match(SEMICOLON);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Whenever_commandContext : ParserRuleContext {
		public ITerminalNode WHENEVER() { return GetToken(plsqlParser.WHENEVER, 0); }
		public ITerminalNode SQLERROR() { return GetToken(plsqlParser.SQLERROR, 0); }
		public ITerminalNode OSERROR() { return GetToken(plsqlParser.OSERROR, 0); }
		public ITerminalNode EXIT() { return GetToken(plsqlParser.EXIT, 0); }
		public ITerminalNode CONTINUE() { return GetToken(plsqlParser.CONTINUE, 0); }
		public ITerminalNode SUCCESS() { return GetToken(plsqlParser.SUCCESS, 0); }
		public ITerminalNode FAILURE() { return GetToken(plsqlParser.FAILURE, 0); }
		public ITerminalNode WARNING() { return GetToken(plsqlParser.WARNING, 0); }
		public ITerminalNode COMMIT() { return GetToken(plsqlParser.COMMIT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(plsqlParser.ROLLBACK, 0); }
		public ITerminalNode NONE() { return GetToken(plsqlParser.NONE, 0); }
		public Whenever_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whenever_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWhenever_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWhenever_command(this);
		}
	}

	[RuleVersion(0)]
	public Whenever_commandContext whenever_command() {
		Whenever_commandContext _localctx = new Whenever_commandContext(Context, State);
		EnterRule(_localctx, 620, RULE_whenever_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4658; Match(WHENEVER);
			State = 4659;
			_la = TokenStream.La(1);
			if ( !(_la==OSERROR || _la==SQLERROR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 4665;
			switch (TokenStream.La(1)) {
			case EXIT:
				{
				State = 4660; Match(EXIT);
				State = 4661;
				_la = TokenStream.La(1);
				if ( !(_la==FAILURE || _la==SUCCESS || _la==WARNING) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 4662;
				_la = TokenStream.La(1);
				if ( !(_la==COMMIT || _la==ROLLBACK) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			case CONTINUE:
				{
				State = 4663; Match(CONTINUE);
				State = 4664;
				_la = TokenStream.La(1);
				if ( !(_la==COMMIT || _la==NONE || _la==ROLLBACK) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_commandContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public Regular_idContext[] regular_id() {
			return GetRuleContexts<Regular_idContext>();
		}
		public Regular_idContext regular_id(int i) {
			return GetRuleContext<Regular_idContext>(i);
		}
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public ITerminalNode ON() { return GetToken(plsqlParser.ON, 0); }
		public ITerminalNode OFF() { return GetToken(plsqlParser.OFF, 0); }
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public Set_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSet_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSet_command(this);
		}
	}

	[RuleVersion(0)]
	public Set_commandContext set_command() {
		Set_commandContext _localctx = new Set_commandContext(Context, State);
		EnterRule(_localctx, 622, RULE_set_command);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4667; Match(SET);
			State = 4668; regular_id();
			State = 4674;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,598,Context) ) {
			case 1:
				{
				State = 4669; Match(CHAR_STRING);
				}
				break;
			case 2:
				{
				State = 4670; Match(ON);
				}
				break;
			case 3:
				{
				State = 4671; Match(OFF);
				}
				break;
			case 4:
				{
				State = 4672; numeric();
				}
				break;
			case 5:
				{
				State = 4673; regular_id();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exit_commandContext : ParserRuleContext {
		public ITerminalNode EXIT() { return GetToken(plsqlParser.EXIT, 0); }
		public Exit_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exit_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterExit_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitExit_command(this);
		}
	}

	[RuleVersion(0)]
	public Exit_commandContext exit_command() {
		Exit_commandContext _localctx = new Exit_commandContext(Context, State);
		EnterRule(_localctx, 624, RULE_exit_command);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4676; Match(EXIT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Prompt_commandContext : ParserRuleContext {
		public ITerminalNode PROMPT() { return GetToken(plsqlParser.PROMPT, 0); }
		public Prompt_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_prompt_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPrompt_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPrompt_command(this);
		}
	}

	[RuleVersion(0)]
	public Prompt_commandContext prompt_command() {
		Prompt_commandContext _localctx = new Prompt_commandContext(Context, State);
		EnterRule(_localctx, 626, RULE_prompt_command);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4678; Match(PROMPT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Show_errors_commandContext : ParserRuleContext {
		public ITerminalNode SHOW() { return GetToken(plsqlParser.SHOW, 0); }
		public ITerminalNode ERR() { return GetToken(plsqlParser.ERR, 0); }
		public ITerminalNode ERRORS() { return GetToken(plsqlParser.ERRORS, 0); }
		public Show_errors_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_show_errors_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterShow_errors_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitShow_errors_command(this);
		}
	}

	[RuleVersion(0)]
	public Show_errors_commandContext show_errors_command() {
		Show_errors_commandContext _localctx = new Show_errors_commandContext(Context, State);
		EnterRule(_localctx, 628, RULE_show_errors_command);
		try {
			State = 4684;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,599,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4680; Match(SHOW);
				State = 4681; Match(ERR);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4682; Match(SHOW);
				State = 4683; Match(ERRORS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_extension_clauseContext : ParserRuleContext {
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode SUBPARTITION() { return GetToken(plsqlParser.SUBPARTITION, 0); }
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ITerminalNode FOR() { return GetToken(plsqlParser.FOR, 0); }
		public Partition_extension_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_extension_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPartition_extension_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPartition_extension_clause(this);
		}
	}

	[RuleVersion(0)]
	public Partition_extension_clauseContext partition_extension_clause() {
		Partition_extension_clauseContext _localctx = new Partition_extension_clauseContext(Context, State);
		EnterRule(_localctx, 630, RULE_partition_extension_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4686;
			_la = TokenStream.La(1);
			if ( !(_la==PARTITION || _la==SUBPARTITION) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 4688;
			_la = TokenStream.La(1);
			if (_la==FOR) {
				{
				State = 4687; Match(FOR);
				}
			}

			State = 4690; expression_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_aliasContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Alias_quoted_stringContext alias_quoted_string() {
			return GetRuleContext<Alias_quoted_stringContext>(0);
		}
		public ITerminalNode AS() { return GetToken(plsqlParser.AS, 0); }
		public Column_aliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_alias; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterColumn_alias(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitColumn_alias(this);
		}
	}

	[RuleVersion(0)]
	public Column_aliasContext column_alias() {
		Column_aliasContext _localctx = new Column_aliasContext(Context, State);
		EnterRule(_localctx, 632, RULE_column_alias);
		int _la;
		try {
			State = 4700;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,603,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4693;
				_la = TokenStream.La(1);
				if (_la==AS) {
					{
					State = 4692; Match(AS);
					}
				}

				State = 4697;
				switch (TokenStream.La(1)) {
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 4695; id();
					}
					break;
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 4696; alias_quoted_string();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4699; Match(AS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_aliasContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Alias_quoted_stringContext alias_quoted_string() {
			return GetRuleContext<Alias_quoted_stringContext>(0);
		}
		public Table_aliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_alias; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_alias(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_alias(this);
		}
	}

	[RuleVersion(0)]
	public Table_aliasContext table_alias() {
		Table_aliasContext _localctx = new Table_aliasContext(Context, State);
		EnterRule(_localctx, 634, RULE_table_alias);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4704;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4702; id();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				{
				State = 4703; alias_quoted_string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alias_quoted_stringContext : ParserRuleContext {
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public Alias_quoted_stringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alias_quoted_string; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAlias_quoted_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAlias_quoted_string(this);
		}
	}

	[RuleVersion(0)]
	public Alias_quoted_stringContext alias_quoted_string() {
		Alias_quoted_stringContext _localctx = new Alias_quoted_stringContext(Context, State);
		EnterRule(_localctx, 636, RULE_alias_quoted_string);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4706; quoted_string();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Where_clauseContext : ParserRuleContext {
		public ITerminalNode WHERE() { return GetToken(plsqlParser.WHERE, 0); }
		public Current_of_clauseContext current_of_clause() {
			return GetRuleContext<Current_of_clauseContext>(0);
		}
		public Condition_wrapperContext condition_wrapper() {
			return GetRuleContext<Condition_wrapperContext>(0);
		}
		public Where_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_where_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterWhere_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitWhere_clause(this);
		}
	}

	[RuleVersion(0)]
	public Where_clauseContext where_clause() {
		Where_clauseContext _localctx = new Where_clauseContext(Context, State);
		EnterRule(_localctx, 638, RULE_where_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4708; Match(WHERE);
			State = 4711;
			switch (TokenStream.La(1)) {
			case CURRENT:
				{
				State = 4709; current_of_clause();
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ANALYZE:
			case ANY:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NOT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4710; condition_wrapper();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Current_of_clauseContext : ParserRuleContext {
		public ITerminalNode CURRENT() { return GetToken(plsqlParser.CURRENT, 0); }
		public ITerminalNode OF() { return GetToken(plsqlParser.OF, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Current_of_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_current_of_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCurrent_of_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCurrent_of_clause(this);
		}
	}

	[RuleVersion(0)]
	public Current_of_clauseContext current_of_clause() {
		Current_of_clauseContext _localctx = new Current_of_clauseContext(Context, State);
		EnterRule(_localctx, 640, RULE_current_of_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4713; Match(CURRENT);
			State = 4714; Match(OF);
			State = 4715; cursor_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Into_clauseContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(plsqlParser.INTO, 0); }
		public Variable_nameContext[] variable_name() {
			return GetRuleContexts<Variable_nameContext>();
		}
		public Variable_nameContext variable_name(int i) {
			return GetRuleContext<Variable_nameContext>(i);
		}
		public ITerminalNode BULK() { return GetToken(plsqlParser.BULK, 0); }
		public ITerminalNode COLLECT() { return GetToken(plsqlParser.COLLECT, 0); }
		public Into_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_into_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterInto_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitInto_clause(this);
		}
	}

	[RuleVersion(0)]
	public Into_clauseContext into_clause() {
		Into_clauseContext _localctx = new Into_clauseContext(Context, State);
		EnterRule(_localctx, 642, RULE_into_clause);
		int _la;
		try {
			State = 4737;
			switch (TokenStream.La(1)) {
			case INTO:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4717; Match(INTO);
				State = 4718; variable_name();
				State = 4723;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4719; Match(COMMA);
					State = 4720; variable_name();
					}
					}
					State = 4725;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			case BULK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4726; Match(BULK);
				State = 4727; Match(COLLECT);
				State = 4728; Match(INTO);
				State = 4729; variable_name();
				State = 4734;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4730; Match(COMMA);
					State = 4731; variable_name();
					}
					}
					State = 4736;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_column_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public Xml_column_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_column_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterXml_column_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitXml_column_name(this);
		}
	}

	[RuleVersion(0)]
	public Xml_column_nameContext xml_column_name() {
		Xml_column_nameContext _localctx = new Xml_column_nameContext(Context, State);
		EnterRule(_localctx, 644, RULE_xml_column_name);
		try {
			State = 4741;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4739; id();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4740; quoted_string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cost_class_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Cost_class_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cost_class_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCost_class_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCost_class_name(this);
		}
	}

	[RuleVersion(0)]
	public Cost_class_nameContext cost_class_name() {
		Cost_class_nameContext _localctx = new Cost_class_nameContext(Context, State);
		EnterRule(_localctx, 646, RULE_cost_class_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4743; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Attribute_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAttribute_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAttribute_name(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_nameContext attribute_name() {
		Attribute_nameContext _localctx = new Attribute_nameContext(Context, State);
		EnterRule(_localctx, 648, RULE_attribute_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4745; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Savepoint_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Savepoint_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepoint_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSavepoint_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSavepoint_name(this);
		}
	}

	[RuleVersion(0)]
	public Savepoint_nameContext savepoint_name() {
		Savepoint_nameContext _localctx = new Savepoint_nameContext(Context, State);
		EnterRule(_localctx, 650, RULE_savepoint_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4747; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollback_segment_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Rollback_segment_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollback_segment_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRollback_segment_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRollback_segment_name(this);
		}
	}

	[RuleVersion(0)]
	public Rollback_segment_nameContext rollback_segment_name() {
		Rollback_segment_nameContext _localctx = new Rollback_segment_nameContext(Context, State);
		EnterRule(_localctx, 652, RULE_rollback_segment_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4749; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_var_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Table_var_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_var_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_var_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_var_name(this);
		}
	}

	[RuleVersion(0)]
	public Table_var_nameContext table_var_name() {
		Table_var_nameContext _localctx = new Table_var_nameContext(Context, State);
		EnterRule(_localctx, 654, RULE_table_var_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4751; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Schema_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Schema_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_schema_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSchema_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSchema_name(this);
		}
	}

	[RuleVersion(0)]
	public Schema_nameContext schema_name() {
		Schema_nameContext _localctx = new Schema_nameContext(Context, State);
		EnterRule(_localctx, 656, RULE_schema_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4753; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Routine_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Routine_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routine_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRoutine_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRoutine_name(this);
		}
	}

	[RuleVersion(0)]
	public Routine_nameContext routine_name() {
		Routine_nameContext _localctx = new Routine_nameContext(Context, State);
		EnterRule(_localctx, 658, RULE_routine_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4755; id();
			State = 4760;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4756; Match(PERIOD);
				State = 4757; id_expression();
				}
				}
				State = 4762;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 4765;
			_la = TokenStream.La(1);
			if (_la==AT_SIGN) {
				{
				State = 4763; Match(AT_SIGN);
				State = 4764; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Package_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPackage_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPackage_name(this);
		}
	}

	[RuleVersion(0)]
	public Package_nameContext package_name() {
		Package_nameContext _localctx = new Package_nameContext(Context, State);
		EnterRule(_localctx, 660, RULE_package_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4767; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Implementation_type_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Implementation_type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_implementation_type_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterImplementation_type_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitImplementation_type_name(this);
		}
	}

	[RuleVersion(0)]
	public Implementation_type_nameContext implementation_type_name() {
		Implementation_type_nameContext _localctx = new Implementation_type_nameContext(Context, State);
		EnterRule(_localctx, 662, RULE_implementation_type_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4769; id();
			State = 4772;
			_la = TokenStream.La(1);
			if (_la==PERIOD) {
				{
				State = 4770; Match(PERIOD);
				State = 4771; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Parameter_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterParameter_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitParameter_name(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_nameContext parameter_name() {
		Parameter_nameContext _localctx = new Parameter_nameContext(Context, State);
		EnterRule(_localctx, 664, RULE_parameter_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4774; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_model_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Reference_model_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_model_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterReference_model_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitReference_model_name(this);
		}
	}

	[RuleVersion(0)]
	public Reference_model_nameContext reference_model_name() {
		Reference_model_nameContext _localctx = new Reference_model_nameContext(Context, State);
		EnterRule(_localctx, 666, RULE_reference_model_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4776; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Main_model_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Main_model_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main_model_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterMain_model_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitMain_model_name(this);
		}
	}

	[RuleVersion(0)]
	public Main_model_nameContext main_model_name() {
		Main_model_nameContext _localctx = new Main_model_nameContext(Context, State);
		EnterRule(_localctx, 668, RULE_main_model_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4778; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Aggregate_function_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Aggregate_function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggregate_function_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterAggregate_function_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitAggregate_function_name(this);
		}
	}

	[RuleVersion(0)]
	public Aggregate_function_nameContext aggregate_function_name() {
		Aggregate_function_nameContext _localctx = new Aggregate_function_nameContext(Context, State);
		EnterRule(_localctx, 670, RULE_aggregate_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4780; id();
			State = 4785;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4781; Match(PERIOD);
				State = 4782; id_expression();
				}
				}
				State = 4787;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Query_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuery_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuery_name(this);
		}
	}

	[RuleVersion(0)]
	public Query_nameContext query_name() {
		Query_nameContext _localctx = new Query_nameContext(Context, State);
		EnterRule(_localctx, 672, RULE_query_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4788; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constraint_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Constraint_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraint_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConstraint_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConstraint_name(this);
		}
	}

	[RuleVersion(0)]
	public Constraint_nameContext constraint_name() {
		Constraint_nameContext _localctx = new Constraint_nameContext(Context, State);
		EnterRule(_localctx, 674, RULE_constraint_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4790; id();
			State = 4795;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4791; Match(PERIOD);
				State = 4792; id_expression();
				}
				}
				State = 4797;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 4800;
			_la = TokenStream.La(1);
			if (_la==AT_SIGN) {
				{
				State = 4798; Match(AT_SIGN);
				State = 4799; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Label_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Label_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLabel_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLabel_name(this);
		}
	}

	[RuleVersion(0)]
	public Label_nameContext label_name() {
		Label_nameContext _localctx = new Label_nameContext(Context, State);
		EnterRule(_localctx, 676, RULE_label_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4802; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_name(this);
		}
	}

	[RuleVersion(0)]
	public Type_nameContext type_name() {
		Type_nameContext _localctx = new Type_nameContext(Context, State);
		EnterRule(_localctx, 678, RULE_type_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4804; id_expression();
			State = 4809;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4805; Match(PERIOD);
				State = 4806; id_expression();
				}
				}
				State = 4811;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Sequence_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterSequence_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitSequence_name(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_nameContext sequence_name() {
		Sequence_nameContext _localctx = new Sequence_nameContext(Context, State);
		EnterRule(_localctx, 680, RULE_sequence_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4812; id_expression();
			State = 4817;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4813; Match(PERIOD);
				State = 4814; id_expression();
				}
				}
				State = 4819;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Exception_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterException_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitException_name(this);
		}
	}

	[RuleVersion(0)]
	public Exception_nameContext exception_name() {
		Exception_nameContext _localctx = new Exception_nameContext(Context, State);
		EnterRule(_localctx, 682, RULE_exception_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4820; id();
			State = 4825;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4821; Match(PERIOD);
				State = 4822; id_expression();
				}
				}
				State = 4827;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_name(this);
		}
	}

	[RuleVersion(0)]
	public Function_nameContext function_name() {
		Function_nameContext _localctx = new Function_nameContext(Context, State);
		EnterRule(_localctx, 684, RULE_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4828; id();
			State = 4831;
			_la = TokenStream.La(1);
			if (_la==PERIOD) {
				{
				State = 4829; Match(PERIOD);
				State = 4830; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Procedure_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterProcedure_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitProcedure_name(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_nameContext procedure_name() {
		Procedure_nameContext _localctx = new Procedure_nameContext(Context, State);
		EnterRule(_localctx, 686, RULE_procedure_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4833; id();
			State = 4836;
			_la = TokenStream.La(1);
			if (_la==PERIOD) {
				{
				State = 4834; Match(PERIOD);
				State = 4835; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Trigger_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTrigger_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTrigger_name(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_nameContext trigger_name() {
		Trigger_nameContext _localctx = new Trigger_nameContext(Context, State);
		EnterRule(_localctx, 688, RULE_trigger_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4838; id();
			State = 4841;
			_la = TokenStream.La(1);
			if (_la==PERIOD) {
				{
				State = 4839; Match(PERIOD);
				State = 4840; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode INTRODUCER() { return GetToken(plsqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Variable_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterVariable_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitVariable_name(this);
		}
	}

	[RuleVersion(0)]
	public Variable_nameContext variable_name() {
		Variable_nameContext _localctx = new Variable_nameContext(Context, State);
		EnterRule(_localctx, 690, RULE_variable_name);
		int _la;
		try {
			State = 4853;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4845;
				_la = TokenStream.La(1);
				if (_la==INTRODUCER) {
					{
					State = 4843; Match(INTRODUCER);
					State = 4844; char_set_name();
					}
				}

				State = 4847; id_expression();
				State = 4850;
				_la = TokenStream.La(1);
				if (_la==PERIOD) {
					{
					State = 4848; Match(PERIOD);
					State = 4849; id_expression();
					}
				}

				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4852; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Index_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterIndex_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitIndex_name(this);
		}
	}

	[RuleVersion(0)]
	public Index_nameContext index_name() {
		Index_nameContext _localctx = new Index_nameContext(Context, State);
		EnterRule(_localctx, 692, RULE_index_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4855; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Cursor_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCursor_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCursor_name(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_nameContext cursor_name() {
		Cursor_nameContext _localctx = new Cursor_nameContext(Context, State);
		EnterRule(_localctx, 694, RULE_cursor_name);
		try {
			State = 4859;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4857; id();
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4858; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Record_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRecord_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRecord_name(this);
		}
	}

	[RuleVersion(0)]
	public Record_nameContext record_name() {
		Record_nameContext _localctx = new Record_nameContext(Context, State);
		EnterRule(_localctx, 696, RULE_record_name);
		try {
			State = 4863;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4861; id();
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4862; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collection_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Collection_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collection_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterCollection_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitCollection_name(this);
		}
	}

	[RuleVersion(0)]
	public Collection_nameContext collection_name() {
		Collection_nameContext _localctx = new Collection_nameContext(Context, State);
		EnterRule(_localctx, 698, RULE_collection_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4865; id();
			State = 4868;
			_la = TokenStream.La(1);
			if (_la==PERIOD) {
				{
				State = 4866; Match(PERIOD);
				State = 4867; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Link_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Link_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_link_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLink_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLink_name(this);
		}
	}

	[RuleVersion(0)]
	public Link_nameContext link_name() {
		Link_nameContext _localctx = new Link_nameContext(Context, State);
		EnterRule(_localctx, 700, RULE_link_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4870; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Column_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterColumn_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitColumn_name(this);
		}
	}

	[RuleVersion(0)]
	public Column_nameContext column_name() {
		Column_nameContext _localctx = new Column_nameContext(Context, State);
		EnterRule(_localctx, 702, RULE_column_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4872; id();
			State = 4877;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4873; Match(PERIOD);
				State = 4874; id_expression();
				}
				}
				State = 4879;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tableview_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Partition_extension_clauseContext partition_extension_clause() {
			return GetRuleContext<Partition_extension_clauseContext>(0);
		}
		public Tableview_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableview_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTableview_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTableview_name(this);
		}
	}

	[RuleVersion(0)]
	public Tableview_nameContext tableview_name() {
		Tableview_nameContext _localctx = new Tableview_nameContext(Context, State);
		EnterRule(_localctx, 704, RULE_tableview_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4880; id();
			State = 4883;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,629,Context) ) {
			case 1:
				{
				State = 4881; Match(PERIOD);
				State = 4882; id_expression();
				}
				break;
			}
			State = 4888;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,630,Context) ) {
			case 1:
				{
				State = 4885; Match(AT_SIGN);
				State = 4886; link_name();
				}
				break;
			case 2:
				{
				State = 4887; partition_extension_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Char_set_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Char_set_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_char_set_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterChar_set_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitChar_set_name(this);
		}
	}

	[RuleVersion(0)]
	public Char_set_nameContext char_set_name() {
		Char_set_nameContext _localctx = new Char_set_nameContext(Context, State);
		EnterRule(_localctx, 706, RULE_char_set_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4890; id_expression();
			State = 4895;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4891; Match(PERIOD);
				State = 4892; id_expression();
				}
				}
				State = 4897;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Keep_clauseContext : ParserRuleContext {
		public ITerminalNode KEEP() { return GetToken(plsqlParser.KEEP, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(plsqlParser.DENSE_RANK, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode FIRST() { return GetToken(plsqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(plsqlParser.LAST, 0); }
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Keep_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keep_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterKeep_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitKeep_clause(this);
		}
	}

	[RuleVersion(0)]
	public Keep_clauseContext keep_clause() {
		Keep_clauseContext _localctx = new Keep_clauseContext(Context, State);
		EnterRule(_localctx, 708, RULE_keep_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4898; Match(KEEP);
			State = 4899; Match(LEFT_PAREN);
			State = 4900; Match(DENSE_RANK);
			State = 4901;
			_la = TokenStream.La(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 4902; order_by_clause();
			State = 4903; Match(RIGHT_PAREN);
			State = 4905;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,632,Context) ) {
			case 1:
				{
				State = 4904; over_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argumentContext : ParserRuleContext {
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public Function_argumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument(this);
		}
	}

	[RuleVersion(0)]
	public Function_argumentContext function_argument() {
		Function_argumentContext _localctx = new Function_argumentContext(Context, State);
		EnterRule(_localctx, 710, RULE_function_argument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4907; Match(LEFT_PAREN);
			State = 4909;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENTITYESCAPING - 64)) | (1L << (ERR - 64)) | (1L << (ERRORS - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVALNAME - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERVAL - 128)) | (1L << (INVALIDATE - 128)) | (1L << (ISOLATION - 128)) | (1L << (ITERATE - 128)) | (1L << (JAVA - 128)) | (1L << (JOIN - 128)) | (1L << (KEEP - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NONE - 192)) | (1L << (NOSCHEMACHECK - 192)) | (1L << (NOT - 192)) | (1L << (NULL - 192)) | (1L << (NULLS - 192)) | (1L << (NUMBER - 192)) | (1L << (NUMERIC - 192)) | (1L << (NVARCHAR2 - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (OBJECT - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)) | (1L << (RELIES_ON - 256)) | (1L << (RENAME - 256)) | (1L << (REPLACE - 256)) | (1L << (RESPECT - 256)) | (1L << (RESTRICT_REFERENCES - 256)) | (1L << (RESULT - 256)) | (1L << (RESULT_CACHE - 256)) | (1L << (RETURN - 256)) | (1L << (RETURNING - 256)) | (1L << (REUSE - 256)) | (1L << (REVERSE - 256)) | (1L << (RIGHT - 256)) | (1L << (ROLLBACK - 256)) | (1L << (ROLLUP - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (STANDALONE - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)) | (1L << (SUBMULTISET - 320)) | (1L << (SUBPARTITION - 320)) | (1L << (SUBSTITUTABLE - 320)) | (1L << (SUBTYPE - 320)) | (1L << (SUCCESS - 320)) | (1L << (SUSPEND - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_UNCONSTRAINED - 320)) | (1L << (TIMEZONE_ABBR - 320)) | (1L << (TIMEZONE_HOUR - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHILE - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)) | (1L << (XML - 384)) | (1L << (XMLAGG - 384)) | (1L << (XMLATTRIBUTES - 384)) | (1L << (XMLCAST - 384)) | (1L << (XMLCOLATTVAL - 384)) | (1L << (XMLELEMENT - 384)) | (1L << (XMLEXISTS - 384)) | (1L << (XMLFOREST - 384)) | (1L << (XMLNAMESPACES - 384)) | (1L << (XMLPARSE - 384)) | (1L << (XMLPI - 384)) | (1L << (XMLQUERY - 384)) | (1L << (XMLROOT - 384)) | (1L << (XMLSERIALIZE - 384)) | (1L << (XMLTABLE - 384)) | (1L << (YEAR - 384)) | (1L << (YES - 384)) | (1L << (YMINTERVAL_UNCONSTRAINED - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)) | (1L << (PLUS_SIGN - 448)) | (1L << (MINUS_SIGN - 448)) | (1L << (BINDVAR - 448)) | (1L << (COLON - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 4908; argument();
				}
			}

			State = 4915;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4911; Match(COMMA);
				State = 4912; argument();
				}
				}
				State = 4917;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 4918; Match(RIGHT_PAREN);
			State = 4920;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,635,Context) ) {
			case 1:
				{
				State = 4919; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argument_analyticContext : ParserRuleContext {
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public Respect_or_ignore_nullsContext[] respect_or_ignore_nulls() {
			return GetRuleContexts<Respect_or_ignore_nullsContext>();
		}
		public Respect_or_ignore_nullsContext respect_or_ignore_nulls(int i) {
			return GetRuleContext<Respect_or_ignore_nullsContext>(i);
		}
		public Function_argument_analyticContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument_analytic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument_analytic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument_analytic(this);
		}
	}

	[RuleVersion(0)]
	public Function_argument_analyticContext function_argument_analytic() {
		Function_argument_analyticContext _localctx = new Function_argument_analyticContext(Context, State);
		EnterRule(_localctx, 712, RULE_function_argument_analytic);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4922; Match(LEFT_PAREN);
			State = 4927;
			_la = TokenStream.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ANALYZE) | (1L << ANY) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)) | (1L << (ENTITYESCAPING - 64)) | (1L << (ERR - 64)) | (1L << (ERRORS - 64)) | (1L << (ESCAPE - 64)) | (1L << (EVALNAME - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERVAL - 128)) | (1L << (INVALIDATE - 128)) | (1L << (ISOLATION - 128)) | (1L << (ITERATE - 128)) | (1L << (JAVA - 128)) | (1L << (JOIN - 128)) | (1L << (KEEP - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NONE - 192)) | (1L << (NOSCHEMACHECK - 192)) | (1L << (NOT - 192)) | (1L << (NULL - 192)) | (1L << (NULLS - 192)) | (1L << (NUMBER - 192)) | (1L << (NUMERIC - 192)) | (1L << (NVARCHAR2 - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (OBJECT - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)) | (1L << (RELIES_ON - 256)) | (1L << (RENAME - 256)) | (1L << (REPLACE - 256)) | (1L << (RESPECT - 256)) | (1L << (RESTRICT_REFERENCES - 256)) | (1L << (RESULT - 256)) | (1L << (RESULT_CACHE - 256)) | (1L << (RETURN - 256)) | (1L << (RETURNING - 256)) | (1L << (REUSE - 256)) | (1L << (REVERSE - 256)) | (1L << (RIGHT - 256)) | (1L << (ROLLBACK - 256)) | (1L << (ROLLUP - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (STANDALONE - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)) | (1L << (SUBMULTISET - 320)) | (1L << (SUBPARTITION - 320)) | (1L << (SUBSTITUTABLE - 320)) | (1L << (SUBTYPE - 320)) | (1L << (SUCCESS - 320)) | (1L << (SUSPEND - 320)) | (1L << (TIME - 320)) | (1L << (TIMESTAMP - 320)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 320)) | (1L << (TIMESTAMP_UNCONSTRAINED - 320)) | (1L << (TIMEZONE_ABBR - 320)) | (1L << (TIMEZONE_HOUR - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHILE - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)) | (1L << (XML - 384)) | (1L << (XMLAGG - 384)) | (1L << (XMLATTRIBUTES - 384)) | (1L << (XMLCAST - 384)) | (1L << (XMLCOLATTVAL - 384)) | (1L << (XMLELEMENT - 384)) | (1L << (XMLEXISTS - 384)) | (1L << (XMLFOREST - 384)) | (1L << (XMLNAMESPACES - 384)) | (1L << (XMLPARSE - 384)) | (1L << (XMLPI - 384)) | (1L << (XMLQUERY - 384)) | (1L << (XMLROOT - 384)) | (1L << (XMLSERIALIZE - 384)) | (1L << (XMLTABLE - 384)) | (1L << (YEAR - 384)) | (1L << (YES - 384)) | (1L << (YMINTERVAL_UNCONSTRAINED - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)) | (1L << (PLUS_SIGN - 448)) | (1L << (MINUS_SIGN - 448)) | (1L << (BINDVAR - 448)) | (1L << (COLON - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 4923; argument();
				State = 4925;
				_la = TokenStream.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 4924; respect_or_ignore_nulls();
					}
				}

				}
			}

			State = 4936;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4929; Match(COMMA);
				State = 4930; argument();
				State = 4932;
				_la = TokenStream.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 4931; respect_or_ignore_nulls();
					}
				}

				}
				}
				State = 4938;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 4939; Match(RIGHT_PAREN);
			State = 4941;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,640,Context) ) {
			case 1:
				{
				State = 4940; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argument_modelingContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode USING() { return GetToken(plsqlParser.USING, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public NumericContext[] numeric() {
			return GetRuleContexts<NumericContext>();
		}
		public NumericContext numeric(int i) {
			return GetRuleContext<NumericContext>(i);
		}
		public ITerminalNode[] NULL() { return GetTokens(plsqlParser.NULL); }
		public ITerminalNode NULL(int i) {
			return GetToken(plsqlParser.NULL, i);
		}
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public Function_argument_modelingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument_modeling; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument_modeling(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument_modeling(this);
		}
	}

	[RuleVersion(0)]
	public Function_argument_modelingContext function_argument_modeling() {
		Function_argument_modelingContext _localctx = new Function_argument_modelingContext(Context, State);
		EnterRule(_localctx, 714, RULE_function_argument_modeling);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4943; Match(LEFT_PAREN);
			State = 4944; column_name();
			State = 4957;
			_la = TokenStream.La(1);
			if (_la==COMMA) {
				{
				State = 4945; Match(COMMA);
				State = 4948;
				switch (TokenStream.La(1)) {
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
					{
					State = 4946; numeric();
					}
					break;
				case NULL:
					{
					State = 4947; Match(NULL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4955;
				_la = TokenStream.La(1);
				if (_la==COMMA) {
					{
					State = 4950; Match(COMMA);
					State = 4953;
					switch (TokenStream.La(1)) {
					case UNSIGNED_INTEGER:
					case APPROXIMATE_NUM_LIT:
						{
						State = 4951; numeric();
						}
						break;
					case NULL:
						{
						State = 4952; Match(NULL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				}
			}

			State = 4959; Match(USING);
			State = 4979;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,648,Context) ) {
			case 1:
				{
				State = 4960; tableview_name();
				State = 4961; Match(PERIOD);
				State = 4962; Match(ASTERISK);
				}
				break;
			case 2:
				{
				State = 4964; Match(ASTERISK);
				}
				break;
			case 3:
				{
				State = 4965; expression();
				State = 4967;
				_la = TokenStream.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 4966; column_alias();
					}
				}

				State = 4976;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4969; Match(COMMA);
					State = 4970; expression();
					State = 4972;
					_la = TokenStream.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << AS) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)) | (1L << (NATIONAL_CHAR_STRING_LIT - 451)) | (1L << (CHAR_STRING - 451)) | (1L << (DELIMITED_ID - 451)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 4971; column_alias();
						}
					}

					}
					}
					State = 4978;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			}
			State = 4981; Match(RIGHT_PAREN);
			State = 4983;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,649,Context) ) {
			case 1:
				{
				State = 4982; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Respect_or_ignore_nullsContext : ParserRuleContext {
		public ITerminalNode NULLS() { return GetToken(plsqlParser.NULLS, 0); }
		public ITerminalNode RESPECT() { return GetToken(plsqlParser.RESPECT, 0); }
		public ITerminalNode IGNORE() { return GetToken(plsqlParser.IGNORE, 0); }
		public Respect_or_ignore_nullsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_respect_or_ignore_nulls; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRespect_or_ignore_nulls(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRespect_or_ignore_nulls(this);
		}
	}

	[RuleVersion(0)]
	public Respect_or_ignore_nullsContext respect_or_ignore_nulls() {
		Respect_or_ignore_nullsContext _localctx = new Respect_or_ignore_nullsContext(Context, State);
		EnterRule(_localctx, 716, RULE_respect_or_ignore_nulls);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4985;
			_la = TokenStream.La(1);
			if ( !(_la==IGNORE || _la==RESPECT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			State = 4986; Match(NULLS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 718, RULE_argument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4992;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,650,Context) ) {
			case 1:
				{
				State = 4988; id();
				State = 4989; Match(EQUALS_OP);
				State = 4990; Match(GREATER_THAN_OP);
				}
				break;
			}
			State = 4994; expression_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_specContext : ParserRuleContext {
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode REF() { return GetToken(plsqlParser.REF, 0); }
		public ITerminalNode PERCENT_ROWTYPE() { return GetToken(plsqlParser.PERCENT_ROWTYPE, 0); }
		public ITerminalNode PERCENT_TYPE() { return GetToken(plsqlParser.PERCENT_TYPE, 0); }
		public Type_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterType_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitType_spec(this);
		}
	}

	[RuleVersion(0)]
	public Type_specContext type_spec() {
		Type_specContext _localctx = new Type_specContext(Context, State);
		EnterRule(_localctx, 720, RULE_type_spec);
		int _la;
		try {
			State = 5004;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,653,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4996; datatype();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4998;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,651,Context) ) {
				case 1:
					{
					State = 4997; Match(REF);
					}
					break;
				}
				State = 5000; type_name();
				State = 5002;
				_la = TokenStream.La(1);
				if (_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) {
					{
					State = 5001;
					_la = TokenStream.La(1);
					if ( !(_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
					    Consume();
					}
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatatypeContext : ParserRuleContext {
		public Native_datatype_elementContext native_datatype_element() {
			return GetRuleContext<Native_datatype_elementContext>(0);
		}
		public Precision_partContext precision_part() {
			return GetRuleContext<Precision_partContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(plsqlParser.WITH, 0); }
		public ITerminalNode TIME() { return GetToken(plsqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(plsqlParser.ZONE, 0); }
		public ITerminalNode LOCAL() { return GetToken(plsqlParser.LOCAL, 0); }
		public ITerminalNode INTERVAL() { return GetToken(plsqlParser.INTERVAL, 0); }
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode YEAR() { return GetToken(plsqlParser.YEAR, 0); }
		public ITerminalNode DAY() { return GetToken(plsqlParser.DAY, 0); }
		public ITerminalNode MONTH() { return GetToken(plsqlParser.MONTH, 0); }
		public ITerminalNode SECOND() { return GetToken(plsqlParser.SECOND, 0); }
		public Expression_wrapperContext[] expression_wrapper() {
			return GetRuleContexts<Expression_wrapperContext>();
		}
		public Expression_wrapperContext expression_wrapper(int i) {
			return GetRuleContext<Expression_wrapperContext>(i);
		}
		public DatatypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datatype; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterDatatype(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitDatatype(this);
		}
	}

	[RuleVersion(0)]
	public DatatypeContext datatype() {
		DatatypeContext _localctx = new DatatypeContext(Context, State);
		EnterRule(_localctx, 722, RULE_datatype);
		int _la;
		try {
			State = 5034;
			switch (TokenStream.La(1)) {
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case CLOB:
			case DATE:
			case DAY:
			case DEC:
			case DECIMAL:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case FLOAT:
			case HOUR:
			case INT:
			case INTEGER:
			case LONG:
			case MINUTE:
			case MLSLABEL:
			case MONTH:
			case NATURAL:
			case NATURALN:
			case NCHAR:
			case NCLOB:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case RAW:
			case REAL:
			case ROWID:
			case SECOND:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SMALLINT:
			case STRING:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case UROWID:
			case VARCHAR:
			case VARCHAR2:
			case YEAR:
			case YMINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5006; native_datatype_element();
				State = 5008;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,654,Context) ) {
				case 1:
					{
					State = 5007; precision_part();
					}
					break;
				}
				State = 5016;
				_la = TokenStream.La(1);
				if (_la==WITH) {
					{
					State = 5010; Match(WITH);
					State = 5012;
					_la = TokenStream.La(1);
					if (_la==LOCAL) {
						{
						State = 5011; Match(LOCAL);
						}
					}

					State = 5014; Match(TIME);
					State = 5015; Match(ZONE);
					}
				}

				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5018; Match(INTERVAL);
				State = 5019;
				_la = TokenStream.La(1);
				if ( !(_la==DAY || _la==YEAR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 5024;
				_la = TokenStream.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 5020; Match(LEFT_PAREN);
					State = 5021; expression_wrapper();
					State = 5022; Match(RIGHT_PAREN);
					}
				}

				State = 5026; Match(TO);
				State = 5027;
				_la = TokenStream.La(1);
				if ( !(_la==MONTH || _la==SECOND) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 5032;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,658,Context) ) {
				case 1:
					{
					State = 5028; Match(LEFT_PAREN);
					State = 5029; expression_wrapper();
					State = 5030; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Precision_partContext : ParserRuleContext {
		public NumericContext[] numeric() {
			return GetRuleContexts<NumericContext>();
		}
		public NumericContext numeric(int i) {
			return GetRuleContext<NumericContext>(i);
		}
		public ITerminalNode CHAR() { return GetToken(plsqlParser.CHAR, 0); }
		public ITerminalNode BYTE() { return GetToken(plsqlParser.BYTE, 0); }
		public Precision_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precision_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterPrecision_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitPrecision_part(this);
		}
	}

	[RuleVersion(0)]
	public Precision_partContext precision_part() {
		Precision_partContext _localctx = new Precision_partContext(Context, State);
		EnterRule(_localctx, 724, RULE_precision_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5036; Match(LEFT_PAREN);
			State = 5037; numeric();
			State = 5040;
			_la = TokenStream.La(1);
			if (_la==COMMA) {
				{
				State = 5038; Match(COMMA);
				State = 5039; numeric();
				}
			}

			State = 5043;
			_la = TokenStream.La(1);
			if (_la==BYTE || _la==CHAR) {
				{
				State = 5042;
				_la = TokenStream.La(1);
				if ( !(_la==BYTE || _la==CHAR) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
			}

			State = 5045; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Native_datatype_elementContext : ParserRuleContext {
		public ITerminalNode BINARY_INTEGER() { return GetToken(plsqlParser.BINARY_INTEGER, 0); }
		public ITerminalNode PLS_INTEGER() { return GetToken(plsqlParser.PLS_INTEGER, 0); }
		public ITerminalNode NATURAL() { return GetToken(plsqlParser.NATURAL, 0); }
		public ITerminalNode BINARY_FLOAT() { return GetToken(plsqlParser.BINARY_FLOAT, 0); }
		public ITerminalNode BINARY_DOUBLE() { return GetToken(plsqlParser.BINARY_DOUBLE, 0); }
		public ITerminalNode NATURALN() { return GetToken(plsqlParser.NATURALN, 0); }
		public ITerminalNode POSITIVE() { return GetToken(plsqlParser.POSITIVE, 0); }
		public ITerminalNode POSITIVEN() { return GetToken(plsqlParser.POSITIVEN, 0); }
		public ITerminalNode SIGNTYPE() { return GetToken(plsqlParser.SIGNTYPE, 0); }
		public ITerminalNode SIMPLE_INTEGER() { return GetToken(plsqlParser.SIMPLE_INTEGER, 0); }
		public ITerminalNode NVARCHAR2() { return GetToken(plsqlParser.NVARCHAR2, 0); }
		public ITerminalNode DEC() { return GetToken(plsqlParser.DEC, 0); }
		public ITerminalNode INTEGER() { return GetToken(plsqlParser.INTEGER, 0); }
		public ITerminalNode INT() { return GetToken(plsqlParser.INT, 0); }
		public ITerminalNode NUMERIC() { return GetToken(plsqlParser.NUMERIC, 0); }
		public ITerminalNode SMALLINT() { return GetToken(plsqlParser.SMALLINT, 0); }
		public ITerminalNode NUMBER() { return GetToken(plsqlParser.NUMBER, 0); }
		public ITerminalNode DECIMAL() { return GetToken(plsqlParser.DECIMAL, 0); }
		public ITerminalNode DOUBLE() { return GetToken(plsqlParser.DOUBLE, 0); }
		public ITerminalNode PRECISION() { return GetToken(plsqlParser.PRECISION, 0); }
		public ITerminalNode FLOAT() { return GetToken(plsqlParser.FLOAT, 0); }
		public ITerminalNode REAL() { return GetToken(plsqlParser.REAL, 0); }
		public ITerminalNode NCHAR() { return GetToken(plsqlParser.NCHAR, 0); }
		public ITerminalNode LONG() { return GetToken(plsqlParser.LONG, 0); }
		public ITerminalNode RAW() { return GetToken(plsqlParser.RAW, 0); }
		public ITerminalNode CHAR() { return GetToken(plsqlParser.CHAR, 0); }
		public ITerminalNode CHARACTER() { return GetToken(plsqlParser.CHARACTER, 0); }
		public ITerminalNode VARCHAR2() { return GetToken(plsqlParser.VARCHAR2, 0); }
		public ITerminalNode VARCHAR() { return GetToken(plsqlParser.VARCHAR, 0); }
		public ITerminalNode STRING() { return GetToken(plsqlParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(plsqlParser.BOOLEAN, 0); }
		public ITerminalNode DATE() { return GetToken(plsqlParser.DATE, 0); }
		public ITerminalNode ROWID() { return GetToken(plsqlParser.ROWID, 0); }
		public ITerminalNode UROWID() { return GetToken(plsqlParser.UROWID, 0); }
		public ITerminalNode YEAR() { return GetToken(plsqlParser.YEAR, 0); }
		public ITerminalNode MONTH() { return GetToken(plsqlParser.MONTH, 0); }
		public ITerminalNode DAY() { return GetToken(plsqlParser.DAY, 0); }
		public ITerminalNode HOUR() { return GetToken(plsqlParser.HOUR, 0); }
		public ITerminalNode MINUTE() { return GetToken(plsqlParser.MINUTE, 0); }
		public ITerminalNode SECOND() { return GetToken(plsqlParser.SECOND, 0); }
		public ITerminalNode TIMEZONE_HOUR() { return GetToken(plsqlParser.TIMEZONE_HOUR, 0); }
		public ITerminalNode TIMEZONE_MINUTE() { return GetToken(plsqlParser.TIMEZONE_MINUTE, 0); }
		public ITerminalNode TIMEZONE_REGION() { return GetToken(plsqlParser.TIMEZONE_REGION, 0); }
		public ITerminalNode TIMEZONE_ABBR() { return GetToken(plsqlParser.TIMEZONE_ABBR, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(plsqlParser.TIMESTAMP, 0); }
		public ITerminalNode TIMESTAMP_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_TZ_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_LTZ_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0); }
		public ITerminalNode YMINTERVAL_UNCONSTRAINED() { return GetToken(plsqlParser.YMINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode DSINTERVAL_UNCONSTRAINED() { return GetToken(plsqlParser.DSINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode BFILE() { return GetToken(plsqlParser.BFILE, 0); }
		public ITerminalNode BLOB() { return GetToken(plsqlParser.BLOB, 0); }
		public ITerminalNode CLOB() { return GetToken(plsqlParser.CLOB, 0); }
		public ITerminalNode NCLOB() { return GetToken(plsqlParser.NCLOB, 0); }
		public ITerminalNode MLSLABEL() { return GetToken(plsqlParser.MLSLABEL, 0); }
		public Native_datatype_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_native_datatype_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNative_datatype_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNative_datatype_element(this);
		}
	}

	[RuleVersion(0)]
	public Native_datatype_elementContext native_datatype_element() {
		Native_datatype_elementContext _localctx = new Native_datatype_elementContext(Context, State);
		EnterRule(_localctx, 726, RULE_native_datatype_element);
		int _la;
		try {
			State = 5107;
			switch (TokenStream.La(1)) {
			case BINARY_INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5047; Match(BINARY_INTEGER);
				}
				break;
			case PLS_INTEGER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5048; Match(PLS_INTEGER);
				}
				break;
			case NATURAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5049; Match(NATURAL);
				}
				break;
			case BINARY_FLOAT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5050; Match(BINARY_FLOAT);
				}
				break;
			case BINARY_DOUBLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5051; Match(BINARY_DOUBLE);
				}
				break;
			case NATURALN:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5052; Match(NATURALN);
				}
				break;
			case POSITIVE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5053; Match(POSITIVE);
				}
				break;
			case POSITIVEN:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5054; Match(POSITIVEN);
				}
				break;
			case SIGNTYPE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5055; Match(SIGNTYPE);
				}
				break;
			case SIMPLE_INTEGER:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5056; Match(SIMPLE_INTEGER);
				}
				break;
			case NVARCHAR2:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5057; Match(NVARCHAR2);
				}
				break;
			case DEC:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5058; Match(DEC);
				}
				break;
			case INTEGER:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5059; Match(INTEGER);
				}
				break;
			case INT:
				EnterOuterAlt(_localctx, 14);
				{
				State = 5060; Match(INT);
				}
				break;
			case NUMERIC:
				EnterOuterAlt(_localctx, 15);
				{
				State = 5061; Match(NUMERIC);
				}
				break;
			case SMALLINT:
				EnterOuterAlt(_localctx, 16);
				{
				State = 5062; Match(SMALLINT);
				}
				break;
			case NUMBER:
				EnterOuterAlt(_localctx, 17);
				{
				State = 5063; Match(NUMBER);
				}
				break;
			case DECIMAL:
				EnterOuterAlt(_localctx, 18);
				{
				State = 5064; Match(DECIMAL);
				}
				break;
			case DOUBLE:
				EnterOuterAlt(_localctx, 19);
				{
				State = 5065; Match(DOUBLE);
				State = 5067;
				_la = TokenStream.La(1);
				if (_la==PRECISION) {
					{
					State = 5066; Match(PRECISION);
					}
				}

				}
				break;
			case FLOAT:
				EnterOuterAlt(_localctx, 20);
				{
				State = 5069; Match(FLOAT);
				}
				break;
			case REAL:
				EnterOuterAlt(_localctx, 21);
				{
				State = 5070; Match(REAL);
				}
				break;
			case NCHAR:
				EnterOuterAlt(_localctx, 22);
				{
				State = 5071; Match(NCHAR);
				}
				break;
			case LONG:
				EnterOuterAlt(_localctx, 23);
				{
				State = 5072; Match(LONG);
				State = 5074;
				_la = TokenStream.La(1);
				if (_la==RAW) {
					{
					State = 5073; Match(RAW);
					}
				}

				}
				break;
			case CHAR:
				EnterOuterAlt(_localctx, 24);
				{
				State = 5076; Match(CHAR);
				}
				break;
			case CHARACTER:
				EnterOuterAlt(_localctx, 25);
				{
				State = 5077; Match(CHARACTER);
				}
				break;
			case VARCHAR2:
				EnterOuterAlt(_localctx, 26);
				{
				State = 5078; Match(VARCHAR2);
				}
				break;
			case VARCHAR:
				EnterOuterAlt(_localctx, 27);
				{
				State = 5079; Match(VARCHAR);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 28);
				{
				State = 5080; Match(STRING);
				}
				break;
			case RAW:
				EnterOuterAlt(_localctx, 29);
				{
				State = 5081; Match(RAW);
				}
				break;
			case BOOLEAN:
				EnterOuterAlt(_localctx, 30);
				{
				State = 5082; Match(BOOLEAN);
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 31);
				{
				State = 5083; Match(DATE);
				}
				break;
			case ROWID:
				EnterOuterAlt(_localctx, 32);
				{
				State = 5084; Match(ROWID);
				}
				break;
			case UROWID:
				EnterOuterAlt(_localctx, 33);
				{
				State = 5085; Match(UROWID);
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 34);
				{
				State = 5086; Match(YEAR);
				}
				break;
			case MONTH:
				EnterOuterAlt(_localctx, 35);
				{
				State = 5087; Match(MONTH);
				}
				break;
			case DAY:
				EnterOuterAlt(_localctx, 36);
				{
				State = 5088; Match(DAY);
				}
				break;
			case HOUR:
				EnterOuterAlt(_localctx, 37);
				{
				State = 5089; Match(HOUR);
				}
				break;
			case MINUTE:
				EnterOuterAlt(_localctx, 38);
				{
				State = 5090; Match(MINUTE);
				}
				break;
			case SECOND:
				EnterOuterAlt(_localctx, 39);
				{
				State = 5091; Match(SECOND);
				}
				break;
			case TIMEZONE_HOUR:
				EnterOuterAlt(_localctx, 40);
				{
				State = 5092; Match(TIMEZONE_HOUR);
				}
				break;
			case TIMEZONE_MINUTE:
				EnterOuterAlt(_localctx, 41);
				{
				State = 5093; Match(TIMEZONE_MINUTE);
				}
				break;
			case TIMEZONE_REGION:
				EnterOuterAlt(_localctx, 42);
				{
				State = 5094; Match(TIMEZONE_REGION);
				}
				break;
			case TIMEZONE_ABBR:
				EnterOuterAlt(_localctx, 43);
				{
				State = 5095; Match(TIMEZONE_ABBR);
				}
				break;
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 44);
				{
				State = 5096; Match(TIMESTAMP);
				}
				break;
			case TIMESTAMP_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 45);
				{
				State = 5097; Match(TIMESTAMP_UNCONSTRAINED);
				}
				break;
			case TIMESTAMP_TZ_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 46);
				{
				State = 5098; Match(TIMESTAMP_TZ_UNCONSTRAINED);
				}
				break;
			case TIMESTAMP_LTZ_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 47);
				{
				State = 5099; Match(TIMESTAMP_LTZ_UNCONSTRAINED);
				}
				break;
			case YMINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 48);
				{
				State = 5100; Match(YMINTERVAL_UNCONSTRAINED);
				}
				break;
			case DSINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 49);
				{
				State = 5101; Match(DSINTERVAL_UNCONSTRAINED);
				}
				break;
			case BFILE:
				EnterOuterAlt(_localctx, 50);
				{
				State = 5102; Match(BFILE);
				}
				break;
			case BLOB:
				EnterOuterAlt(_localctx, 51);
				{
				State = 5103; Match(BLOB);
				}
				break;
			case CLOB:
				EnterOuterAlt(_localctx, 52);
				{
				State = 5104; Match(CLOB);
				}
				break;
			case NCLOB:
				EnterOuterAlt(_localctx, 53);
				{
				State = 5105; Match(NCLOB);
				}
				break;
			case MLSLABEL:
				EnterOuterAlt(_localctx, 54);
				{
				State = 5106; Match(MLSLABEL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bind_variableContext : ParserRuleContext {
		public ITerminalNode[] BINDVAR() { return GetTokens(plsqlParser.BINDVAR); }
		public ITerminalNode BINDVAR(int i) {
			return GetToken(plsqlParser.BINDVAR, i);
		}
		public ITerminalNode[] UNSIGNED_INTEGER() { return GetTokens(plsqlParser.UNSIGNED_INTEGER); }
		public ITerminalNode UNSIGNED_INTEGER(int i) {
			return GetToken(plsqlParser.UNSIGNED_INTEGER, i);
		}
		public General_element_partContext[] general_element_part() {
			return GetRuleContexts<General_element_partContext>();
		}
		public General_element_partContext general_element_part(int i) {
			return GetRuleContext<General_element_partContext>(i);
		}
		public ITerminalNode INDICATOR() { return GetToken(plsqlParser.INDICATOR, 0); }
		public Bind_variableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bind_variable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterBind_variable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitBind_variable(this);
		}
	}

	[RuleVersion(0)]
	public Bind_variableContext bind_variable() {
		Bind_variableContext _localctx = new Bind_variableContext(Context, State);
		EnterRule(_localctx, 728, RULE_bind_variable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5112;
			switch (TokenStream.La(1)) {
			case BINDVAR:
				{
				State = 5109; Match(BINDVAR);
				}
				break;
			case COLON:
				{
				State = 5110; Match(COLON);
				State = 5111; Match(UNSIGNED_INTEGER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5122;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,668,Context) ) {
			case 1:
				{
				State = 5115;
				_la = TokenStream.La(1);
				if (_la==INDICATOR) {
					{
					State = 5114; Match(INDICATOR);
					}
				}

				State = 5120;
				switch (TokenStream.La(1)) {
				case BINDVAR:
					{
					State = 5117; Match(BINDVAR);
					}
					break;
				case COLON:
					{
					State = 5118; Match(COLON);
					State = 5119; Match(UNSIGNED_INTEGER);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			State = 5128;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5124; Match(PERIOD);
				State = 5125; general_element_part();
				}
				}
				State = 5130;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_elementContext : ParserRuleContext {
		public General_element_partContext[] general_element_part() {
			return GetRuleContexts<General_element_partContext>();
		}
		public General_element_partContext general_element_part(int i) {
			return GetRuleContext<General_element_partContext>(i);
		}
		public General_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGeneral_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGeneral_element(this);
		}
	}

	[RuleVersion(0)]
	public General_elementContext general_element() {
		General_elementContext _localctx = new General_elementContext(Context, State);
		EnterRule(_localctx, 730, RULE_general_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5131; general_element_part();
			State = 5136;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5132; Match(PERIOD);
				State = 5133; general_element_part();
				}
				}
				State = 5138;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_element_partContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode INTRODUCER() { return GetToken(plsqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public General_element_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_element_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGeneral_element_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGeneral_element_part(this);
		}
	}

	[RuleVersion(0)]
	public General_element_partContext general_element_part() {
		General_element_partContext _localctx = new General_element_partContext(Context, State);
		EnterRule(_localctx, 732, RULE_general_element_part);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5141;
			_la = TokenStream.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5139; Match(INTRODUCER);
				State = 5140; char_set_name();
				}
			}

			State = 5143; id_expression();
			State = 5148;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,672,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 5144; Match(PERIOD);
					State = 5145; id_expression();
					}
					} 
				}
				State = 5150;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,672,Context);
			}
			State = 5152;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,673,Context) ) {
			case 1:
				{
				State = 5151; function_argument();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_elementContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode INTRODUCER() { return GetToken(plsqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterTable_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitTable_element(this);
		}
	}

	[RuleVersion(0)]
	public Table_elementContext table_element() {
		Table_elementContext _localctx = new Table_elementContext(Context, State);
		EnterRule(_localctx, 734, RULE_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5156;
			_la = TokenStream.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5154; Match(INTRODUCER);
				State = 5155; char_set_name();
				}
			}

			State = 5158; id_expression();
			State = 5163;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5159; Match(PERIOD);
				State = 5160; id_expression();
				}
				}
				State = 5165;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode TIMESTAMP() { return GetToken(plsqlParser.TIMESTAMP, 0); }
		public Quoted_stringContext[] quoted_string() {
			return GetRuleContexts<Quoted_stringContext>();
		}
		public Quoted_stringContext quoted_string(int i) {
			return GetRuleContext<Quoted_stringContext>(i);
		}
		public Bind_variableContext[] bind_variable() {
			return GetRuleContexts<Bind_variableContext>();
		}
		public Bind_variableContext bind_variable(int i) {
			return GetRuleContext<Bind_variableContext>(i);
		}
		public ITerminalNode AT() { return GetToken(plsqlParser.AT, 0); }
		public ITerminalNode TIME() { return GetToken(plsqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(plsqlParser.ZONE, 0); }
		public ITerminalNode INTERVAL() { return GetToken(plsqlParser.INTERVAL, 0); }
		public ITerminalNode[] DAY() { return GetTokens(plsqlParser.DAY); }
		public ITerminalNode DAY(int i) {
			return GetToken(plsqlParser.DAY, i);
		}
		public ITerminalNode[] HOUR() { return GetTokens(plsqlParser.HOUR); }
		public ITerminalNode HOUR(int i) {
			return GetToken(plsqlParser.HOUR, i);
		}
		public ITerminalNode[] MINUTE() { return GetTokens(plsqlParser.MINUTE); }
		public ITerminalNode MINUTE(int i) {
			return GetToken(plsqlParser.MINUTE, i);
		}
		public ITerminalNode[] SECOND() { return GetTokens(plsqlParser.SECOND); }
		public ITerminalNode SECOND(int i) {
			return GetToken(plsqlParser.SECOND, i);
		}
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public ITerminalNode TO() { return GetToken(plsqlParser.TO, 0); }
		public ITerminalNode[] UNSIGNED_INTEGER() { return GetTokens(plsqlParser.UNSIGNED_INTEGER); }
		public ITerminalNode UNSIGNED_INTEGER(int i) {
			return GetToken(plsqlParser.UNSIGNED_INTEGER, i);
		}
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public ITerminalNode DATE() { return GetToken(plsqlParser.DATE, 0); }
		public ITerminalNode NULL() { return GetToken(plsqlParser.NULL, 0); }
		public ITerminalNode TRUE() { return GetToken(plsqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(plsqlParser.FALSE, 0); }
		public ITerminalNode DBTIMEZONE() { return GetToken(plsqlParser.DBTIMEZONE, 0); }
		public ITerminalNode SESSIONTIMEZONE() { return GetToken(plsqlParser.SESSIONTIMEZONE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(plsqlParser.MINVALUE, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(plsqlParser.MAXVALUE, 0); }
		public ITerminalNode DEFAULT() { return GetToken(plsqlParser.DEFAULT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 736, RULE_constant);
		int _la;
		try {
			State = 5228;
			switch (TokenStream.La(1)) {
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5166; Match(TIMESTAMP);
				State = 5169;
				switch (TokenStream.La(1)) {
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 5167; quoted_string();
					}
					break;
				case BINDVAR:
				case COLON:
					{
					State = 5168; bind_variable();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5175;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,677,Context) ) {
				case 1:
					{
					State = 5171; Match(AT);
					State = 5172; Match(TIME);
					State = 5173; Match(ZONE);
					State = 5174; quoted_string();
					}
					break;
				}
				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5177; Match(INTERVAL);
				State = 5181;
				switch (TokenStream.La(1)) {
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 5178; quoted_string();
					}
					break;
				case BINDVAR:
				case COLON:
					{
					State = 5179; bind_variable();
					}
					break;
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ANALYZE:
				case ARRAY:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BULK:
				case BYTE:
				case C_LETTER:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CROSS:
				case CUBE:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DOCUMENT:
				case DOUBLE:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case ENTITYESCAPING:
				case ERR:
				case ERRORS:
				case ESCAPE:
				case EVALNAME:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXECUTE:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FORALL:
				case FORCE:
				case FULL:
				case FUNCTION:
				case GROUPING:
				case HASH:
				case HIDE:
				case HOUR:
				case IGNORE:
				case IMMEDIATE:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERVAL:
				case INVALIDATE:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NONE:
				case NOSCHEMACHECK:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OFF:
				case OID:
				case OLD:
				case ONLY:
				case OPEN:
				case ORADATA:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELF:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case STANDALONE:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNLIMITED:
				case UNTIL:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case VALIDATE:
				case VALUE:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHENEVER:
				case WHILE:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 5180; general_element_part();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5183;
				_la = TokenStream.La(1);
				if ( !(_la==DAY || _la==HOUR || _la==MINUTE || _la==SECOND) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 5197;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,682,Context) ) {
				case 1:
					{
					State = 5184; Match(LEFT_PAREN);
					State = 5187;
					switch (TokenStream.La(1)) {
					case UNSIGNED_INTEGER:
						{
						State = 5185; Match(UNSIGNED_INTEGER);
						}
						break;
					case BINDVAR:
					case COLON:
						{
						State = 5186; bind_variable();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5194;
					_la = TokenStream.La(1);
					if (_la==COMMA) {
						{
						State = 5189; Match(COMMA);
						State = 5192;
						switch (TokenStream.La(1)) {
						case UNSIGNED_INTEGER:
							{
							State = 5190; Match(UNSIGNED_INTEGER);
							}
							break;
						case BINDVAR:
						case COLON:
							{
							State = 5191; bind_variable();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
					}

					State = 5196; Match(RIGHT_PAREN);
					}
					break;
				}
				State = 5214;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,686,Context) ) {
				case 1:
					{
					State = 5199; Match(TO);
					State = 5212;
					switch (TokenStream.La(1)) {
					case DAY:
						{
						State = 5200; Match(DAY);
						}
						break;
					case HOUR:
						{
						State = 5201; Match(HOUR);
						}
						break;
					case MINUTE:
						{
						State = 5202; Match(MINUTE);
						}
						break;
					case SECOND:
						{
						State = 5203; Match(SECOND);
						State = 5210;
						ErrorHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(TokenStream,684,Context) ) {
						case 1:
							{
							State = 5204; Match(LEFT_PAREN);
							State = 5207;
							switch (TokenStream.La(1)) {
							case UNSIGNED_INTEGER:
								{
								State = 5205; Match(UNSIGNED_INTEGER);
								}
								break;
							case BINDVAR:
							case COLON:
								{
								State = 5206; bind_variable();
								}
								break;
							default:
								throw new NoViableAltException(this);
							}
							State = 5209; Match(RIGHT_PAREN);
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				}
				}
				break;
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5216; numeric();
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5217; Match(DATE);
				State = 5218; quoted_string();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5219; quoted_string();
				}
				break;
			case NULL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5220; Match(NULL);
				}
				break;
			case TRUE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5221; Match(TRUE);
				}
				break;
			case FALSE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5222; Match(FALSE);
				}
				break;
			case DBTIMEZONE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5223; Match(DBTIMEZONE);
				}
				break;
			case SESSIONTIMEZONE:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5224; Match(SESSIONTIMEZONE);
				}
				break;
			case MINVALUE:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5225; Match(MINVALUE);
				}
				break;
			case MAXVALUE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5226; Match(MAXVALUE);
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5227; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericContext : ParserRuleContext {
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(plsqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode APPROXIMATE_NUM_LIT() { return GetToken(plsqlParser.APPROXIMATE_NUM_LIT, 0); }
		public NumericContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNumeric(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNumeric(this);
		}
	}

	[RuleVersion(0)]
	public NumericContext numeric() {
		NumericContext _localctx = new NumericContext(Context, State);
		EnterRule(_localctx, 738, RULE_numeric);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5230;
			_la = TokenStream.La(1);
			if ( !(_la==UNSIGNED_INTEGER || _la==APPROXIMATE_NUM_LIT) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Numeric_negativeContext : ParserRuleContext {
		public ITerminalNode MINUS_SIGN() { return GetToken(plsqlParser.MINUS_SIGN, 0); }
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public Numeric_negativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric_negative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNumeric_negative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNumeric_negative(this);
		}
	}

	[RuleVersion(0)]
	public Numeric_negativeContext numeric_negative() {
		Numeric_negativeContext _localctx = new Numeric_negativeContext(Context, State);
		EnterRule(_localctx, 740, RULE_numeric_negative);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5232; Match(MINUS_SIGN);
			State = 5233; numeric();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quoted_stringContext : ParserRuleContext {
		public ITerminalNode CHAR_STRING() { return GetToken(plsqlParser.CHAR_STRING, 0); }
		public ITerminalNode NATIONAL_CHAR_STRING_LIT() { return GetToken(plsqlParser.NATIONAL_CHAR_STRING_LIT, 0); }
		public Quoted_stringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quoted_string; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterQuoted_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitQuoted_string(this);
		}
	}

	[RuleVersion(0)]
	public Quoted_stringContext quoted_string() {
		Quoted_stringContext _localctx = new Quoted_stringContext(Context, State);
		EnterRule(_localctx, 742, RULE_quoted_string);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5235;
			_la = TokenStream.La(1);
			if ( !(_la==NATIONAL_CHAR_STRING_LIT || _la==CHAR_STRING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(plsqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public IdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitId(this);
		}
	}

	[RuleVersion(0)]
	public IdContext id() {
		IdContext _localctx = new IdContext(Context, State);
		EnterRule(_localctx, 744, RULE_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5239;
			_la = TokenStream.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5237; Match(INTRODUCER);
				State = 5238; char_set_name();
				}
			}

			State = 5241; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Id_expressionContext : ParserRuleContext {
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public ITerminalNode DELIMITED_ID() { return GetToken(plsqlParser.DELIMITED_ID, 0); }
		public Id_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterId_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitId_expression(this);
		}
	}

	[RuleVersion(0)]
	public Id_expressionContext id_expression() {
		Id_expressionContext _localctx = new Id_expressionContext(Context, State);
		EnterRule(_localctx, 746, RULE_id_expression);
		try {
			State = 5245;
			switch (TokenStream.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ANALYZE:
			case ARRAY:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BULK:
			case BYTE:
			case C_LETTER:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CROSS:
			case CUBE:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DOCUMENT:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case ENTITYESCAPING:
			case ERR:
			case ERRORS:
			case ESCAPE:
			case EVALNAME:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXECUTE:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FORALL:
			case FORCE:
			case FULL:
			case FUNCTION:
			case GROUPING:
			case HASH:
			case HIDE:
			case HOUR:
			case IGNORE:
			case IMMEDIATE:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERVAL:
			case INVALIDATE:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NONE:
			case NOSCHEMACHECK:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OFF:
			case OID:
			case OLD:
			case ONLY:
			case OPEN:
			case ORADATA:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELF:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case STANDALONE:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNLIMITED:
			case UNTIL:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case VALIDATE:
			case VALUE:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHENEVER:
			case WHILE:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5243; regular_id();
				}
				break;
			case DELIMITED_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5244; Match(DELIMITED_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Not_equal_opContext : ParserRuleContext {
		public ITerminalNode NOT_EQUAL_OP() { return GetToken(plsqlParser.NOT_EQUAL_OP, 0); }
		public Not_equal_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_not_equal_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterNot_equal_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitNot_equal_op(this);
		}
	}

	[RuleVersion(0)]
	public Not_equal_opContext not_equal_op() {
		Not_equal_opContext _localctx = new Not_equal_opContext(Context, State);
		EnterRule(_localctx, 748, RULE_not_equal_op);
		try {
			State = 5254;
			switch (TokenStream.La(1)) {
			case NOT_EQUAL_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5247; Match(NOT_EQUAL_OP);
				}
				break;
			case LESS_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5248; Match(LESS_THAN_OP);
				State = 5249; Match(GREATER_THAN_OP);
				}
				break;
			case EXCLAMATION_OPERATOR_PART:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5250; Match(EXCLAMATION_OPERATOR_PART);
				State = 5251; Match(EQUALS_OP);
				}
				break;
			case CARRET_OPERATOR_PART:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5252; Match(CARRET_OPERATOR_PART);
				State = 5253; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Greater_than_or_equals_opContext : ParserRuleContext {
		public Greater_than_or_equals_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_greater_than_or_equals_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterGreater_than_or_equals_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitGreater_than_or_equals_op(this);
		}
	}

	[RuleVersion(0)]
	public Greater_than_or_equals_opContext greater_than_or_equals_op() {
		Greater_than_or_equals_opContext _localctx = new Greater_than_or_equals_opContext(Context, State);
		EnterRule(_localctx, 750, RULE_greater_than_or_equals_op);
		try {
			State = 5259;
			switch (TokenStream.La(1)) {
			case GREATER_THAN_OR_EQUALS_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5256; Match(GREATER_THAN_OR_EQUALS_OP);
				}
				break;
			case GREATER_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5257; Match(GREATER_THAN_OP);
				State = 5258; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Less_than_or_equals_opContext : ParserRuleContext {
		public Less_than_or_equals_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_less_than_or_equals_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterLess_than_or_equals_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitLess_than_or_equals_op(this);
		}
	}

	[RuleVersion(0)]
	public Less_than_or_equals_opContext less_than_or_equals_op() {
		Less_than_or_equals_opContext _localctx = new Less_than_or_equals_opContext(Context, State);
		EnterRule(_localctx, 752, RULE_less_than_or_equals_op);
		try {
			State = 5264;
			switch (TokenStream.La(1)) {
			case LESS_THAN_OR_EQUALS_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5261; Match(LESS_THAN_OR_EQUALS_OP);
				}
				break;
			case LESS_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5262; Match(LESS_THAN_OP);
				State = 5263; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Concatenation_opContext : ParserRuleContext {
		public Concatenation_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterConcatenation_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitConcatenation_op(this);
		}
	}

	[RuleVersion(0)]
	public Concatenation_opContext concatenation_op() {
		Concatenation_opContext _localctx = new Concatenation_opContext(Context, State);
		EnterRule(_localctx, 754, RULE_concatenation_op);
		try {
			State = 5269;
			switch (TokenStream.La(1)) {
			case CONCATENATION_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5266; Match(CONCATENATION_OP);
				}
				break;
			case VERTICAL_BAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5267; Match(VERTICAL_BAR);
				State = 5268; Match(VERTICAL_BAR);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Outer_join_signContext : ParserRuleContext {
		public Outer_join_signContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outer_join_sign; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterOuter_join_sign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitOuter_join_sign(this);
		}
	}

	[RuleVersion(0)]
	public Outer_join_signContext outer_join_sign() {
		Outer_join_signContext _localctx = new Outer_join_signContext(Context, State);
		EnterRule(_localctx, 756, RULE_outer_join_sign);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5271; Match(LEFT_PAREN);
			State = 5272; Match(PLUS_SIGN);
			State = 5273; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Regular_idContext : ParserRuleContext {
		public ITerminalNode REGULAR_ID() { return GetToken(plsqlParser.REGULAR_ID, 0); }
		public ITerminalNode A_LETTER() { return GetToken(plsqlParser.A_LETTER, 0); }
		public ITerminalNode ADD() { return GetToken(plsqlParser.ADD, 0); }
		public ITerminalNode AFTER() { return GetToken(plsqlParser.AFTER, 0); }
		public ITerminalNode AGENT() { return GetToken(plsqlParser.AGENT, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(plsqlParser.AGGREGATE, 0); }
		public ITerminalNode ANALYZE() { return GetToken(plsqlParser.ANALYZE, 0); }
		public ITerminalNode ARRAY() { return GetToken(plsqlParser.ARRAY, 0); }
		public ITerminalNode ASSOCIATE() { return GetToken(plsqlParser.ASSOCIATE, 0); }
		public ITerminalNode AT() { return GetToken(plsqlParser.AT, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(plsqlParser.ATTRIBUTE, 0); }
		public ITerminalNode AUDIT() { return GetToken(plsqlParser.AUDIT, 0); }
		public ITerminalNode AUTHID() { return GetToken(plsqlParser.AUTHID, 0); }
		public ITerminalNode AUTO() { return GetToken(plsqlParser.AUTO, 0); }
		public ITerminalNode AUTOMATIC() { return GetToken(plsqlParser.AUTOMATIC, 0); }
		public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(plsqlParser.AUTONOMOUS_TRANSACTION, 0); }
		public ITerminalNode BATCH() { return GetToken(plsqlParser.BATCH, 0); }
		public ITerminalNode BEFORE() { return GetToken(plsqlParser.BEFORE, 0); }
		public ITerminalNode BFILE() { return GetToken(plsqlParser.BFILE, 0); }
		public ITerminalNode BINARY_DOUBLE() { return GetToken(plsqlParser.BINARY_DOUBLE, 0); }
		public ITerminalNode BINARY_FLOAT() { return GetToken(plsqlParser.BINARY_FLOAT, 0); }
		public ITerminalNode BINARY_INTEGER() { return GetToken(plsqlParser.BINARY_INTEGER, 0); }
		public ITerminalNode BLOB() { return GetToken(plsqlParser.BLOB, 0); }
		public ITerminalNode BLOCK() { return GetToken(plsqlParser.BLOCK, 0); }
		public ITerminalNode BODY() { return GetToken(plsqlParser.BODY, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(plsqlParser.BOOLEAN, 0); }
		public ITerminalNode BOTH() { return GetToken(plsqlParser.BOTH, 0); }
		public ITerminalNode BULK() { return GetToken(plsqlParser.BULK, 0); }
		public ITerminalNode BYTE() { return GetToken(plsqlParser.BYTE, 0); }
		public ITerminalNode C_LETTER() { return GetToken(plsqlParser.C_LETTER, 0); }
		public ITerminalNode CALL() { return GetToken(plsqlParser.CALL, 0); }
		public ITerminalNode CANONICAL() { return GetToken(plsqlParser.CANONICAL, 0); }
		public ITerminalNode CASCADE() { return GetToken(plsqlParser.CASCADE, 0); }
		public ITerminalNode CAST() { return GetToken(plsqlParser.CAST, 0); }
		public ITerminalNode CHAR() { return GetToken(plsqlParser.CHAR, 0); }
		public ITerminalNode CHAR_CS() { return GetToken(plsqlParser.CHAR_CS, 0); }
		public ITerminalNode CHARACTER() { return GetToken(plsqlParser.CHARACTER, 0); }
		public ITerminalNode CHR() { return GetToken(plsqlParser.CHR, 0); }
		public ITerminalNode CLOB() { return GetToken(plsqlParser.CLOB, 0); }
		public ITerminalNode CLOSE() { return GetToken(plsqlParser.CLOSE, 0); }
		public ITerminalNode CLUSTER() { return GetToken(plsqlParser.CLUSTER, 0); }
		public ITerminalNode COLLECT() { return GetToken(plsqlParser.COLLECT, 0); }
		public ITerminalNode COLUMNS() { return GetToken(plsqlParser.COLUMNS, 0); }
		public ITerminalNode COMMENT() { return GetToken(plsqlParser.COMMENT, 0); }
		public ITerminalNode COMMIT() { return GetToken(plsqlParser.COMMIT, 0); }
		public ITerminalNode COMMITTED() { return GetToken(plsqlParser.COMMITTED, 0); }
		public ITerminalNode COMPATIBILITY() { return GetToken(plsqlParser.COMPATIBILITY, 0); }
		public ITerminalNode COMPILE() { return GetToken(plsqlParser.COMPILE, 0); }
		public ITerminalNode COMPOUND() { return GetToken(plsqlParser.COMPOUND, 0); }
		public ITerminalNode CONSTANT() { return GetToken(plsqlParser.CONSTANT, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(plsqlParser.CONSTRAINT, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(plsqlParser.CONSTRAINTS, 0); }
		public ITerminalNode CONSTRUCTOR() { return GetToken(plsqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode CONTENT() { return GetToken(plsqlParser.CONTENT, 0); }
		public ITerminalNode CONTEXT() { return GetToken(plsqlParser.CONTEXT, 0); }
		public ITerminalNode CONTINUE() { return GetToken(plsqlParser.CONTINUE, 0); }
		public ITerminalNode CONVERT() { return GetToken(plsqlParser.CONVERT, 0); }
		public ITerminalNode CORRUPT_XID() { return GetToken(plsqlParser.CORRUPT_XID, 0); }
		public ITerminalNode CORRUPT_XID_ALL() { return GetToken(plsqlParser.CORRUPT_XID_ALL, 0); }
		public ITerminalNode COST() { return GetToken(plsqlParser.COST, 0); }
		public ITerminalNode COUNT() { return GetToken(plsqlParser.COUNT, 0); }
		public ITerminalNode CROSS() { return GetToken(plsqlParser.CROSS, 0); }
		public ITerminalNode CUBE() { return GetToken(plsqlParser.CUBE, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(plsqlParser.CURRENT_USER, 0); }
		public ITerminalNode CURSOR() { return GetToken(plsqlParser.CURSOR, 0); }
		public ITerminalNode CUSTOMDATUM() { return GetToken(plsqlParser.CUSTOMDATUM, 0); }
		public ITerminalNode CYCLE() { return GetToken(plsqlParser.CYCLE, 0); }
		public ITerminalNode DATA() { return GetToken(plsqlParser.DATA, 0); }
		public ITerminalNode DATABASE() { return GetToken(plsqlParser.DATABASE, 0); }
		public ITerminalNode DAY() { return GetToken(plsqlParser.DAY, 0); }
		public ITerminalNode DB_ROLE_CHANGE() { return GetToken(plsqlParser.DB_ROLE_CHANGE, 0); }
		public ITerminalNode DBTIMEZONE() { return GetToken(plsqlParser.DBTIMEZONE, 0); }
		public ITerminalNode DDL() { return GetToken(plsqlParser.DDL, 0); }
		public ITerminalNode DEBUG() { return GetToken(plsqlParser.DEBUG, 0); }
		public ITerminalNode DEC() { return GetToken(plsqlParser.DEC, 0); }
		public ITerminalNode DECIMAL() { return GetToken(plsqlParser.DECIMAL, 0); }
		public ITerminalNode DECOMPOSE() { return GetToken(plsqlParser.DECOMPOSE, 0); }
		public ITerminalNode DECREMENT() { return GetToken(plsqlParser.DECREMENT, 0); }
		public ITerminalNode DEFAULTS() { return GetToken(plsqlParser.DEFAULTS, 0); }
		public ITerminalNode DEFERRED() { return GetToken(plsqlParser.DEFERRED, 0); }
		public ITerminalNode DEFINER() { return GetToken(plsqlParser.DEFINER, 0); }
		public ITerminalNode DETERMINISTIC() { return GetToken(plsqlParser.DETERMINISTIC, 0); }
		public ITerminalNode DIMENSION() { return GetToken(plsqlParser.DIMENSION, 0); }
		public ITerminalNode DISABLE() { return GetToken(plsqlParser.DISABLE, 0); }
		public ITerminalNode DISASSOCIATE() { return GetToken(plsqlParser.DISASSOCIATE, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(plsqlParser.DOCUMENT, 0); }
		public ITerminalNode DOUBLE() { return GetToken(plsqlParser.DOUBLE, 0); }
		public ITerminalNode DSINTERVAL_UNCONSTRAINED() { return GetToken(plsqlParser.DSINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode EACH() { return GetToken(plsqlParser.EACH, 0); }
		public ITerminalNode ELEMENT() { return GetToken(plsqlParser.ELEMENT, 0); }
		public ITerminalNode EMPTY() { return GetToken(plsqlParser.EMPTY, 0); }
		public ITerminalNode ENABLE() { return GetToken(plsqlParser.ENABLE, 0); }
		public ITerminalNode ENCODING() { return GetToken(plsqlParser.ENCODING, 0); }
		public ITerminalNode ENTITYESCAPING() { return GetToken(plsqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode ERR() { return GetToken(plsqlParser.ERR, 0); }
		public ITerminalNode ERRORS() { return GetToken(plsqlParser.ERRORS, 0); }
		public ITerminalNode ESCAPE() { return GetToken(plsqlParser.ESCAPE, 0); }
		public ITerminalNode EVALNAME() { return GetToken(plsqlParser.EVALNAME, 0); }
		public ITerminalNode EXCEPTION_INIT() { return GetToken(plsqlParser.EXCEPTION_INIT, 0); }
		public ITerminalNode EXCEPTIONS() { return GetToken(plsqlParser.EXCEPTIONS, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(plsqlParser.EXCLUDE, 0); }
		public ITerminalNode EXECUTE() { return GetToken(plsqlParser.EXECUTE, 0); }
		public ITerminalNode EXIT() { return GetToken(plsqlParser.EXIT, 0); }
		public ITerminalNode EXPLAIN() { return GetToken(plsqlParser.EXPLAIN, 0); }
		public ITerminalNode EXTERNAL() { return GetToken(plsqlParser.EXTERNAL, 0); }
		public ITerminalNode EXTRACT() { return GetToken(plsqlParser.EXTRACT, 0); }
		public ITerminalNode FAILURE() { return GetToken(plsqlParser.FAILURE, 0); }
		public ITerminalNode FINAL() { return GetToken(plsqlParser.FINAL, 0); }
		public ITerminalNode FIRST() { return GetToken(plsqlParser.FIRST, 0); }
		public ITerminalNode FIRST_VALUE() { return GetToken(plsqlParser.FIRST_VALUE, 0); }
		public ITerminalNode FLOAT() { return GetToken(plsqlParser.FLOAT, 0); }
		public ITerminalNode FOLLOWING() { return GetToken(plsqlParser.FOLLOWING, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(plsqlParser.FOLLOWS, 0); }
		public ITerminalNode FORALL() { return GetToken(plsqlParser.FORALL, 0); }
		public ITerminalNode FORCE() { return GetToken(plsqlParser.FORCE, 0); }
		public ITerminalNode FULL() { return GetToken(plsqlParser.FULL, 0); }
		public ITerminalNode FUNCTION() { return GetToken(plsqlParser.FUNCTION, 0); }
		public ITerminalNode GROUPING() { return GetToken(plsqlParser.GROUPING, 0); }
		public ITerminalNode HASH() { return GetToken(plsqlParser.HASH, 0); }
		public ITerminalNode HIDE() { return GetToken(plsqlParser.HIDE, 0); }
		public ITerminalNode HOUR() { return GetToken(plsqlParser.HOUR, 0); }
		public ITerminalNode IGNORE() { return GetToken(plsqlParser.IGNORE, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(plsqlParser.IMMEDIATE, 0); }
		public ITerminalNode INCLUDE() { return GetToken(plsqlParser.INCLUDE, 0); }
		public ITerminalNode INCLUDING() { return GetToken(plsqlParser.INCLUDING, 0); }
		public ITerminalNode INCREMENT() { return GetToken(plsqlParser.INCREMENT, 0); }
		public ITerminalNode INDENT() { return GetToken(plsqlParser.INDENT, 0); }
		public ITerminalNode INDEXED() { return GetToken(plsqlParser.INDEXED, 0); }
		public ITerminalNode INDICATOR() { return GetToken(plsqlParser.INDICATOR, 0); }
		public ITerminalNode INDICES() { return GetToken(plsqlParser.INDICES, 0); }
		public ITerminalNode INFINITE() { return GetToken(plsqlParser.INFINITE, 0); }
		public ITerminalNode INLINE() { return GetToken(plsqlParser.INLINE, 0); }
		public ITerminalNode INNER() { return GetToken(plsqlParser.INNER, 0); }
		public ITerminalNode INOUT() { return GetToken(plsqlParser.INOUT, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(plsqlParser.INSTANTIABLE, 0); }
		public ITerminalNode INSTEAD() { return GetToken(plsqlParser.INSTEAD, 0); }
		public ITerminalNode INT() { return GetToken(plsqlParser.INT, 0); }
		public ITerminalNode INTEGER() { return GetToken(plsqlParser.INTEGER, 0); }
		public ITerminalNode INTERVAL() { return GetToken(plsqlParser.INTERVAL, 0); }
		public ITerminalNode INVALIDATE() { return GetToken(plsqlParser.INVALIDATE, 0); }
		public ITerminalNode ISOLATION() { return GetToken(plsqlParser.ISOLATION, 0); }
		public ITerminalNode ITERATE() { return GetToken(plsqlParser.ITERATE, 0); }
		public ITerminalNode JAVA() { return GetToken(plsqlParser.JAVA, 0); }
		public ITerminalNode JOIN() { return GetToken(plsqlParser.JOIN, 0); }
		public ITerminalNode KEEP() { return GetToken(plsqlParser.KEEP, 0); }
		public ITerminalNode LANGUAGE() { return GetToken(plsqlParser.LANGUAGE, 0); }
		public ITerminalNode LAST() { return GetToken(plsqlParser.LAST, 0); }
		public ITerminalNode LAST_VALUE() { return GetToken(plsqlParser.LAST_VALUE, 0); }
		public ITerminalNode LEADING() { return GetToken(plsqlParser.LEADING, 0); }
		public ITerminalNode LEFT() { return GetToken(plsqlParser.LEFT, 0); }
		public ITerminalNode LEVEL() { return GetToken(plsqlParser.LEVEL, 0); }
		public ITerminalNode LIBRARY() { return GetToken(plsqlParser.LIBRARY, 0); }
		public ITerminalNode LIKE2() { return GetToken(plsqlParser.LIKE2, 0); }
		public ITerminalNode LIKE4() { return GetToken(plsqlParser.LIKE4, 0); }
		public ITerminalNode LIKEC() { return GetToken(plsqlParser.LIKEC, 0); }
		public ITerminalNode LIMIT() { return GetToken(plsqlParser.LIMIT, 0); }
		public ITerminalNode LOCAL() { return GetToken(plsqlParser.LOCAL, 0); }
		public ITerminalNode LOCKED() { return GetToken(plsqlParser.LOCKED, 0); }
		public ITerminalNode LOG() { return GetToken(plsqlParser.LOG, 0); }
		public ITerminalNode LOGOFF() { return GetToken(plsqlParser.LOGOFF, 0); }
		public ITerminalNode LOGON() { return GetToken(plsqlParser.LOGON, 0); }
		public ITerminalNode LONG() { return GetToken(plsqlParser.LONG, 0); }
		public ITerminalNode LOOP() { return GetToken(plsqlParser.LOOP, 0); }
		public ITerminalNode MAIN() { return GetToken(plsqlParser.MAIN, 0); }
		public ITerminalNode MAP() { return GetToken(plsqlParser.MAP, 0); }
		public ITerminalNode MATCHED() { return GetToken(plsqlParser.MATCHED, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(plsqlParser.MAXVALUE, 0); }
		public ITerminalNode MEASURES() { return GetToken(plsqlParser.MEASURES, 0); }
		public ITerminalNode MEMBER() { return GetToken(plsqlParser.MEMBER, 0); }
		public ITerminalNode MERGE() { return GetToken(plsqlParser.MERGE, 0); }
		public ITerminalNode MINUTE() { return GetToken(plsqlParser.MINUTE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(plsqlParser.MINVALUE, 0); }
		public ITerminalNode MLSLABEL() { return GetToken(plsqlParser.MLSLABEL, 0); }
		public ITerminalNode MODEL() { return GetToken(plsqlParser.MODEL, 0); }
		public ITerminalNode MODIFY() { return GetToken(plsqlParser.MODIFY, 0); }
		public ITerminalNode MONTH() { return GetToken(plsqlParser.MONTH, 0); }
		public ITerminalNode MULTISET() { return GetToken(plsqlParser.MULTISET, 0); }
		public ITerminalNode NAME() { return GetToken(plsqlParser.NAME, 0); }
		public ITerminalNode NAN() { return GetToken(plsqlParser.NAN, 0); }
		public ITerminalNode NATURAL() { return GetToken(plsqlParser.NATURAL, 0); }
		public ITerminalNode NATURALN() { return GetToken(plsqlParser.NATURALN, 0); }
		public ITerminalNode NAV() { return GetToken(plsqlParser.NAV, 0); }
		public ITerminalNode NCHAR() { return GetToken(plsqlParser.NCHAR, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(plsqlParser.NCHAR_CS, 0); }
		public ITerminalNode NCLOB() { return GetToken(plsqlParser.NCLOB, 0); }
		public ITerminalNode NESTED() { return GetToken(plsqlParser.NESTED, 0); }
		public ITerminalNode NEW() { return GetToken(plsqlParser.NEW, 0); }
		public ITerminalNode NO() { return GetToken(plsqlParser.NO, 0); }
		public ITerminalNode NOAUDIT() { return GetToken(plsqlParser.NOAUDIT, 0); }
		public ITerminalNode NOCOPY() { return GetToken(plsqlParser.NOCOPY, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(plsqlParser.NOCYCLE, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(plsqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode NONE() { return GetToken(plsqlParser.NONE, 0); }
		public ITerminalNode NOSCHEMACHECK() { return GetToken(plsqlParser.NOSCHEMACHECK, 0); }
		public ITerminalNode NULLS() { return GetToken(plsqlParser.NULLS, 0); }
		public ITerminalNode NUMBER() { return GetToken(plsqlParser.NUMBER, 0); }
		public ITerminalNode NUMERIC() { return GetToken(plsqlParser.NUMERIC, 0); }
		public ITerminalNode NVARCHAR2() { return GetToken(plsqlParser.NVARCHAR2, 0); }
		public ITerminalNode OBJECT() { return GetToken(plsqlParser.OBJECT, 0); }
		public ITerminalNode OFF() { return GetToken(plsqlParser.OFF, 0); }
		public ITerminalNode OID() { return GetToken(plsqlParser.OID, 0); }
		public ITerminalNode OLD() { return GetToken(plsqlParser.OLD, 0); }
		public ITerminalNode ONLY() { return GetToken(plsqlParser.ONLY, 0); }
		public ITerminalNode OPEN() { return GetToken(plsqlParser.OPEN, 0); }
		public ITerminalNode ORADATA() { return GetToken(plsqlParser.ORADATA, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(plsqlParser.ORDINALITY, 0); }
		public ITerminalNode OSERROR() { return GetToken(plsqlParser.OSERROR, 0); }
		public ITerminalNode OUT() { return GetToken(plsqlParser.OUT, 0); }
		public ITerminalNode OUTER() { return GetToken(plsqlParser.OUTER, 0); }
		public ITerminalNode OVER() { return GetToken(plsqlParser.OVER, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(plsqlParser.OVERRIDING, 0); }
		public ITerminalNode PACKAGE() { return GetToken(plsqlParser.PACKAGE, 0); }
		public ITerminalNode PARALLEL_ENABLE() { return GetToken(plsqlParser.PARALLEL_ENABLE, 0); }
		public ITerminalNode PARAMETERS() { return GetToken(plsqlParser.PARAMETERS, 0); }
		public ITerminalNode PARENT() { return GetToken(plsqlParser.PARENT, 0); }
		public ITerminalNode PARTITION() { return GetToken(plsqlParser.PARTITION, 0); }
		public ITerminalNode PASSING() { return GetToken(plsqlParser.PASSING, 0); }
		public ITerminalNode PATH() { return GetToken(plsqlParser.PATH, 0); }
		public ITerminalNode PIPELINED() { return GetToken(plsqlParser.PIPELINED, 0); }
		public ITerminalNode PLAN() { return GetToken(plsqlParser.PLAN, 0); }
		public ITerminalNode PLS_INTEGER() { return GetToken(plsqlParser.PLS_INTEGER, 0); }
		public ITerminalNode POSITIVE() { return GetToken(plsqlParser.POSITIVE, 0); }
		public ITerminalNode POSITIVEN() { return GetToken(plsqlParser.POSITIVEN, 0); }
		public ITerminalNode PRAGMA() { return GetToken(plsqlParser.PRAGMA, 0); }
		public ITerminalNode PRECEDING() { return GetToken(plsqlParser.PRECEDING, 0); }
		public ITerminalNode PRECISION() { return GetToken(plsqlParser.PRECISION, 0); }
		public ITerminalNode PRESENT() { return GetToken(plsqlParser.PRESENT, 0); }
		public ITerminalNode RAISE() { return GetToken(plsqlParser.RAISE, 0); }
		public ITerminalNode RANGE() { return GetToken(plsqlParser.RANGE, 0); }
		public ITerminalNode RAW() { return GetToken(plsqlParser.RAW, 0); }
		public ITerminalNode READ() { return GetToken(plsqlParser.READ, 0); }
		public ITerminalNode REAL() { return GetToken(plsqlParser.REAL, 0); }
		public ITerminalNode RECORD() { return GetToken(plsqlParser.RECORD, 0); }
		public ITerminalNode REF() { return GetToken(plsqlParser.REF, 0); }
		public ITerminalNode REFERENCE() { return GetToken(plsqlParser.REFERENCE, 0); }
		public ITerminalNode REFERENCING() { return GetToken(plsqlParser.REFERENCING, 0); }
		public ITerminalNode REJECT() { return GetToken(plsqlParser.REJECT, 0); }
		public ITerminalNode RELIES_ON() { return GetToken(plsqlParser.RELIES_ON, 0); }
		public ITerminalNode RENAME() { return GetToken(plsqlParser.RENAME, 0); }
		public ITerminalNode REPLACE() { return GetToken(plsqlParser.REPLACE, 0); }
		public ITerminalNode RESPECT() { return GetToken(plsqlParser.RESPECT, 0); }
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(plsqlParser.RESTRICT_REFERENCES, 0); }
		public ITerminalNode RESULT() { return GetToken(plsqlParser.RESULT, 0); }
		public ITerminalNode RESULT_CACHE() { return GetToken(plsqlParser.RESULT_CACHE, 0); }
		public ITerminalNode RETURN() { return GetToken(plsqlParser.RETURN, 0); }
		public ITerminalNode RETURNING() { return GetToken(plsqlParser.RETURNING, 0); }
		public ITerminalNode REUSE() { return GetToken(plsqlParser.REUSE, 0); }
		public ITerminalNode REVERSE() { return GetToken(plsqlParser.REVERSE, 0); }
		public ITerminalNode RIGHT() { return GetToken(plsqlParser.RIGHT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(plsqlParser.ROLLBACK, 0); }
		public ITerminalNode ROLLUP() { return GetToken(plsqlParser.ROLLUP, 0); }
		public ITerminalNode ROW() { return GetToken(plsqlParser.ROW, 0); }
		public ITerminalNode ROWID() { return GetToken(plsqlParser.ROWID, 0); }
		public ITerminalNode ROWS() { return GetToken(plsqlParser.ROWS, 0); }
		public ITerminalNode RULES() { return GetToken(plsqlParser.RULES, 0); }
		public ITerminalNode SAMPLE() { return GetToken(plsqlParser.SAMPLE, 0); }
		public ITerminalNode SAVE() { return GetToken(plsqlParser.SAVE, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(plsqlParser.SAVEPOINT, 0); }
		public ITerminalNode SCHEMA() { return GetToken(plsqlParser.SCHEMA, 0); }
		public ITerminalNode SCHEMACHECK() { return GetToken(plsqlParser.SCHEMACHECK, 0); }
		public ITerminalNode SCN() { return GetToken(plsqlParser.SCN, 0); }
		public ITerminalNode SECOND() { return GetToken(plsqlParser.SECOND, 0); }
		public ITerminalNode SEED() { return GetToken(plsqlParser.SEED, 0); }
		public ITerminalNode SEGMENT() { return GetToken(plsqlParser.SEGMENT, 0); }
		public ITerminalNode SELF() { return GetToken(plsqlParser.SELF, 0); }
		public ITerminalNode SEQUENTIAL() { return GetToken(plsqlParser.SEQUENTIAL, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(plsqlParser.SERIALIZABLE, 0); }
		public ITerminalNode SERIALLY_REUSABLE() { return GetToken(plsqlParser.SERIALLY_REUSABLE, 0); }
		public ITerminalNode SERVERERROR() { return GetToken(plsqlParser.SERVERERROR, 0); }
		public ITerminalNode SESSIONTIMEZONE() { return GetToken(plsqlParser.SESSIONTIMEZONE, 0); }
		public ITerminalNode SET() { return GetToken(plsqlParser.SET, 0); }
		public ITerminalNode SETS() { return GetToken(plsqlParser.SETS, 0); }
		public ITerminalNode SETTINGS() { return GetToken(plsqlParser.SETTINGS, 0); }
		public ITerminalNode SHOW() { return GetToken(plsqlParser.SHOW, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(plsqlParser.SHUTDOWN, 0); }
		public ITerminalNode SIBLINGS() { return GetToken(plsqlParser.SIBLINGS, 0); }
		public ITerminalNode SIGNTYPE() { return GetToken(plsqlParser.SIGNTYPE, 0); }
		public ITerminalNode SIMPLE_INTEGER() { return GetToken(plsqlParser.SIMPLE_INTEGER, 0); }
		public ITerminalNode SINGLE() { return GetToken(plsqlParser.SINGLE, 0); }
		public ITerminalNode SKIP_() { return GetToken(plsqlParser.SKIP_, 0); }
		public ITerminalNode SMALLINT() { return GetToken(plsqlParser.SMALLINT, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(plsqlParser.SNAPSHOT, 0); }
		public ITerminalNode SOME() { return GetToken(plsqlParser.SOME, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(plsqlParser.SPECIFICATION, 0); }
		public ITerminalNode SQLDATA() { return GetToken(plsqlParser.SQLDATA, 0); }
		public ITerminalNode SQLERROR() { return GetToken(plsqlParser.SQLERROR, 0); }
		public ITerminalNode STANDALONE() { return GetToken(plsqlParser.STANDALONE, 0); }
		public ITerminalNode STARTUP() { return GetToken(plsqlParser.STARTUP, 0); }
		public ITerminalNode STATEMENT() { return GetToken(plsqlParser.STATEMENT, 0); }
		public ITerminalNode STATEMENT_ID() { return GetToken(plsqlParser.STATEMENT_ID, 0); }
		public ITerminalNode STATIC() { return GetToken(plsqlParser.STATIC, 0); }
		public ITerminalNode STATISTICS() { return GetToken(plsqlParser.STATISTICS, 0); }
		public ITerminalNode STRING() { return GetToken(plsqlParser.STRING, 0); }
		public ITerminalNode SUBMULTISET() { return GetToken(plsqlParser.SUBMULTISET, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(plsqlParser.SUBPARTITION, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(plsqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode SUBTYPE() { return GetToken(plsqlParser.SUBTYPE, 0); }
		public ITerminalNode SUCCESS() { return GetToken(plsqlParser.SUCCESS, 0); }
		public ITerminalNode SUSPEND() { return GetToken(plsqlParser.SUSPEND, 0); }
		public ITerminalNode TIME() { return GetToken(plsqlParser.TIME, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(plsqlParser.TIMESTAMP, 0); }
		public ITerminalNode TIMESTAMP_LTZ_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_TZ_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_UNCONSTRAINED() { return GetToken(plsqlParser.TIMESTAMP_UNCONSTRAINED, 0); }
		public ITerminalNode TIMEZONE_ABBR() { return GetToken(plsqlParser.TIMEZONE_ABBR, 0); }
		public ITerminalNode TIMEZONE_HOUR() { return GetToken(plsqlParser.TIMEZONE_HOUR, 0); }
		public ITerminalNode TIMEZONE_MINUTE() { return GetToken(plsqlParser.TIMEZONE_MINUTE, 0); }
		public ITerminalNode TIMEZONE_REGION() { return GetToken(plsqlParser.TIMEZONE_REGION, 0); }
		public ITerminalNode TRAILING() { return GetToken(plsqlParser.TRAILING, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(plsqlParser.TRANSACTION, 0); }
		public ITerminalNode TRANSLATE() { return GetToken(plsqlParser.TRANSLATE, 0); }
		public ITerminalNode TREAT() { return GetToken(plsqlParser.TREAT, 0); }
		public ITerminalNode TRIGGER() { return GetToken(plsqlParser.TRIGGER, 0); }
		public ITerminalNode TRIM() { return GetToken(plsqlParser.TRIM, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(plsqlParser.TRUNCATE, 0); }
		public ITerminalNode TYPE() { return GetToken(plsqlParser.TYPE, 0); }
		public ITerminalNode UNBOUNDED() { return GetToken(plsqlParser.UNBOUNDED, 0); }
		public ITerminalNode UNDER() { return GetToken(plsqlParser.UNDER, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(plsqlParser.UNLIMITED, 0); }
		public ITerminalNode UNTIL() { return GetToken(plsqlParser.UNTIL, 0); }
		public ITerminalNode UPDATED() { return GetToken(plsqlParser.UPDATED, 0); }
		public ITerminalNode UPSERT() { return GetToken(plsqlParser.UPSERT, 0); }
		public ITerminalNode UROWID() { return GetToken(plsqlParser.UROWID, 0); }
		public ITerminalNode USE() { return GetToken(plsqlParser.USE, 0); }
		public ITerminalNode VALIDATE() { return GetToken(plsqlParser.VALIDATE, 0); }
		public ITerminalNode VALUE() { return GetToken(plsqlParser.VALUE, 0); }
		public ITerminalNode VARCHAR() { return GetToken(plsqlParser.VARCHAR, 0); }
		public ITerminalNode VARCHAR2() { return GetToken(plsqlParser.VARCHAR2, 0); }
		public ITerminalNode VARIABLE() { return GetToken(plsqlParser.VARIABLE, 0); }
		public ITerminalNode VARRAY() { return GetToken(plsqlParser.VARRAY, 0); }
		public ITerminalNode VARYING() { return GetToken(plsqlParser.VARYING, 0); }
		public ITerminalNode VERSION() { return GetToken(plsqlParser.VERSION, 0); }
		public ITerminalNode VERSIONS() { return GetToken(plsqlParser.VERSIONS, 0); }
		public ITerminalNode WAIT() { return GetToken(plsqlParser.WAIT, 0); }
		public ITerminalNode WARNING() { return GetToken(plsqlParser.WARNING, 0); }
		public ITerminalNode WELLFORMED() { return GetToken(plsqlParser.WELLFORMED, 0); }
		public ITerminalNode WHENEVER() { return GetToken(plsqlParser.WHENEVER, 0); }
		public ITerminalNode WHILE() { return GetToken(plsqlParser.WHILE, 0); }
		public ITerminalNode WITHIN() { return GetToken(plsqlParser.WITHIN, 0); }
		public ITerminalNode WORK() { return GetToken(plsqlParser.WORK, 0); }
		public ITerminalNode WRITE() { return GetToken(plsqlParser.WRITE, 0); }
		public ITerminalNode XML() { return GetToken(plsqlParser.XML, 0); }
		public ITerminalNode XMLAGG() { return GetToken(plsqlParser.XMLAGG, 0); }
		public ITerminalNode XMLATTRIBUTES() { return GetToken(plsqlParser.XMLATTRIBUTES, 0); }
		public ITerminalNode XMLCAST() { return GetToken(plsqlParser.XMLCAST, 0); }
		public ITerminalNode XMLCOLATTVAL() { return GetToken(plsqlParser.XMLCOLATTVAL, 0); }
		public ITerminalNode XMLELEMENT() { return GetToken(plsqlParser.XMLELEMENT, 0); }
		public ITerminalNode XMLEXISTS() { return GetToken(plsqlParser.XMLEXISTS, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(plsqlParser.XMLFOREST, 0); }
		public ITerminalNode XMLNAMESPACES() { return GetToken(plsqlParser.XMLNAMESPACES, 0); }
		public ITerminalNode XMLPARSE() { return GetToken(plsqlParser.XMLPARSE, 0); }
		public ITerminalNode XMLPI() { return GetToken(plsqlParser.XMLPI, 0); }
		public ITerminalNode XMLQUERY() { return GetToken(plsqlParser.XMLQUERY, 0); }
		public ITerminalNode XMLROOT() { return GetToken(plsqlParser.XMLROOT, 0); }
		public ITerminalNode XMLSERIALIZE() { return GetToken(plsqlParser.XMLSERIALIZE, 0); }
		public ITerminalNode XMLTABLE() { return GetToken(plsqlParser.XMLTABLE, 0); }
		public ITerminalNode YEAR() { return GetToken(plsqlParser.YEAR, 0); }
		public ITerminalNode YES() { return GetToken(plsqlParser.YES, 0); }
		public ITerminalNode YMINTERVAL_UNCONSTRAINED() { return GetToken(plsqlParser.YMINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode ZONE() { return GetToken(plsqlParser.ZONE, 0); }
		public ITerminalNode PREDICTION() { return GetToken(plsqlParser.PREDICTION, 0); }
		public ITerminalNode PREDICTION_BOUNDS() { return GetToken(plsqlParser.PREDICTION_BOUNDS, 0); }
		public ITerminalNode PREDICTION_COST() { return GetToken(plsqlParser.PREDICTION_COST, 0); }
		public ITerminalNode PREDICTION_DETAILS() { return GetToken(plsqlParser.PREDICTION_DETAILS, 0); }
		public ITerminalNode PREDICTION_PROBABILITY() { return GetToken(plsqlParser.PREDICTION_PROBABILITY, 0); }
		public ITerminalNode PREDICTION_SET() { return GetToken(plsqlParser.PREDICTION_SET, 0); }
		public ITerminalNode CUME_DIST() { return GetToken(plsqlParser.CUME_DIST, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(plsqlParser.DENSE_RANK, 0); }
		public ITerminalNode LISTAGG() { return GetToken(plsqlParser.LISTAGG, 0); }
		public ITerminalNode PERCENT_RANK() { return GetToken(plsqlParser.PERCENT_RANK, 0); }
		public ITerminalNode PERCENTILE_CONT() { return GetToken(plsqlParser.PERCENTILE_CONT, 0); }
		public ITerminalNode PERCENTILE_DISC() { return GetToken(plsqlParser.PERCENTILE_DISC, 0); }
		public ITerminalNode RANK() { return GetToken(plsqlParser.RANK, 0); }
		public ITerminalNode AVG() { return GetToken(plsqlParser.AVG, 0); }
		public ITerminalNode CORR() { return GetToken(plsqlParser.CORR, 0); }
		public ITerminalNode LAG() { return GetToken(plsqlParser.LAG, 0); }
		public ITerminalNode LEAD() { return GetToken(plsqlParser.LEAD, 0); }
		public ITerminalNode MAX() { return GetToken(plsqlParser.MAX, 0); }
		public ITerminalNode MEDIAN() { return GetToken(plsqlParser.MEDIAN, 0); }
		public ITerminalNode MIN() { return GetToken(plsqlParser.MIN, 0); }
		public ITerminalNode NTILE() { return GetToken(plsqlParser.NTILE, 0); }
		public ITerminalNode RATIO_TO_REPORT() { return GetToken(plsqlParser.RATIO_TO_REPORT, 0); }
		public ITerminalNode ROW_NUMBER() { return GetToken(plsqlParser.ROW_NUMBER, 0); }
		public ITerminalNode SUM() { return GetToken(plsqlParser.SUM, 0); }
		public ITerminalNode VARIANCE() { return GetToken(plsqlParser.VARIANCE, 0); }
		public ITerminalNode REGR_() { return GetToken(plsqlParser.REGR_, 0); }
		public ITerminalNode STDDEV() { return GetToken(plsqlParser.STDDEV, 0); }
		public ITerminalNode VAR_() { return GetToken(plsqlParser.VAR_, 0); }
		public ITerminalNode COVAR_() { return GetToken(plsqlParser.COVAR_, 0); }
		public Regular_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regular_id; } }
		public override void EnterRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.EnterRegular_id(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IplsqlListener typedListener = listener as IplsqlListener;
			if (typedListener != null) typedListener.ExitRegular_id(this);
		}
	}

	[RuleVersion(0)]
	public Regular_idContext regular_id() {
		Regular_idContext _localctx = new Regular_idContext(Context, State);
		EnterRule(_localctx, 758, RULE_regular_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5275;
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ANALYZE) | (1L << ARRAY) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BULK) | (1L << BYTE) | (1L << C_LETTER) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS) | (1L << COMMENT) | (1L << COMMIT) | (1L << COMMITTED) | (1L << COMPATIBILITY) | (1L << COMPILE) | (1L << COMPOUND))) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & ((1L << (CONSTANT - 65)) | (1L << (CONSTRAINT - 65)) | (1L << (CONSTRAINTS - 65)) | (1L << (CONSTRUCTOR - 65)) | (1L << (CONTENT - 65)) | (1L << (CONTEXT - 65)) | (1L << (CONTINUE - 65)) | (1L << (CONVERT - 65)) | (1L << (CORRUPT_XID - 65)) | (1L << (CORRUPT_XID_ALL - 65)) | (1L << (COST - 65)) | (1L << (COUNT - 65)) | (1L << (CROSS - 65)) | (1L << (CUBE - 65)) | (1L << (CURRENT_USER - 65)) | (1L << (CURSOR - 65)) | (1L << (CUSTOMDATUM - 65)) | (1L << (CYCLE - 65)) | (1L << (DATA - 65)) | (1L << (DATABASE - 65)) | (1L << (DAY - 65)) | (1L << (DB_ROLE_CHANGE - 65)) | (1L << (DBTIMEZONE - 65)) | (1L << (DDL - 65)) | (1L << (DEBUG - 65)) | (1L << (DEC - 65)) | (1L << (DECIMAL - 65)) | (1L << (DECOMPOSE - 65)) | (1L << (DECREMENT - 65)) | (1L << (DEFAULTS - 65)) | (1L << (DEFERRED - 65)) | (1L << (DEFINER - 65)) | (1L << (DETERMINISTIC - 65)) | (1L << (DIMENSION - 65)) | (1L << (DISABLE - 65)) | (1L << (DISASSOCIATE - 65)) | (1L << (DOCUMENT - 65)) | (1L << (DOUBLE - 65)) | (1L << (DSINTERVAL_UNCONSTRAINED - 65)) | (1L << (EACH - 65)) | (1L << (ELEMENT - 65)) | (1L << (EMPTY - 65)) | (1L << (ENABLE - 65)) | (1L << (ENCODING - 65)) | (1L << (ENTITYESCAPING - 65)) | (1L << (ERR - 65)) | (1L << (ERRORS - 65)) | (1L << (ESCAPE - 65)) | (1L << (EVALNAME - 65)) | (1L << (EXCEPTION_INIT - 65)))) != 0) || ((((_la - 129)) & ~0x3f) == 0 && ((1L << (_la - 129)) & ((1L << (EXCEPTIONS - 129)) | (1L << (EXCLUDE - 129)) | (1L << (EXECUTE - 129)) | (1L << (EXIT - 129)) | (1L << (EXPLAIN - 129)) | (1L << (EXTERNAL - 129)) | (1L << (EXTRACT - 129)) | (1L << (FAILURE - 129)) | (1L << (FINAL - 129)) | (1L << (FIRST - 129)) | (1L << (FIRST_VALUE - 129)) | (1L << (FLOAT - 129)) | (1L << (FOLLOWING - 129)) | (1L << (FOLLOWS - 129)) | (1L << (FORALL - 129)) | (1L << (FORCE - 129)) | (1L << (FULL - 129)) | (1L << (FUNCTION - 129)) | (1L << (GROUPING - 129)) | (1L << (HASH - 129)) | (1L << (HIDE - 129)) | (1L << (HOUR - 129)) | (1L << (IGNORE - 129)) | (1L << (IMMEDIATE - 129)) | (1L << (INCLUDE - 129)) | (1L << (INCLUDING - 129)) | (1L << (INCREMENT - 129)) | (1L << (INDENT - 129)) | (1L << (INDEXED - 129)) | (1L << (INDICATOR - 129)) | (1L << (INDICES - 129)) | (1L << (INFINITE - 129)) | (1L << (INLINE - 129)) | (1L << (INNER - 129)) | (1L << (INOUT - 129)) | (1L << (INSTANTIABLE - 129)) | (1L << (INSTEAD - 129)) | (1L << (INT - 129)) | (1L << (INTEGER - 129)) | (1L << (INTERVAL - 129)) | (1L << (INVALIDATE - 129)) | (1L << (ISOLATION - 129)) | (1L << (ITERATE - 129)) | (1L << (JAVA - 129)) | (1L << (JOIN - 129)) | (1L << (KEEP - 129)) | (1L << (LANGUAGE - 129)))) != 0) || ((((_la - 193)) & ~0x3f) == 0 && ((1L << (_la - 193)) & ((1L << (LAST - 193)) | (1L << (LAST_VALUE - 193)) | (1L << (LEADING - 193)) | (1L << (LEFT - 193)) | (1L << (LEVEL - 193)) | (1L << (LIBRARY - 193)) | (1L << (LIKE2 - 193)) | (1L << (LIKE4 - 193)) | (1L << (LIKEC - 193)) | (1L << (LIMIT - 193)) | (1L << (LOCAL - 193)) | (1L << (LOCKED - 193)) | (1L << (LOG - 193)) | (1L << (LOGOFF - 193)) | (1L << (LOGON - 193)) | (1L << (LONG - 193)) | (1L << (LOOP - 193)) | (1L << (MAIN - 193)) | (1L << (MAP - 193)) | (1L << (MATCHED - 193)) | (1L << (MAXVALUE - 193)) | (1L << (MEASURES - 193)) | (1L << (MEMBER - 193)) | (1L << (MERGE - 193)) | (1L << (MINUTE - 193)) | (1L << (MINVALUE - 193)) | (1L << (MLSLABEL - 193)) | (1L << (MODEL - 193)) | (1L << (MODIFY - 193)) | (1L << (MONTH - 193)) | (1L << (MULTISET - 193)) | (1L << (NAME - 193)) | (1L << (NAN - 193)) | (1L << (NATURAL - 193)) | (1L << (NATURALN - 193)) | (1L << (NAV - 193)) | (1L << (NCHAR - 193)) | (1L << (NCHAR_CS - 193)) | (1L << (NCLOB - 193)) | (1L << (NESTED - 193)) | (1L << (NEW - 193)) | (1L << (NO - 193)) | (1L << (NOAUDIT - 193)) | (1L << (NOCOPY - 193)) | (1L << (NOCYCLE - 193)) | (1L << (NOENTITYESCAPING - 193)) | (1L << (NONE - 193)) | (1L << (NOSCHEMACHECK - 193)) | (1L << (NULLS - 193)) | (1L << (NUMBER - 193)) | (1L << (NUMERIC - 193)) | (1L << (NVARCHAR2 - 193)) | (1L << (OBJECT - 193)))) != 0) || ((((_la - 258)) & ~0x3f) == 0 && ((1L << (_la - 258)) & ((1L << (OFF - 258)) | (1L << (OID - 258)) | (1L << (OLD - 258)) | (1L << (ONLY - 258)) | (1L << (OPEN - 258)) | (1L << (ORADATA - 258)) | (1L << (ORDINALITY - 258)) | (1L << (OSERROR - 258)) | (1L << (OUT - 258)) | (1L << (OUTER - 258)) | (1L << (OVER - 258)) | (1L << (OVERRIDING - 258)) | (1L << (PACKAGE - 258)) | (1L << (PARALLEL_ENABLE - 258)) | (1L << (PARAMETERS - 258)) | (1L << (PARENT - 258)) | (1L << (PARTITION - 258)) | (1L << (PASSING - 258)) | (1L << (PATH - 258)) | (1L << (PIPELINED - 258)) | (1L << (PLAN - 258)) | (1L << (PLS_INTEGER - 258)) | (1L << (POSITIVE - 258)) | (1L << (POSITIVEN - 258)) | (1L << (PRAGMA - 258)) | (1L << (PRECEDING - 258)) | (1L << (PRECISION - 258)) | (1L << (PRESENT - 258)) | (1L << (RAISE - 258)) | (1L << (RANGE - 258)) | (1L << (RAW - 258)) | (1L << (READ - 258)) | (1L << (REAL - 258)) | (1L << (RECORD - 258)) | (1L << (REF - 258)) | (1L << (REFERENCE - 258)) | (1L << (REFERENCING - 258)) | (1L << (REJECT - 258)) | (1L << (RELIES_ON - 258)) | (1L << (RENAME - 258)) | (1L << (REPLACE - 258)) | (1L << (RESPECT - 258)) | (1L << (RESTRICT_REFERENCES - 258)) | (1L << (RESULT - 258)) | (1L << (RESULT_CACHE - 258)) | (1L << (RETURN - 258)) | (1L << (RETURNING - 258)) | (1L << (REUSE - 258)) | (1L << (REVERSE - 258)) | (1L << (RIGHT - 258)) | (1L << (ROLLBACK - 258)) | (1L << (ROLLUP - 258)) | (1L << (ROW - 258)) | (1L << (ROWID - 258)))) != 0) || ((((_la - 322)) & ~0x3f) == 0 && ((1L << (_la - 322)) & ((1L << (ROWS - 322)) | (1L << (RULES - 322)) | (1L << (SAMPLE - 322)) | (1L << (SAVE - 322)) | (1L << (SAVEPOINT - 322)) | (1L << (SCHEMA - 322)) | (1L << (SCHEMACHECK - 322)) | (1L << (SCN - 322)) | (1L << (SECOND - 322)) | (1L << (SEED - 322)) | (1L << (SEGMENT - 322)) | (1L << (SELF - 322)) | (1L << (SEQUENTIAL - 322)) | (1L << (SERIALIZABLE - 322)) | (1L << (SERIALLY_REUSABLE - 322)) | (1L << (SERVERERROR - 322)) | (1L << (SESSIONTIMEZONE - 322)) | (1L << (SET - 322)) | (1L << (SETS - 322)) | (1L << (SETTINGS - 322)) | (1L << (SHOW - 322)) | (1L << (SHUTDOWN - 322)) | (1L << (SIBLINGS - 322)) | (1L << (SIGNTYPE - 322)) | (1L << (SIMPLE_INTEGER - 322)) | (1L << (SINGLE - 322)) | (1L << (SKIP_ - 322)) | (1L << (SMALLINT - 322)) | (1L << (SNAPSHOT - 322)) | (1L << (SOME - 322)) | (1L << (SPECIFICATION - 322)) | (1L << (SQLDATA - 322)) | (1L << (SQLERROR - 322)) | (1L << (STANDALONE - 322)) | (1L << (STARTUP - 322)) | (1L << (STATEMENT - 322)) | (1L << (STATEMENT_ID - 322)) | (1L << (STATIC - 322)) | (1L << (STATISTICS - 322)) | (1L << (STRING - 322)) | (1L << (SUBMULTISET - 322)) | (1L << (SUBPARTITION - 322)) | (1L << (SUBSTITUTABLE - 322)) | (1L << (SUBTYPE - 322)) | (1L << (SUCCESS - 322)) | (1L << (SUSPEND - 322)) | (1L << (TIME - 322)) | (1L << (TIMESTAMP - 322)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 322)) | (1L << (TIMESTAMP_UNCONSTRAINED - 322)) | (1L << (TIMEZONE_ABBR - 322)) | (1L << (TIMEZONE_HOUR - 322)) | (1L << (TIMEZONE_MINUTE - 322)) | (1L << (TIMEZONE_REGION - 322)))) != 0) || ((((_la - 387)) & ~0x3f) == 0 && ((1L << (_la - 387)) & ((1L << (TRAILING - 387)) | (1L << (TRANSACTION - 387)) | (1L << (TRANSLATE - 387)) | (1L << (TREAT - 387)) | (1L << (TRIGGER - 387)) | (1L << (TRIM - 387)) | (1L << (TRUNCATE - 387)) | (1L << (TYPE - 387)) | (1L << (UNBOUNDED - 387)) | (1L << (UNDER - 387)) | (1L << (UNLIMITED - 387)) | (1L << (UNTIL - 387)) | (1L << (UPDATED - 387)) | (1L << (UPSERT - 387)) | (1L << (UROWID - 387)) | (1L << (USE - 387)) | (1L << (VALIDATE - 387)) | (1L << (VALUE - 387)) | (1L << (VARCHAR - 387)) | (1L << (VARCHAR2 - 387)) | (1L << (VARIABLE - 387)) | (1L << (VARRAY - 387)) | (1L << (VARYING - 387)) | (1L << (VERSION - 387)) | (1L << (VERSIONS - 387)) | (1L << (WAIT - 387)) | (1L << (WARNING - 387)) | (1L << (WELLFORMED - 387)) | (1L << (WHENEVER - 387)) | (1L << (WHILE - 387)) | (1L << (WITHIN - 387)) | (1L << (WORK - 387)) | (1L << (WRITE - 387)) | (1L << (XML - 387)) | (1L << (XMLAGG - 387)) | (1L << (XMLATTRIBUTES - 387)) | (1L << (XMLCAST - 387)) | (1L << (XMLCOLATTVAL - 387)) | (1L << (XMLELEMENT - 387)) | (1L << (XMLEXISTS - 387)) | (1L << (XMLFOREST - 387)) | (1L << (XMLNAMESPACES - 387)) | (1L << (XMLPARSE - 387)) | (1L << (XMLPI - 387)) | (1L << (XMLQUERY - 387)) | (1L << (XMLROOT - 387)) | (1L << (XMLSERIALIZE - 387)) | (1L << (XMLTABLE - 387)) | (1L << (YEAR - 387)) | (1L << (YES - 387)) | (1L << (YMINTERVAL_UNCONSTRAINED - 387)) | (1L << (ZONE - 387)) | (1L << (PREDICTION - 387)) | (1L << (PREDICTION_BOUNDS - 387)))) != 0) || ((((_la - 451)) & ~0x3f) == 0 && ((1L << (_la - 451)) & ((1L << (PREDICTION_COST - 451)) | (1L << (PREDICTION_DETAILS - 451)) | (1L << (PREDICTION_PROBABILITY - 451)) | (1L << (PREDICTION_SET - 451)) | (1L << (CUME_DIST - 451)) | (1L << (DENSE_RANK - 451)) | (1L << (LISTAGG - 451)) | (1L << (PERCENT_RANK - 451)) | (1L << (PERCENTILE_CONT - 451)) | (1L << (PERCENTILE_DISC - 451)) | (1L << (RANK - 451)) | (1L << (AVG - 451)) | (1L << (CORR - 451)) | (1L << (LAG - 451)) | (1L << (LEAD - 451)) | (1L << (MAX - 451)) | (1L << (MEDIAN - 451)) | (1L << (MIN - 451)) | (1L << (NTILE - 451)) | (1L << (RATIO_TO_REPORT - 451)) | (1L << (ROW_NUMBER - 451)) | (1L << (SUM - 451)) | (1L << (VARIANCE - 451)) | (1L << (REGR_ - 451)) | (1L << (STDDEV - 451)) | (1L << (VAR_ - 451)) | (1L << (COVAR_ - 451)))) != 0) || _la==REGULAR_ID) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x267");
		sb.Append("\x14A0\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6");
		sb.Append("\x4\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r");
		sb.Append("\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12");
		sb.Append("\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4");
		sb.Append("\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B\t\x1B");
		sb.Append("\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t ");
		sb.Append("\x4!\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t");
		sb.Append("(\x4)\t)\x4*\t*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t");
		sb.Append("\x30\x4\x31\t\x31\x4\x32\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4");
		sb.Append("\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37\x4\x38\t\x38\x4\x39\t\x39");
		sb.Append("\x4:\t:\x4;\t;\x4<\t<\x4=\t=\x4>\t>\x4?\t?\x4@\t@\x4\x41\t\x41");
		sb.Append("\x4\x42\t\x42\x4\x43\t\x43\x4\x44\t\x44\x4\x45\t\x45\x4\x46");
		sb.Append("\t\x46\x4G\tG\x4H\tH\x4I\tI\x4J\tJ\x4K\tK\x4L\tL\x4M\tM\x4N");
		sb.Append("\tN\x4O\tO\x4P\tP\x4Q\tQ\x4R\tR\x4S\tS\x4T\tT\x4U\tU\x4V\tV");
		sb.Append("\x4W\tW\x4X\tX\x4Y\tY\x4Z\tZ\x4[\t[\x4\\\t\\\x4]\t]\x4^\t^\x4");
		sb.Append("_\t_\x4`\t`\x4\x61\t\x61\x4\x62\t\x62\x4\x63\t\x63\x4\x64\t");
		sb.Append("\x64\x4\x65\t\x65\x4\x66\t\x66\x4g\tg\x4h\th\x4i\ti\x4j\tj\x4");
		sb.Append("k\tk\x4l\tl\x4m\tm\x4n\tn\x4o\to\x4p\tp\x4q\tq\x4r\tr\x4s\t");
		sb.Append("s\x4t\tt\x4u\tu\x4v\tv\x4w\tw\x4x\tx\x4y\ty\x4z\tz\x4{\t{\x4");
		sb.Append("|\t|\x4}\t}\x4~\t~\x4\x7F\t\x7F\x4\x80\t\x80\x4\x81\t\x81\x4");
		sb.Append("\x82\t\x82\x4\x83\t\x83\x4\x84\t\x84\x4\x85\t\x85\x4\x86\t\x86");
		sb.Append("\x4\x87\t\x87\x4\x88\t\x88\x4\x89\t\x89\x4\x8A\t\x8A\x4\x8B");
		sb.Append("\t\x8B\x4\x8C\t\x8C\x4\x8D\t\x8D\x4\x8E\t\x8E\x4\x8F\t\x8F\x4");
		sb.Append("\x90\t\x90\x4\x91\t\x91\x4\x92\t\x92\x4\x93\t\x93\x4\x94\t\x94");
		sb.Append("\x4\x95\t\x95\x4\x96\t\x96\x4\x97\t\x97\x4\x98\t\x98\x4\x99");
		sb.Append("\t\x99\x4\x9A\t\x9A\x4\x9B\t\x9B\x4\x9C\t\x9C\x4\x9D\t\x9D\x4");
		sb.Append("\x9E\t\x9E\x4\x9F\t\x9F\x4\xA0\t\xA0\x4\xA1\t\xA1\x4\xA2\t\xA2");
		sb.Append("\x4\xA3\t\xA3\x4\xA4\t\xA4\x4\xA5\t\xA5\x4\xA6\t\xA6\x4\xA7");
		sb.Append("\t\xA7\x4\xA8\t\xA8\x4\xA9\t\xA9\x4\xAA\t\xAA\x4\xAB\t\xAB\x4");
		sb.Append("\xAC\t\xAC\x4\xAD\t\xAD\x4\xAE\t\xAE\x4\xAF\t\xAF\x4\xB0\t\xB0");
		sb.Append("\x4\xB1\t\xB1\x4\xB2\t\xB2\x4\xB3\t\xB3\x4\xB4\t\xB4\x4\xB5");
		sb.Append("\t\xB5\x4\xB6\t\xB6\x4\xB7\t\xB7\x4\xB8\t\xB8\x4\xB9\t\xB9\x4");
		sb.Append("\xBA\t\xBA\x4\xBB\t\xBB\x4\xBC\t\xBC\x4\xBD\t\xBD\x4\xBE\t\xBE");
		sb.Append("\x4\xBF\t\xBF\x4\xC0\t\xC0\x4\xC1\t\xC1\x4\xC2\t\xC2\x4\xC3");
		sb.Append("\t\xC3\x4\xC4\t\xC4\x4\xC5\t\xC5\x4\xC6\t\xC6\x4\xC7\t\xC7\x4");
		sb.Append("\xC8\t\xC8\x4\xC9\t\xC9\x4\xCA\t\xCA\x4\xCB\t\xCB\x4\xCC\t\xCC");
		sb.Append("\x4\xCD\t\xCD\x4\xCE\t\xCE\x4\xCF\t\xCF\x4\xD0\t\xD0\x4\xD1");
		sb.Append("\t\xD1\x4\xD2\t\xD2\x4\xD3\t\xD3\x4\xD4\t\xD4\x4\xD5\t\xD5\x4");
		sb.Append("\xD6\t\xD6\x4\xD7\t\xD7\x4\xD8\t\xD8\x4\xD9\t\xD9\x4\xDA\t\xDA");
		sb.Append("\x4\xDB\t\xDB\x4\xDC\t\xDC\x4\xDD\t\xDD\x4\xDE\t\xDE\x4\xDF");
		sb.Append("\t\xDF\x4\xE0\t\xE0\x4\xE1\t\xE1\x4\xE2\t\xE2\x4\xE3\t\xE3\x4");
		sb.Append("\xE4\t\xE4\x4\xE5\t\xE5\x4\xE6\t\xE6\x4\xE7\t\xE7\x4\xE8\t\xE8");
		sb.Append("\x4\xE9\t\xE9\x4\xEA\t\xEA\x4\xEB\t\xEB\x4\xEC\t\xEC\x4\xED");
		sb.Append("\t\xED\x4\xEE\t\xEE\x4\xEF\t\xEF\x4\xF0\t\xF0\x4\xF1\t\xF1\x4");
		sb.Append("\xF2\t\xF2\x4\xF3\t\xF3\x4\xF4\t\xF4\x4\xF5\t\xF5\x4\xF6\t\xF6");
		sb.Append("\x4\xF7\t\xF7\x4\xF8\t\xF8\x4\xF9\t\xF9\x4\xFA\t\xFA\x4\xFB");
		sb.Append("\t\xFB\x4\xFC\t\xFC\x4\xFD\t\xFD\x4\xFE\t\xFE\x4\xFF\t\xFF\x4");
		sb.Append("\x100\t\x100\x4\x101\t\x101\x4\x102\t\x102\x4\x103\t\x103\x4");
		sb.Append("\x104\t\x104\x4\x105\t\x105\x4\x106\t\x106\x4\x107\t\x107\x4");
		sb.Append("\x108\t\x108\x4\x109\t\x109\x4\x10A\t\x10A\x4\x10B\t\x10B\x4");
		sb.Append("\x10C\t\x10C\x4\x10D\t\x10D\x4\x10E\t\x10E\x4\x10F\t\x10F\x4");
		sb.Append("\x110\t\x110\x4\x111\t\x111\x4\x112\t\x112\x4\x113\t\x113\x4");
		sb.Append("\x114\t\x114\x4\x115\t\x115\x4\x116\t\x116\x4\x117\t\x117\x4");
		sb.Append("\x118\t\x118\x4\x119\t\x119\x4\x11A\t\x11A\x4\x11B\t\x11B\x4");
		sb.Append("\x11C\t\x11C\x4\x11D\t\x11D\x4\x11E\t\x11E\x4\x11F\t\x11F\x4");
		sb.Append("\x120\t\x120\x4\x121\t\x121\x4\x122\t\x122\x4\x123\t\x123\x4");
		sb.Append("\x124\t\x124\x4\x125\t\x125\x4\x126\t\x126\x4\x127\t\x127\x4");
		sb.Append("\x128\t\x128\x4\x129\t\x129\x4\x12A\t\x12A\x4\x12B\t\x12B\x4");
		sb.Append("\x12C\t\x12C\x4\x12D\t\x12D\x4\x12E\t\x12E\x4\x12F\t\x12F\x4");
		sb.Append("\x130\t\x130\x4\x131\t\x131\x4\x132\t\x132\x4\x133\t\x133\x4");
		sb.Append("\x134\t\x134\x4\x135\t\x135\x4\x136\t\x136\x4\x137\t\x137\x4");
		sb.Append("\x138\t\x138\x4\x139\t\x139\x4\x13A\t\x13A\x4\x13B\t\x13B\x4");
		sb.Append("\x13C\t\x13C\x4\x13D\t\x13D\x4\x13E\t\x13E\x4\x13F\t\x13F\x4");
		sb.Append("\x140\t\x140\x4\x141\t\x141\x4\x142\t\x142\x4\x143\t\x143\x4");
		sb.Append("\x144\t\x144\x4\x145\t\x145\x4\x146\t\x146\x4\x147\t\x147\x4");
		sb.Append("\x148\t\x148\x4\x149\t\x149\x4\x14A\t\x14A\x4\x14B\t\x14B\x4");
		sb.Append("\x14C\t\x14C\x4\x14D\t\x14D\x4\x14E\t\x14E\x4\x14F\t\x14F\x4");
		sb.Append("\x150\t\x150\x4\x151\t\x151\x4\x152\t\x152\x4\x153\t\x153\x4");
		sb.Append("\x154\t\x154\x4\x155\t\x155\x4\x156\t\x156\x4\x157\t\x157\x4");
		sb.Append("\x158\t\x158\x4\x159\t\x159\x4\x15A\t\x15A\x4\x15B\t\x15B\x4");
		sb.Append("\x15C\t\x15C\x4\x15D\t\x15D\x4\x15E\t\x15E\x4\x15F\t\x15F\x4");
		sb.Append("\x160\t\x160\x4\x161\t\x161\x4\x162\t\x162\x4\x163\t\x163\x4");
		sb.Append("\x164\t\x164\x4\x165\t\x165\x4\x166\t\x166\x4\x167\t\x167\x4");
		sb.Append("\x168\t\x168\x4\x169\t\x169\x4\x16A\t\x16A\x4\x16B\t\x16B\x4");
		sb.Append("\x16C\t\x16C\x4\x16D\t\x16D\x4\x16E\t\x16E\x4\x16F\t\x16F\x4");
		sb.Append("\x170\t\x170\x4\x171\t\x171\x4\x172\t\x172\x4\x173\t\x173\x4");
		sb.Append("\x174\t\x174\x4\x175\t\x175\x4\x176\t\x176\x4\x177\t\x177\x4");
		sb.Append("\x178\t\x178\x4\x179\t\x179\x4\x17A\t\x17A\x4\x17B\t\x17B\x4");
		sb.Append("\x17C\t\x17C\x4\x17D\t\x17D\x3\x2\x6\x2\x2FC\n\x2\r\x2\xE\x2");
		sb.Append("\x2FD\x3\x3\a\x3\x301\n\x3\f\x3\xE\x3\x304\v\x3\x3\x3\x3\x3");
		sb.Append("\x3\x4\x3\x4\a\x4\x30A\n\x4\f\x4\xE\x4\x30D\v\x4\x3\x4\x3\x4");
		sb.Append("\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5");
		sb.Append("\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5");
		sb.Append("\x324\n\x5\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\a\x3\a\x3\a\x3\a");
		sb.Append("\x3\a\x5\a\x330\n\a\x3\a\a\a\x333\n\a\f\a\xE\a\x336\v\a\x3\a");
		sb.Append("\x3\a\x5\a\x33A\n\a\x3\a\x3\a\x3\b\x3\b\x3\b\x5\b\x341\n\b\x5");
		sb.Append("\b\x343\n\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\a\b\x34B\n\b\f\b\xE");
		sb.Append("\b\x34E\v\b\x3\b\x3\b\x5\b\x352\n\b\x3\b\x3\b\x3\b\x3\b\x3\b");
		sb.Append("\x3\b\a\b\x35A\n\b\f\b\xE\b\x35D\v\b\x3\b\x5\b\x360\n\b\x3\b");
		sb.Append("\x3\b\x5\b\x364\n\b\x3\b\a\b\x367\n\b\f\b\xE\b\x36A\v\b\x3\b");
		sb.Append("\x3\b\x5\b\x36E\n\b\x3\b\x3\b\x3\b\x5\b\x373\n\b\x3\b\x3\b\x3");
		sb.Append("\t\x3\t\x5\t\x379\n\t\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3\n\x3");
		sb.Append("\n\x3\n\x3\n\a\n\x385\n\n\f\n\xE\n\x388\v\n\x3\n\x3\n\x5\n\x38C");
		sb.Append("\n\n\x3\n\x5\n\x38F\n\n\x3\n\x3\n\x3\v\x3\v\x5\v\x395\n\v\x3");
		sb.Append("\f\x3\f\x3\f\x3\f\x3\f\a\f\x39C\n\f\f\f\xE\f\x39F\v\f\x3\f\x3");
		sb.Append("\f\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\a\r\x3AA\n\r\f\r\xE\r");
		sb.Append("\x3AD\v\r\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x5\xE\x3B4\n\xE\x3\xE");
		sb.Append("\x3\xE\x3\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3\xF\x5\xF\x3BE\n\xF\x3");
		sb.Append("\xF\x5\xF\x3C1\n\xF\x3\xF\a\xF\x3C4\n\xF\f\xF\xE\xF\x3C7\v\xF");
		sb.Append("\x3\xF\x3\xF\x5\xF\x3CB\n\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10");
		sb.Append("\x5\x10\x3D2\n\x10\x3\x10\x3\x10\x3\x10\x5\x10\x3D7\n\x10\x3");
		sb.Append("\x10\x3\x10\x3\x11\x3\x11\x3\x11\x3\x11\a\x11\x3DF\n\x11\f\x11");
		sb.Append("\xE\x11\x3E2\v\x11\x3\x11\x3\x11\x3\x11\x3\x11\x5\x11\x3E8\n");
		sb.Append("\x11\x5\x11\x3EA\n\x11\x3\x12\x3\x12\x5\x12\x3EE\n\x12\x3\x12");
		sb.Append("\x3\x12\a\x12\x3F2\n\x12\f\x12\xE\x12\x3F5\v\x12\x3\x12\x3\x12");
		sb.Append("\x5\x12\x3F9\n\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13");
		sb.Append("\x3\x13\x3\x13\x3\x13\x5\x13\x404\n\x13\x3\x14\x3\x14\x3\x14");
		sb.Append("\x3\x14\x3\x14\x3\x14\a\x14\x40C\n\x14\f\x14\xE\x14\x40F\v\x14");
		sb.Append("\x3\x14\x3\x14\x5\x14\x413\n\x14\x3\x14\x3\x14\x3\x15\x3\x15");
		sb.Append("\x3\x15\x3\x15\x3\x15\x3\x15\a\x15\x41D\n\x15\f\x15\xE\x15\x420");
		sb.Append("\v\x15\x3\x15\x3\x15\x5\x15\x424\n\x15\x3\x15\x3\x15\x3\x15");
		sb.Append("\x5\x15\x429\n\x15\x3\x15\x5\x15\x42C\n\x15\x3\x15\x3\x15\x3");
		sb.Append("\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16");
		sb.Append("\x3\x16\x5\x16\x43A\n\x16\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17");
		sb.Append("\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x446\n\x18\x3\x18");
		sb.Append("\a\x18\x449\n\x18\f\x18\xE\x18\x44C\v\x18\x3\x18\x3\x18\x5\x18");
		sb.Append("\x450\n\x18\x3\x18\x3\x18\x3\x19\x3\x19\x3\x19\x5\x19\x457\n");
		sb.Append("\x19\x5\x19\x459\n\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3");
		sb.Append("\x19\a\x19\x461\n\x19\f\x19\xE\x19\x464\v\x19\x3\x19\x3\x19");
		sb.Append("\x5\x19\x468\n\x19\x3\x19\x5\x19\x46B\n\x19\x3\x19\x3\x19\x5");
		sb.Append("\x19\x46F\n\x19\x3\x19\a\x19\x472\n\x19\f\x19\xE\x19\x475\v");
		sb.Append("\x19\x3\x19\x3\x19\x3\x19\x5\x19\x47A\n\x19\x3\x19\x3\x19\x3");
		sb.Append("\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1B\x3\x1B\x3\x1B\x3\x1B");
		sb.Append("\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x48C\n\x1B\x3\x1B");
		sb.Append("\a\x1B\x48F\n\x1B\f\x1B\xE\x1B\x492\v\x1B\x3\x1B\x3\x1B\x5\x1B");
		sb.Append("\x496\n\x1B\x5\x1B\x498\n\x1B\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x3");
		sb.Append("\x1C\x5\x1C\x49F\n\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x5");
		sb.Append("\x1C\x4A6\n\x1C\x3\x1C\x5\x1C\x4A9\n\x1C\x3\x1C\x5\x1C\x4AC");
		sb.Append("\n\x1C\x3\x1C\x5\x1C\x4AF\n\x1C\x3\x1C\x3\x1C\x3\x1C\x3\x1D");
		sb.Append("\x3\x1D\x3\x1D\x3\x1D\a\x1D\x4B8\n\x1D\f\x1D\xE\x1D\x4BB\v\x1D");
		sb.Append("\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3\x1F\x3");
		sb.Append("\x1F\x5\x1F\x4C6\n\x1F\x3\x1F\x3\x1F\x5\x1F\x4CA\n\x1F\x3\x1F");
		sb.Append("\x5\x1F\x4CD\n\x1F\x3 \x3 \x3 \x3 \x3!\x3!\x3!\x5!\x4D6\n!\x3");
		sb.Append("\"\x3\"\x3\"\x3\"\a\"\x4DC\n\"\f\"\xE\"\x4DF\v\"\x3\"\x3\"\x3");
		sb.Append("\"\x3\"\x3\"\x5\"\x4E6\n\"\x3\"\x5\"\x4E9\n\"\x3#\x3#\x3#\x3");
		sb.Append("#\x3#\x5#\x4F0\n#\x3$\x3$\x5$\x4F4\n$\x3%\x3%\x3%\a%\x4F9\n");
		sb.Append("%\f%\xE%\x4FC\v%\x3%\x6%\x4FF\n%\r%\xE%\x500\x3%\x3%\x3%\x3");
		sb.Append("&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3");
		sb.Append("&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3&\x3");
		sb.Append("&\x3&\x3&\x3&\x3&\x3&\x5&\x52A\n&\x3\'\x3\'\x3\'\x3\'\x3\'\x3");
		sb.Append("\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3");
		sb.Append("\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x3\'\x5\'\x546\n\'\x3");
		sb.Append("(\x3(\x3(\a(\x54B\n(\f(\xE(\x54E\v(\x3(\x3(\x5(\x552\n(\x3(");
		sb.Append("\x3(\x3)\x3)\x3)\x3)\x3)\a)\x55B\n)\f)\xE)\x55E\v)\x5)\x560");
		sb.Append("\n)\x3*\x3*\x3*\x3*\x3*\x3+\x3+\x6+\x569\n+\r+\xE+\x56A\x3,");
		sb.Append("\x3,\x3,\x3-\x3-\x3-\x5-\x573\n-\x3-\x3-\x5-\x577\n-\x3-\x3");
		sb.Append("-\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x3.\x5.\x583\n.\x3.\x5.\x586\n");
		sb.Append(".\x3.\x3.\x3/\x3/\x5/\x58C\n/\x3/\x5/\x58F\n/\x3/\a/\x592\n");
		sb.Append("/\f/\xE/\x595\v/\x3/\x3/\x5/\x599\n/\x3\x30\x3\x30\x5\x30\x59D");
		sb.Append("\n\x30\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\a\x30\x5A5");
		sb.Append("\n\x30\f\x30\xE\x30\x5A8\v\x30\x3\x30\x3\x30\x3\x31\x3\x31\x3");
		sb.Append("\x31\a\x31\x5AF\n\x31\f\x31\xE\x31\x5B2\v\x31\x3\x32\x3\x32");
		sb.Append("\x3\x32\x5\x32\x5B7\n\x32\x3\x33\x3\x33\x3\x33\x3\x33\x3\x33");
		sb.Append("\x3\x33\x3\x33\a\x33\x5C0\n\x33\f\x33\xE\x33\x5C3\v\x33\x3\x33");
		sb.Append("\x3\x33\x5\x33\x5C7\n\x33\x3\x34\x3\x34\x5\x34\x5CB\n\x34\x3");
		sb.Append("\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x5\x35\x5D3\n\x35\x3");
		sb.Append("\x36\x3\x36\x3\x36\x3\x36\x3\x36\x3\x36\x5\x36\x5DB\n\x36\x3");
		sb.Append("\x36\x3\x36\x3\x36\x5\x36\x5E0\n\x36\x3\x36\x5\x36\x5E3\n\x36");
		sb.Append("\x5\x36\x5E5\n\x36\x3\x37\x5\x37\x5E8\n\x37\x3\x37\x3\x37\x3");
		sb.Append("\x37\x3\x37\x3\x38\x3\x38\x3\x38\x5\x38\x5F1\n\x38\x3\x38\x3");
		sb.Append("\x38\x3\x38\x5\x38\x5F6\n\x38\x3\x38\x3\x38\x3\x39\x3\x39\x3");
		sb.Append("\x39\x5\x39\x5FD\n\x39\x3\x39\x5\x39\x600\n\x39\x3:\x5:\x603");
		sb.Append("\n:\x3:\x3:\x5:\x607\n:\x3:\x5:\x60A\n:\x3:\x3:\x3:\x3:\a:\x610");
		sb.Append("\n:\f:\xE:\x613\v:\x3:\x3:\x5:\x617\n:\x3:\a:\x61A\n:\f:\xE");
		sb.Append(":\x61D\v:\x3;\x3;\x3;\x3;\x5;\x623\n;\x3<\x3<\x3<\x3=\x3=\x3");
		sb.Append("=\x3=\x3=\x5=\x62D\n=\x3>\x3>\x3>\x3>\x3>\x3>\x3>\x3>\x3?\x3");
		sb.Append("?\x3?\x3?\x6?\x63B\n?\r?\xE?\x63C\x3?\x3?\x3@\x3@\x5@\x643\n");
		sb.Append("@\x3\x41\x3\x41\x3\x41\x3\x41\x3\x42\x3\x42\x3\x42\x3\x42\x5");
		sb.Append("\x42\x64D\n\x42\x3\x43\x3\x43\x3\x43\x3\x43\x3\x43\x3\x43\a");
		sb.Append("\x43\x655\n\x43\f\x43\xE\x43\x658\v\x43\x3\x43\x3\x43\x3\x43");
		sb.Append("\x3\x43\x5\x43\x65E\n\x43\x3\x43\a\x43\x661\n\x43\f\x43\xE\x43");
		sb.Append("\x664\v\x43\x3\x43\x3\x43\x3\x43\x5\x43\x669\n\x43\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x3\x44\x3\x44\a\x44\x671\n\x44\f\x44\xE\x44");
		sb.Append("\x674\v\x44\x3\x44\x3\x44\x5\x44\x678\n\x44\x3\x44\x3\x44\x3");
		sb.Append("\x44\x3\x44\x3\x44\x5\x44\x67F\n\x44\x3\x44\a\x44\x682\n\x44");
		sb.Append("\f\x44\xE\x44\x685\v\x44\x3\x44\x3\x44\x3\x44\x5\x44\x68A\n");
		sb.Append("\x44\x3\x45\x5\x45\x68D\n\x45\x3\x45\x5\x45\x690\n\x45\x3\x45");
		sb.Append("\x3\x45\x3\x45\x3\x45\x3\x45\x3\x45\x3\x45\x3\x45\x3\x45\x3");
		sb.Append("\x45\x3\x45\x3\x45\x3\x45\a\x45\x69F\n\x45\f\x45\xE\x45\x6A2");
		sb.Append("\v\x45\x3\x45\x3\x45\x5\x45\x6A6\n\x45\x3\x45\x3\x45\x3\x45");
		sb.Append("\x3\x45\x3\x45\x3\x45\x3\x45\x5\x45\x6AF\n\x45\x3\x45\a\x45");
		sb.Append("\x6B2\n\x45\f\x45\xE\x45\x6B5\v\x45\x3\x45\x3\x45\x3\x45\x5");
		sb.Append("\x45\x6BA\n\x45\x3\x46\x5\x46\x6BD\n\x46\x3\x46\x3\x46\x3G\x3");
		sb.Append("G\x3G\x5G\x6C4\nG\x3G\x5G\x6C7\nG\x3H\x3H\x3H\x3H\x3I\x5I\x6CE");
		sb.Append("\nI\x3I\x6I\x6D1\nI\rI\xEI\x6D2\x3I\x3I\x5I\x6D7\nI\x3J\x3J");
		sb.Append("\x3J\x5J\x6DC\nJ\x3K\x3K\x3K\x5K\x6E1\nK\x3L\x3L\x3L\x3L\x3");
		sb.Append("L\x3L\aL\x6E9\nL\fL\xEL\x6EC\vL\x3L\x3L\x3L\x5L\x6F1\nL\x3M");
		sb.Append("\x3M\x3M\x3M\x3M\x3M\aM\x6F9\nM\fM\xEM\x6FC\vM\x3M\x3M\x5M\x700");
		sb.Append("\nM\x3M\x3M\x3M\x3M\x3M\x5M\x707\nM\x3M\x3M\x3M\x3M\x5M\x70D");
		sb.Append("\nM\x3M\x3M\x5M\x711\nM\x3N\x5N\x714\nN\x3N\x5N\x717\nN\x3N");
		sb.Append("\x3N\x3N\x3N\x3N\x3N\x3N\x3N\x3N\x3N\x3N\x3N\x3N\aN\x726\nN");
		sb.Append("\fN\xEN\x729\vN\x3N\x3N\x5N\x72D\nN\x3N\x3N\x3N\x3N\x3N\x3N");
		sb.Append("\x5N\x735\nN\x3O\x3O\x3O\x3O\x3P\x3P\x3P\x3P\x3P\x3P\aP\x741");
		sb.Append("\nP\fP\xEP\x744\vP\x3P\x3P\x3Q\x3Q\x5Q\x74A\nQ\x3R\x3R\x3R\x3");
		sb.Append("S\x3S\x3S\x3S\x3S\x3T\x3T\x3T\x3T\x6T\x758\nT\rT\xET\x759\x3");
		sb.Append("T\x3T\x3U\x3U\x3U\x3U\x3U\aU\x763\nU\fU\xEU\x766\vU\x3U\x3U");
		sb.Append("\x3V\x3V\x3V\x3V\x3V\x3V\x3V\x3V\x3V\x3V\x3V\x3V\x3V\x3V\x3");
		sb.Append("V\x3V\x5V\x77A\nV\x3W\x3W\x3W\x3W\x3X\x3X\x3X\x3Y\x3Y\x3Y\x3");
		sb.Append("Y\x3Z\x3Z\x3Z\x5Z\x78A\nZ\x3[\x3[\x3[\x3[\x3\\\x3\\\x3\\\x5");
		sb.Append("\\\x793\n\\\x3\\\x3\\\x3\\\x5\\\x798\n\\\x3\\\x3\\\x5\\\x79C");
		sb.Append("\n\\\x3\\\x5\\\x79F\n\\\x3]\x3]\x3]\x3]\x3]\x3]\a]\x7A7\n]\f");
		sb.Append("]\xE]\x7AA\v]\x3]\x3]\x3^\x3^\x3^\x3^\x3^\a^\x7B3\n^\f^\xE^");
		sb.Append("\x7B6\v^\x3^\x3^\x3^\x5^\x7BB\n^\x3^\x3^\x3_\x3_\a_\x7C1\n_");
		sb.Append("\f_\xE_\x7C4\v_\x3_\x5_\x7C7\n_\x3_\x5_\x7CA\n_\x3`\x3`\x3`");
		sb.Append("\x3\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3\x61\x3");
		sb.Append("\x61\x5\x61\x7D8\n\x61\x3\x62\x3\x62\x5\x62\x7DC\n\x62\x3\x62");
		sb.Append("\x3\x62\x3\x62\x5\x62\x7E1\n\x62\x3\x62\x5\x62\x7E4\n\x62\x3");
		sb.Append("\x62\x3\x62\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63");
		sb.Append("\x3\x63\x3\x63\x5\x63\x7F1\n\x63\x3\x63\x3\x63\x5\x63\x7F5\n");
		sb.Append("\x63\x3\x63\x3\x63\x3\x64\x3\x64\x3\x64\x3\x64\x3\x64\x3\x64");
		sb.Append("\a\x64\x7FF\n\x64\f\x64\xE\x64\x802\v\x64\x3\x64\x3\x64\x5\x64");
		sb.Append("\x806\n\x64\x3\x64\x3\x64\x5\x64\x80A\n\x64\x3\x64\x3\x64\x5");
		sb.Append("\x64\x80E\n\x64\x3\x64\x3\x64\x3\x65\x3\x65\x5\x65\x814\n\x65");
		sb.Append("\x3\x65\x5\x65\x817\n\x65\x3\x65\x5\x65\x81A\n\x65\x3\x66\x3");
		sb.Append("\x66\x3\x66\x3\x66\x3g\x3g\x3g\x3g\x3g\x3g\x3g\x3g\x3g\x3g\x3");
		sb.Append("g\x3g\x3g\x3g\x3g\x3g\x3g\x3g\x3g\x3g\x3g\x5g\x835\ng\x3g\x3");
		sb.Append("g\x6g\x839\ng\rg\xEg\x83A\x3g\x3g\x5g\x83F\ng\x3g\x3g\x3h\x3");
		sb.Append("h\x5h\x845\nh\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\ai\x84F\ni\fi");
		sb.Append("\xEi\x852\vi\x3i\x3i\x3i\x3i\x3i\x3i\x5i\x85A\ni\x5i\x85C\n");
		sb.Append("i\x3i\x3i\x3j\x3j\x5j\x862\nj\x3j\x3j\x5j\x866\nj\x3j\x5j\x869");
		sb.Append("\nj\x3k\x3k\x3k\x3k\x3k\x3l\x3l\x5l\x872\nl\x3l\x3l\x3m\x3m");
		sb.Append("\x3m\x3m\x3m\x3m\x3m\x5m\x87D\nm\x3m\x3m\x5m\x881\nm\x3m\x5");
		sb.Append("m\x884\nm\x3n\x3n\x5n\x888\nn\x3n\x3n\x3n\x3o\x3o\x3o\x5o\x890");
		sb.Append("\no\x3o\x3o\x3o\x3o\x3o\x3o\x3o\x5o\x899\no\x3p\x3p\x3p\x3q");
		sb.Append("\x3q\x3q\x3q\x6q\x8A2\nq\rq\xEq\x8A3\x3r\x3r\x3r\x3r\x3r\x3");
		sb.Append("r\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3");
		sb.Append("s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x3s\x5s\x8C3\ns\x3t\x3t\x5t\x8C7");
		sb.Append("\nt\x3t\x3t\x3t\x3u\x3u\x5u\x8CE\nu\x3u\x3u\x5u\x8D2\nu\x3v");
		sb.Append("\x3v\x5v\x8D6\nv\x3v\x3v\x5v\x8DA\nv\x3w\x3w\x3w\x3x\x3x\x3");
		sb.Append("x\x3x\x3x\ax\x8E4\nx\fx\xEx\x8E7\vx\x3x\x5x\x8EA\nx\x3x\x3x");
		sb.Append("\x3x\x3y\x3y\x3y\x3y\x3y\x3z\x3z\x3z\x3{\x5{\x8F8\n{\x3{\x3");
		sb.Append("{\x3{\x3{\x5{\x8FE\n{\x3{\x3{\x3{\x3{\x3{\x5{\x905\n{\x3|\x3");
		sb.Append("|\x3|\x5|\x90A\n|\x3|\x3|\x3|\x3|\x3|\x3|\x3|\x3|\x5|\x914\n");
		sb.Append("|\x3|\x3|\x3|\x3|\x5|\x91A\n|\x5|\x91C\n|\x3}\x3}\x3}\x3}\x3");
		sb.Append("}\x3}\x3}\x5}\x925\n}\x3~\x3~\x3~\x3~\x3~\x3~\x3~\x3~\x5~\x92F");
		sb.Append("\n~\x3~\x3~\x3~\x5~\x934\n~\x3\x7F\x3\x7F\x3\x7F\x3\x7F\x3\x7F");
		sb.Append("\x3\x80\x3\x80\x3\x81\x3\x81\x3\x82\x3\x82\x3\x83\x3\x83\x5");
		sb.Append("\x83\x943\n\x83\x3\x84\x3\x84\x5\x84\x947\n\x84\x3\x85\x5\x85");
		sb.Append("\x94A\n\x85\x3\x85\x3\x85\x5\x85\x94E\n\x85\x3\x86\x3\x86\x3");
		sb.Append("\x86\x5\x86\x953\n\x86\x3\x86\x3\x86\x5\x86\x957\n\x86\x3\x87");
		sb.Append("\x3\x87\x6\x87\x95B\n\x87\r\x87\xE\x87\x95C\x3\x88\x3\x88\x3");
		sb.Append("\x88\x3\x88\a\x88\x963\n\x88\f\x88\xE\x88\x966\v\x88\x3\x88");
		sb.Append("\x3\x88\x3\x88\x3\x89\x5\x89\x96C\n\x89\x3\x89\x6\x89\x96F\n");
		sb.Append("\x89\r\x89\xE\x89\x970\x5\x89\x973\n\x89\x3\x89\x3\x89\x3\x8A");
		sb.Append("\x5\x8A\x978\n\x8A\x3\x8A\x6\x8A\x97B\n\x8A\r\x8A\xE\x8A\x97C");
		sb.Append("\x3\x8A\x3\x8A\x3\x8B\x3\x8B\x3\x8B\x3\x8B\x5\x8B\x985\n\x8B");
		sb.Append("\x3\x8C\x3\x8C\x3\x8C\x3\x8C\x3\x8C\x5\x8C\x98C\n\x8C\x3\x8C");
		sb.Append("\x3\x8C\x5\x8C\x990\n\x8C\x3\x8C\x5\x8C\x993\n\x8C\x3\x8D\x3");
		sb.Append("\x8D\x3\x8D\x3\x8E\x3\x8E\x3\x8E\x3\x8E\x3\x8E\x3\x8E\x3\x8E");
		sb.Append("\x5\x8E\x99F\n\x8E\x3\x8F\x3\x8F\x3\x8F\x3\x8F\x5\x8F\x9A5\n");
		sb.Append("\x8F\x3\x90\x3\x90\x3\x90\x3\x91\x3\x91\x3\x91\x5\x91\x9AD\n");
		sb.Append("\x91\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92\a\x92\x9B5\n");
		sb.Append("\x92\f\x92\xE\x92\x9B8\v\x92\x3\x92\x3\x92\x3\x92\x3\x92\x3");
		sb.Append("\x92\x3\x92\a\x92\x9C0\n\x92\f\x92\xE\x92\x9C3\v\x92\x5\x92");
		sb.Append("\x9C5\n\x92\x3\x93\x3\x93\x3\x93\x3\x93\x3\x93\x5\x93\x9CC\n");
		sb.Append("\x93\x3\x93\x5\x93\x9CF\n\x93\x3\x94\x3\x94\x3\x94\x3\x94\x3");
		sb.Append("\x94\x5\x94\x9D6\n\x94\x3\x95\x3\x95\x3\x95\x3\x95\x3\x95\x3");
		sb.Append("\x95\x3\x95\x3\x95\x3\x95\x5\x95\x9E1\n\x95\x3\x95\x3\x95\x3");
		sb.Append("\x95\x3\x95\x5\x95\x9E7\n\x95\x3\x95\x3\x95\x5\x95\x9EB\n\x95");
		sb.Append("\x3\x96\x3\x96\x3\x96\x3\x96\x3\x96\x3\x96\a\x96\x9F3\n\x96");
		sb.Append("\f\x96\xE\x96\x9F6\v\x96\x5\x96\x9F8\n\x96\x3\x96\x3\x96\x3");
		sb.Append("\x97\x3\x97\x5\x97\x9FE\n\x97\x3\x97\x3\x97\x3\x97\x3\x97\x3");
		sb.Append("\x97\x3\x97\x3\x97\x3\x97\x3\x97\x5\x97\xA09\n\x97\x5\x97\xA0B");
		sb.Append("\n\x97\x5\x97\xA0D\n\x97\x3\x97\x5\x97\xA10\n\x97\x3\x98\x3");
		sb.Append("\x98\x5\x98\xA14\n\x98\x3\x98\x5\x98\xA17\n\x98\x3\x99\x3\x99");
		sb.Append("\x5\x99\xA1B\n\x99\x3\x99\x3\x99\x5\x99\xA1F\n\x99\x3\x99\x3");
		sb.Append("\x99\x3\x99\x5\x99\xA24\n\x99\x3\x9A\x3\x9A\x3\x9A\x3\x9B\x3");
		sb.Append("\x9B\x3\x9B\x3\x9B\x3\x9B\x3\x9B\x5\x9B\xA2F\n\x9B\x3\x9B\x3");
		sb.Append("\x9B\x5\x9B\xA33\n\x9B\x3\x9B\x3\x9B\x3\x9B\x3\x9B\x3\x9B\x3");
		sb.Append("\x9B\x5\x9B\xA3B\n\x9B\x3\x9C\x5\x9C\xA3E\n\x9C\x3\x9C\x3\x9C");
		sb.Append("\x3\x9C\a\x9C\xA43\n\x9C\f\x9C\xE\x9C\xA46\v\x9C\x3\x9D\x3\x9D");
		sb.Append("\x3\x9D\x3\x9D\a\x9D\xA4C\n\x9D\f\x9D\xE\x9D\xA4F\v\x9D\x3\x9E");
		sb.Append("\x3\x9E\x3\x9E\x3\x9E\x3\x9E\a\x9E\xA56\n\x9E\f\x9E\xE\x9E\xA59");
		sb.Append("\v\x9E\x3\x9E\x3\x9E\x5\x9E\xA5D\n\x9E\x3\x9E\x3\x9E\x3\x9E");
		sb.Append("\x3\x9E\x5\x9E\xA63\n\x9E\x3\x9E\x3\x9E\x5\x9E\xA67\n\x9E\x3");
		sb.Append("\x9E\x5\x9E\xA6A\n\x9E\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3");
		sb.Append("\x9F\x5\x9F\xA72\n\x9F\x3\x9F\x5\x9F\xA75\n\x9F\x3\x9F\x3\x9F");
		sb.Append("\x5\x9F\xA79\n\x9F\x3\x9F\x3\x9F\x5\x9F\xA7D\n\x9F\x3\x9F\x3");
		sb.Append("\x9F\x3\x9F\x5\x9F\xA82\n\x9F\x3\x9F\x5\x9F\xA85\n\x9F\x3\x9F");
		sb.Append("\x3\x9F\x5\x9F\xA89\n\x9F\x3\x9F\x3\x9F\x5\x9F\xA8D\n\x9F\a");
		sb.Append("\x9F\xA8F\n\x9F\f\x9F\xE\x9F\xA92\v\x9F\x3\x9F\x3\x9F\x3\x9F");
		sb.Append("\x3\xA0\x3\xA0\x3\xA0\x3\xA0\a\xA0\xA9B\n\xA0\f\xA0\xE\xA0\xA9E");
		sb.Append("\v\xA0\x3\xA0\x3\xA0\x3\xA0\x3\xA0\x3\xA0\x3\xA0\x3\xA0\x3\xA1");
		sb.Append("\x3\xA1\a\xA1\xAA9\n\xA1\f\xA1\xE\xA1\xAAC\v\xA1\x3\xA2\x3\xA2");
		sb.Append("\x5\xA2\xAB0\n\xA2\x3\xA2\x3\xA2\x5\xA2\xAB4\n\xA2\x3\xA2\x3");
		sb.Append("\xA2\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\xABD\n\xA3\x3");
		sb.Append("\xA4\x3\xA4\x5\xA4\xAC1\n\xA4\x3\xA4\x3\xA4\x3\xA4\x3\xA4\a");
		sb.Append("\xA4\xAC7\n\xA4\f\xA4\xE\xA4\xACA\v\xA4\x5\xA4\xACC\n\xA4\x3");
		sb.Append("\xA4\x5\xA4\xACF\n\xA4\x3\xA4\x3\xA4\x5\xA4\xAD3\n\xA4\x3\xA4");
		sb.Append("\x5\xA4\xAD6\n\xA4\x3\xA4\x5\xA4\xAD9\n\xA4\x3\xA4\x5\xA4\xADC");
		sb.Append("\n\xA4\x3\xA5\x3\xA5\x5\xA5\xAE0\n\xA5\x3\xA6\x3\xA6\x3\xA6");
		sb.Append("\x3\xA7\x3\xA7\x3\xA7\x3\xA7\x3\xA7\x5\xA7\xAEA\n\xA7\x3\xA8");
		sb.Append("\x3\xA8\x3\xA8\a\xA8\xAEF\n\xA8\f\xA8\xE\xA8\xAF2\v\xA8\x3\xA9");
		sb.Append("\x3\xA9\a\xA9\xAF6\n\xA9\f\xA9\xE\xA9\xAF9\v\xA9\x3\xA9\x3\xA9");
		sb.Append("\x5\xA9\xAFD\n\xA9\x3\xAA\x3\xAA\x3\xAA\x5\xAA\xB02\n\xAA\x3");
		sb.Append("\xAA\x3\xAA\x3\xAA\a\xAA\xB07\n\xAA\f\xAA\xE\xAA\xB0A\v\xAA");
		sb.Append("\x3\xAA\x3\xAA\x3\xAA\x5\xAA\xB0F\n\xAA\x3\xAA\x3\xAA\x3\xAA");
		sb.Append("\x3\xAA\x3\xAA\x3\xAA\x3\xAA\x3\xAA\x5\xAA\xB19\n\xAA\x5\xAA");
		sb.Append("\xB1B\n\xAA\x3\xAA\a\xAA\xB1E\n\xAA\f\xAA\xE\xAA\xB21\v\xAA");
		sb.Append("\x3\xAA\x5\xAA\xB24\n\xAA\x3\xAB\x5\xAB\xB27\n\xAB\x3\xAB\x5");
		sb.Append("\xAB\xB2A\n\xAB\x3\xAB\x3\xAB\x5\xAB\xB2E\n\xAB\x3\xAB\x3\xAB");
		sb.Append("\x3\xAB\x5\xAB\xB33\n\xAB\x3\xAB\x3\xAB\a\xAB\xB37\n\xAB\f\xAB");
		sb.Append("\xE\xAB\xB3A\v\xAB\x3\xAC\x3\xAC\x3\xAC\x3\xAD\x3\xAD\x3\xAD");
		sb.Append("\x3\xAD\x3\xAD\a\xAD\xB44\n\xAD\f\xAD\xE\xAD\xB47\v\xAD\x3\xAD");
		sb.Append("\x3\xAD\x3\xAE\x3\xAE\x5\xAE\xB4D\n\xAE\x3\xAF\x3\xAF\x3\xAF");
		sb.Append("\x3\xAF\x3\xAF\x3\xAF\x3\xAF\x3\xAF\x3\xAF\x3\xAF\a\xAF\xB59");
		sb.Append("\n\xAF\f\xAF\xE\xAF\xB5C\v\xAF\x5\xAF\xB5E\n\xAF\x3\xB0\x3\xB0");
		sb.Append("\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x3\xB0\x5\xB0\xB68\n\xB0");
		sb.Append("\x3\xB1\x3\xB1\x5\xB1\xB6C\n\xB1\x3\xB1\x3\xB1\x3\xB1\x3\xB1");
		sb.Append("\a\xB1\xB72\n\xB1\f\xB1\xE\xB1\xB75\v\xB1\x3\xB1\x3\xB1\x3\xB1");
		sb.Append("\x3\xB1\x3\xB2\x3\xB2\x3\xB2\x3\xB2\x3\xB2\x5\xB2\xB80\n\xB2");
		sb.Append("\x3\xB3\x3\xB3\x3\xB3\x3\xB3\x3\xB3\x3\xB3\a\xB3\xB88\n\xB3");
		sb.Append("\f\xB3\xE\xB3\xB8B\v\xB3\x3\xB3\x3\xB3\x5\xB3\xB8F\n\xB3\x3");
		sb.Append("\xB4\x3\xB4\x3\xB4\x3\xB4\x3\xB4\x3\xB4\a\xB4\xB97\n\xB4\f\xB4");
		sb.Append("\xE\xB4\xB9A\v\xB4\x3\xB4\x3\xB4\x3\xB4\a\xB4\xB9F\n\xB4\f\xB4");
		sb.Append("\xE\xB4\xBA2\v\xB4\x5\xB4\xBA4\n\xB4\x3\xB4\x3\xB4\x3\xB5\x3");
		sb.Append("\xB5\x5\xB5\xBAA\n\xB5\x3\xB6\x3\xB6\x5\xB6\xBAE\n\xB6\x3\xB7");
		sb.Append("\x3\xB7\x3\xB7\x5\xB7\xBB3\n\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB7");
		sb.Append("\x3\xB7\x3\xB7\a\xB7\xBBB\n\xB7\f\xB7\xE\xB7\xBBE\v\xB7\x3\xB7");
		sb.Append("\x3\xB7\x5\xB7\xBC2\n\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB8");
		sb.Append("\x3\xB8\x3\xB8\x3\xB8\x3\xB8\a\xB8\xBCD\n\xB8\f\xB8\xE\xB8\xBD0");
		sb.Append("\v\xB8\x3\xB8\x3\xB8\x3\xB9\x3\xB9\x3\xB9\x3\xB9\x3\xB9\a\xB9");
		sb.Append("\xBD9\n\xB9\f\xB9\xE\xB9\xBDC\v\xB9\x3\xB9\x3\xB9\x5\xB9\xBE0");
		sb.Append("\n\xB9\x3\xB9\x3\xB9\x3\xB9\x3\xB9\x3\xB9\x3\xB9\a\xB9\xBE8");
		sb.Append("\n\xB9\f\xB9\xE\xB9\xBEB\v\xB9\x3\xB9\x3\xB9\x5\xB9\xBEF\n\xB9");
		sb.Append("\x5\xB9\xBF1\n\xB9\x3\xBA\x3\xBA\x3\xBA\x5\xBA\xBF6\n\xBA\x3");
		sb.Append("\xBA\x3\xBA\x5\xBA\xBFA\n\xBA\x3\xBA\x3\xBA\x3\xBA\x3\xBA\x5");
		sb.Append("\xBA\xC00\n\xBA\x3\xBA\x3\xBA\x5\xBA\xC04\n\xBA\x3\xBB\x3\xBB");
		sb.Append("\x3\xBB\x3\xBB\x3\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\a\xBC\xC0F");
		sb.Append("\n\xBC\f\xBC\xE\xBC\xC12\v\xBC\x3\xBC\x5\xBC\xC15\n\xBC\x3\xBC");
		sb.Append("\x3\xBC\x3\xBC\x3\xBC\x3\xBC\x3\xBC\a\xBC\xC1D\n\xBC\f\xBC\xE");
		sb.Append("\xBC\xC20\v\xBC\x5\xBC\xC22\n\xBC\x5\xBC\xC24\n\xBC\x3\xBD\x3");
		sb.Append("\xBD\x3\xBD\x5\xBD\xC29\n\xBD\x3\xBE\x3\xBE\x3\xBE\x3\xBE\x3");
		sb.Append("\xBE\a\xBE\xC30\n\xBE\f\xBE\xE\xBE\xC33\v\xBE\x3\xBE\x3\xBE");
		sb.Append("\x3\xBF\x3\xBF\x3\xBF\x3\xBF\x3\xBF\x3\xBF\a\xBF\xC3D\n\xBF");
		sb.Append("\f\xBF\xE\xBF\xC40\v\xBF\x3\xBF\x3\xBF\x3\xC0\x3\xC0\x3\xC0");
		sb.Append("\x5\xC0\xC47\n\xC0\x3\xC1\x3\xC1\x3\xC1\x3\xC2\x3\xC2\a\xC2");
		sb.Append("\xC4E\n\xC2\f\xC2\xE\xC2\xC51\v\xC2\x3\xC2\x5\xC2\xC54\n\xC2");
		sb.Append("\x3\xC2\a\xC2\xC57\n\xC2\f\xC2\xE\xC2\xC5A\v\xC2\x3\xC2\x3\xC2");
		sb.Append("\x3\xC3\x3\xC3\x3\xC3\x3\xC3\x3\xC3\x3\xC3\x5\xC3\xC64\n\xC3");
		sb.Append("\x5\xC3\xC66\n\xC3\x3\xC4\x3\xC4\x3\xC4\x3\xC4\x3\xC5\x3\xC5");
		sb.Append("\x3\xC5\x3\xC5\x3\xC5\x3\xC5\x3\xC5\x3\xC5\a\xC5\xC74\n\xC5");
		sb.Append("\f\xC5\xE\xC5\xC77\v\xC5\x3\xC6\x3\xC6\x5\xC6\xC7B\n\xC6\x3");
		sb.Append("\xC6\x3\xC6\a\xC6\xC7F\n\xC6\f\xC6\xE\xC6\xC82\v\xC6\x3\xC6");
		sb.Append("\x3\xC6\x3\xC7\x5\xC7\xC87\n\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7");
		sb.Append("\x3\xC7\x3\xC7\x3\xC8\x3\xC8\x3\xC8\x3\xC8\x3\xC9\x3\xC9\x3");
		sb.Append("\xC9\x3\xC9\a\xC9\xC97\n\xC9\f\xC9\xE\xC9\xC9A\v\xC9\x3\xC9");
		sb.Append("\x3\xC9\x3\xCA\x3\xCA\x5\xCA\xCA0\n\xCA\x3\xCB\x5\xCB\xCA3\n");
		sb.Append("\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\a\xCB\xCA9\n\xCB\f\xCB\xE\xCB");
		sb.Append("\xCAC\v\xCB\x3\xCB\x3\xCB\x3\xCC\x3\xCC\x3\xCC\x3\xCC\x5\xCC");
		sb.Append("\xCB4\n\xCC\x5\xCC\xCB6\n\xCC\x3\xCC\x3\xCC\x5\xCC\xCBA\n\xCC");
		sb.Append("\x3\xCC\x5\xCC\xCBD\n\xCC\x3\xCD\x3\xCD\x3\xCD\x5\xCD\xCC2\n");
		sb.Append("\xCD\x5\xCD\xCC4\n\xCD\x3\xCD\x3\xCD\x5\xCD\xCC8\n\xCD\x3\xCD");
		sb.Append("\x3\xCD\x3\xCD\x3\xCE\x3\xCE\x3\xCF\x3\xCF\x3\xCF\x3\xCF\x3");
		sb.Append("\xCF\x5\xCF\xCD4\n\xCF\x3\xD0\x3\xD0\x3\xD0\x3\xD0\x3\xD0\x3");
		sb.Append("\xD1\x3\xD1\x5\xD1\xCDD\n\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD1\a");
		sb.Append("\xD1\xCE3\n\xD1\f\xD1\xE\xD1\xCE6\v\xD1\x3\xD2\x3\xD2\x5\xD2");
		sb.Append("\xCEA\n\xD2\x3\xD2\x3\xD2\x5\xD2\xCEE\n\xD2\x3\xD3\x3\xD3\x3");
		sb.Append("\xD3\x5\xD3\xCF3\n\xD3\x3\xD3\x5\xD3\xCF6\n\xD3\x3\xD4\x3\xD4");
		sb.Append("\x3\xD4\x3\xD4\a\xD4\xCFC\n\xD4\f\xD4\xE\xD4\xCFF\v\xD4\x3\xD5");
		sb.Append("\x3\xD5\x3\xD5\x3\xD5\x3\xD5\x5\xD5\xD06\n\xD5\x3\xD6\x3\xD6");
		sb.Append("\x3\xD6\x3\xD6\x5\xD6\xD0C\n\xD6\x3\xD6\x5\xD6\xD0F\n\xD6\x3");
		sb.Append("\xD6\x5\xD6\xD12\n\xD6\x3\xD7\x3\xD7\x3\xD7\x3\xD7\a\xD7\xD18");
		sb.Append("\n\xD7\f\xD7\xE\xD7\xD1B\v\xD7\x3\xD7\x3\xD7\x3\xD7\x3\xD7\x3");
		sb.Append("\xD7\x3\xD7\x3\xD7\x5\xD7\xD24\n\xD7\x3\xD8\x3\xD8\x3\xD8\x3");
		sb.Append("\xD8\x3\xD8\x3\xD8\x3\xD8\x3\xD8\a\xD8\xD2E\n\xD8\f\xD8\xE\xD8");
		sb.Append("\xD31\v\xD8\x3\xD8\x3\xD8\x3\xD8\x3\xD8\x5\xD8\xD37\n\xD8\x3");
		sb.Append("\xD9\x3\xD9\x5\xD9\xD3B\n\xD9\x3\xD9\x3\xD9\x5\xD9\xD3F\n\xD9");
		sb.Append("\x3\xD9\x5\xD9\xD42\n\xD9\x3\xD9\x5\xD9\xD45\n\xD9\x3\xDA\x3");
		sb.Append("\xDA\x3\xDA\x5\xDA\xD4A\n\xDA\x3\xDB\x3\xDB\x3\xDB\x5\xDB\xD4F");
		sb.Append("\n\xDB\x3\xDB\x5\xDB\xD52\n\xDB\x3\xDB\x5\xDB\xD55\n\xDB\x3");
		sb.Append("\xDC\x3\xDC\x6\xDC\xD59\n\xDC\r\xDC\xE\xDC\xD5A\x3\xDC\x5\xDC");
		sb.Append("\xD5E\n\xDC\x3\xDC\x3\xDC\x3\xDD\x3\xDD\x5\xDD\xD64\n\xDD\x3");
		sb.Append("\xDD\x5\xDD\xD67\n\xDD\x3\xDE\x5\xDE\xD6A\n\xDE\x3\xDE\x6\xDE");
		sb.Append("\xD6D\n\xDE\r\xDE\xE\xDE\xD6E\x3\xDE\x5\xDE\xD72\n\xDE\x3\xDF");
		sb.Append("\x3\xDF\x3\xDF\x3\xDF\x6\xDF\xD78\n\xDF\r\xDF\xE\xDF\xD79\x3");
		sb.Append("\xE0\x3\xE0\x6\xE0\xD7E\n\xE0\r\xE0\xE\xE0\xD7F\x3\xE1\x3\xE1");
		sb.Append("\x3\xE1\x3\xE1\x3\xE1\x3\xE1\a\xE1\xD88\n\xE1\f\xE1\xE\xE1\xD8B");
		sb.Append("\v\xE1\x3\xE1\x3\xE1\x5\xE1\xD8F\n\xE1\x3\xE2\x3\xE2\x3\xE2");
		sb.Append("\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x5\xE3\xD98\n\xE3\x3\xE3\x3\xE3");
		sb.Append("\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x5\xE3\xDA2\n\xE3");
		sb.Append("\x3\xE3\x3\xE3\x5\xE3\xDA6\n\xE3\x5\xE3\xDA8\n\xE3\x3\xE3\x5");
		sb.Append("\xE3\xDAB\n\xE3\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3\xE4\x3");
		sb.Append("\xE4\x3\xE4\a\xE4\xDB5\n\xE4\f\xE4\xE\xE4\xDB8\v\xE4\x3\xE4");
		sb.Append("\x5\xE4\xDBB\n\xE4\x3\xE4\x5\xE4\xDBE\n\xE4\x3\xE5\x3\xE5\x3");
		sb.Append("\xE5\x3\xE5\x3\xE6\x3\xE6\x3\xE6\x3\xE7\x3\xE7\x3\xE7\x3\xE7");
		sb.Append("\x3\xE7\x3\xE7\x3\xE7\x3\xE7\x3\xE7\a\xE7\xDD0\n\xE7\f\xE7\xE");
		sb.Append("\xE7\xDD3\v\xE7\x3\xE7\x3\xE7\x5\xE7\xDD7\n\xE7\x3\xE7\x3\xE7");
		sb.Append("\x3\xE7\x5\xE7\xDDC\n\xE7\x3\xE8\x3\xE8\x3\xE8\x3\xE8\x3\xE8");
		sb.Append("\x5\xE8\xDE3\n\xE8\x3\xE8\x5\xE8\xDE6\n\xE8\x3\xE9\x3\xE9\x3");
		sb.Append("\xE9\x3\xE9\x3\xE9\a\xE9\xDED\n\xE9\f\xE9\xE\xE9\xDF0\v\xE9");
		sb.Append("\x3\xE9\x3\xE9\x3\xE9\x3\xE9\x5\xE9\xDF6\n\xE9\x3\xEA\x3\xEA");
		sb.Append("\x3\xEA\x5\xEA\xDFB\n\xEA\x3\xEB\x3\xEB\x5\xEB\xDFF\n\xEB\x3");
		sb.Append("\xEC\x3\xEC\x3\xEC\x3\xEC\x3\xEC\x3\xEC\x5\xEC\xE07\n\xEC\x3");
		sb.Append("\xEC\x3\xEC\x3\xEC\x3\xEC\x5\xEC\xE0D\n\xEC\x3\xED\x3\xED\x3");
		sb.Append("\xED\x3\xED\x3\xED\x3\xED\x5\xED\xE15\n\xED\x3\xED\x5\xED\xE18");
		sb.Append("\n\xED\x3\xEE\x3\xEE\x3\xEE\x3\xEE\a\xEE\xE1E\n\xEE\f\xEE\xE");
		sb.Append("\xEE\xE21\v\xEE\x3\xEE\x3\xEE\x3\xEF\x3\xEF\x3\xEF\x5\xEF\xE28");
		sb.Append("\n\xEF\x3\xEF\x5\xEF\xE2B\n\xEF\x3\xEF\x5\xEF\xE2E\n\xEF\x3");
		sb.Append("\xF0\x3\xF0\x3\xF0\x3\xF1\x3\xF1\x3\xF1\x3\xF1\x5\xF1\xE37\n");
		sb.Append("\xF1\x3\xF2\x3\xF2\x3\xF2\x3\xF2\x5\xF2\xE3D\n\xF2\x3\xF2\x3");
		sb.Append("\xF2\x3\xF2\x3\xF2\x5\xF2\xE43\n\xF2\x5\xF2\xE45\n\xF2\x3\xF3");
		sb.Append("\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x3\xF3\x3");
		sb.Append("\xF3\x3\xF3\x5\xF3\xE52\n\xF3\x5\xF3\xE54\n\xF3\x3\xF4\x3\xF4");
		sb.Append("\x3\xF4\x3\xF4\x3\xF4\x3\xF4\x3\xF4\x5\xF4\xE5D\n\xF4\x5\xF4");
		sb.Append("\xE5F\n\xF4\x3\xF5\x3\xF5\x5\xF5\xE63\n\xF5\x3\xF5\x3\xF5\x3");
		sb.Append("\xF5\x3\xF5\x5\xF5\xE69\n\xF5\x3\xF5\x3\xF5\x5\xF5\xE6D\n\xF5");
		sb.Append("\x3\xF6\x3\xF6\x3\xF6\x3\xF6\x3\xF6\x3\xF7\x3\xF7\x3\xF7\x3");
		sb.Append("\xF7\x3\xF7\x3\xF8\x3\xF8\x5\xF8\xE7B\n\xF8\x3\xF8\x3\xF8\a");
		sb.Append("\xF8\xE7F\n\xF8\f\xF8\xE\xF8\xE82\v\xF8\x3\xF8\x3\xF8\x3\xF9");
		sb.Append("\x3\xF9\x3\xFA\x3\xFA\x3\xFB\x3\xFB\x3\xFB\x3\xFB\a\xFB\xE8E");
		sb.Append("\n\xFB\f\xFB\xE\xFB\xE91\v\xFB\x5\xFB\xE93\n\xFB\x3\xFC\x3\xFC");
		sb.Append("\x3\xFD\x3\xFD\x3\xFD\a\xFD\xE9A\n\xFD\f\xFD\xE\xFD\xE9D\v\xFD");
		sb.Append("\x3\xFE\x3\xFE\x3\xFE\x5\xFE\xEA2\n\xFE\x3\xFF\x3\xFF\x3\xFF");
		sb.Append("\x5\xFF\xEA7\n\xFF\x3\xFF\x3\xFF\x3\xFF\x3\xFF\x3\xFF\x3\xFF");
		sb.Append("\x3\xFF\x3\xFF\x3\xFF\x5\xFF\xEB2\n\xFF\x3\xFF\x3\xFF\x5\xFF");
		sb.Append("\xEB6\n\xFF\x3\xFF\x3\xFF\x3\xFF\a\xFF\xEBB\n\xFF\f\xFF\xE\xFF");
		sb.Append("\xEBE\v\xFF\x3\xFF\x3\xFF\x5\xFF\xEC2\n\xFF\a\xFF\xEC4\n\xFF");
		sb.Append("\f\xFF\xE\xFF\xEC7\v\xFF\x3\x100\x3\x100\x3\x100\x5\x100\xECC");
		sb.Append("\n\x100\x3\x100\x3\x100\x5\x100\xED0\n\x100\x3\x101\x3\x101");
		sb.Append("\x3\x102\x3\x102\x3\x102\x3\x102\x3\x102\x3\x102\x3\x102\x5");
		sb.Append("\x102\xEDB\n\x102\x3\x102\a\x102\xEDE\n\x102\f\x102\xE\x102");
		sb.Append("\xEE1\v\x102\x3\x103\x3\x103\x5\x103\xEE5\n\x103\x3\x103\x3");
		sb.Append("\x103\x3\x103\x3\x103\x3\x103\x3\x103\x3\x103\x5\x103\xEEE\n");
		sb.Append("\x103\x5\x103\xEF0\n\x103\x5\x103\xEF2\n\x103\x3\x104\x3\x104");
		sb.Append("\x3\x105\x3\x105\x3\x105\x3\x106\x3\x106\x3\x106\x3\x106\x3");
		sb.Append("\x106\x3\x106\x3\x106\x3\x106\a\x106\xF01\n\x106\f\x106\xE\x106");
		sb.Append("\xF04\v\x106\x3\x106\x3\x106\x3\x106\x3\x106\x3\x106\x5\x106");
		sb.Append("\xF0B\n\x106\x3\x107\x3\x107\x3\x107\x3\x107\x3\x108\x3\x108");
		sb.Append("\x3\x108\x3\x108\a\x108\xF15\n\x108\f\x108\xE\x108\xF18\v\x108");
		sb.Append("\x3\x109\x3\x109\x3\x10A\x3\x10A\x3\x10A\a\x10A\xF1F\n\x10A");
		sb.Append("\f\x10A\xE\x10A\xF22\v\x10A\x3\x10B\x3\x10B\x3\x10B\a\x10B\xF27");
		sb.Append("\n\x10B\f\x10B\xE\x10B\xF2A\v\x10B\x3\x10C\x3\x10C\x3\x10C\x3");
		sb.Append("\x10C\x3\x10C\x3\x10C\x5\x10C\xF32\n\x10C\x3\x10C\x5\x10C\xF35");
		sb.Append("\n\x10C\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x5\x10D\xF3C");
		sb.Append("\n\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x5\x10D");
		sb.Append("\xF44\n\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x3\x10D\x5\x10D");
		sb.Append("\xF4B\n\x10D\x3\x10D\x3\x10D\x5\x10D\xF4F\n\x10D\x3\x10E\x3");
		sb.Append("\x10E\x3\x10E\x3\x10E\x3\x10E\x5\x10E\xF56\n\x10E\x3\x10F\x3");
		sb.Append("\x10F\x5\x10F\xF5A\n\x10F\x3\x10F\x3\x10F\x3\x10F\x5\x10F\xF5F");
		sb.Append("\n\x10F\a\x10F\xF61\n\x10F\f\x10F\xE\x10F\xF64\v\x10F\x3\x10F");
		sb.Append("\x3\x10F\x3\x10F\a\x10F\xF69\n\x10F\f\x10F\xE\x10F\xF6C\v\x10F");
		sb.Append("\x3\x10F\x5\x10F\xF6F\n\x10F\x3\x110\x3\x110\x3\x110\x3\x110");
		sb.Append("\x3\x110\x5\x110\xF76\n\x110\x3\x110\x3\x110\x3\x110\x3\x110");
		sb.Append("\x3\x110\x3\x110\x3\x110\x5\x110\xF7F\n\x110\x3\x111\x3\x111");
		sb.Append("\x3\x111\x3\x112\x3\x112\x3\x113\x3\x113\x3\x113\x3\x113\x3");
		sb.Append("\x113\a\x113\xF8B\n\x113\f\x113\xE\x113\xF8E\v\x113\x3\x113");
		sb.Append("\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113\x3\x113\a\x113");
		sb.Append("\xF98\n\x113\f\x113\xE\x113\xF9B\v\x113\x3\x113\x3\x113\x5\x113");
		sb.Append("\xF9F\n\x113\x3\x113\x3\x113\x3\x114\x3\x114\x3\x114\x3\x114");
		sb.Append("\x3\x114\x3\x114\x3\x114\x3\x114\x3\x114\x3\x114\x3\x114\x3");
		sb.Append("\x114\x3\x114\x3\x114\x3\x114\x3\x114\x3\x114\x3\x114\x5\x114");
		sb.Append("\xFB5\n\x114\x3\x115\x3\x115\x5\x115\xFB9\n\x115\x3\x116\x5");
		sb.Append("\x116\xFBC\n\x116\x3\x116\x3\x116\x3\x116\x6\x116\xFC1\n\x116");
		sb.Append("\r\x116\xE\x116\xFC2\x3\x116\x5\x116\xFC6\n\x116\x3\x116\x3");
		sb.Append("\x116\x5\x116\xFCA\n\x116\x3\x116\x5\x116\xFCD\n\x116\x3\x117");
		sb.Append("\x3\x117\x3\x117\x3\x117\x3\x117\x5\x117\xFD4\n\x117\x3\x118");
		sb.Append("\x5\x118\xFD7\n\x118\x3\x118\x3\x118\x6\x118\xFDB\n\x118\r\x118");
		sb.Append("\xE\x118\xFDC\x3\x118\x5\x118\xFE0\n\x118\x3\x118\x3\x118\x5");
		sb.Append("\x118\xFE4\n\x118\x3\x118\x5\x118\xFE7\n\x118\x3\x119\x3\x119");
		sb.Append("\x3\x119\x3\x119\x3\x119\x5\x119\xFEE\n\x119\x3\x11A\x3\x11A");
		sb.Append("\x3\x11A\x5\x11A\xFF3\n\x11A\x3\x11B\x3\x11B\x3\x11B\x3\x11B");
		sb.Append("\x3\x11B\x3\x11B\x3\x11B\x3\x11B\x3\x11B\x3\x11B\a\x11B\xFFF");
		sb.Append("\n\x11B\f\x11B\xE\x11B\x1002\v\x11B\x3\x11B\x3\x11B\x3\x11B");
		sb.Append("\x5\x11B\x1007\n\x11B\x5\x11B\x1009\n\x11B\x3\x11C\x3\x11C\x5");
		sb.Append("\x11C\x100D\n\x11C\x3\x11D\x3\x11D\x3\x11D\x3\x11D\a\x11D\x1013");
		sb.Append("\n\x11D\f\x11D\xE\x11D\x1016\v\x11D\x3\x11E\x3\x11E\x3\x11E");
		sb.Append("\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x3\x11E\x5\x11E\x1021");
		sb.Append("\n\x11E\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1026\n\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x5\x11F\x102B\n\x11F\x3\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x5\x11F\x1031\n\x11F\x3\x11F\x5\x11F\x1034\n\x11F\x3");
		sb.Append("\x11F\x3\x11F\x5\x11F\x1038\n\x11F\x3\x11F\x3\x11F\x3\x11F\x3");
		sb.Append("\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1042\n\x11F\x3");
		sb.Append("\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1052");
		sb.Append("\n\x11F\x3\x11F\x3\x11F\x5\x11F\x1056\n\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x6\x11F\x105D\n\x11F\r\x11F\xE\x11F");
		sb.Append("\x105E\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1065\n\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3");
		sb.Append("\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1073\n\x11F\x3");
		sb.Append("\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\a\x11F");
		sb.Append("\x107C\n\x11F\f\x11F\xE\x11F\x107F\v\x11F\x3\x11F\x5\x11F\x1082");
		sb.Append("\n\x11F\x3\x11F\x5\x11F\x1085\n\x11F\x3\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x108E\n\x11F\x3\x11F");
		sb.Append("\x3\x11F\a\x11F\x1092\n\x11F\f\x11F\xE\x11F\x1095\v\x11F\x3");
		sb.Append("\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F");
		sb.Append("\x109E\n\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F");
		sb.Append("\x5\x11F\x10A6\n\x11F\x3\x11F\x5\x11F\x10A9\n\x11F\x3\x11F\x5");
		sb.Append("\x11F\x10AC\n\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3");
		sb.Append("\x11F\x3\x11F\x5\x11F\x10B5\n\x11F\x3\x11F\x3\x11F\x3\x11F\x5");
		sb.Append("\x11F\x10BA\n\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\a");
		sb.Append("\x11F\x10C1\n\x11F\f\x11F\xE\x11F\x10C4\v\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x5\x11F\x10C9\n\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F");
		sb.Append("\x10CE\n\x11F\x3\x11F\x5\x11F\x10D1\n\x11F\x3\x11F\x3\x11F\x3");
		sb.Append("\x11F\x5\x11F\x10D6\n\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x10DB");
		sb.Append("\n\x11F\a\x11F\x10DD\n\x11F\f\x11F\xE\x11F\x10E0\v\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x5\x11F\x10E5\n\x11F\x3\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x5\x11F\x10EB\n\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x10F4\n\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x5\x11F\x10F9\n\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x5\x11F\x1101\n\x11F\x3\x11F\x3\x11F\x5\x11F");
		sb.Append("\x1105\n\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x110A\n\x11F\x3");
		sb.Append("\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1110\n\x11F\x3\x11F\x3");
		sb.Append("\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1117\n\x11F\x3\x11F\x3");
		sb.Append("\x11F\x3\x11F\x5\x11F\x111C\n\x11F\x3\x11F\x3\x11F\x3\x11F\x3");
		sb.Append("\x11F\x3\x11F\x5\x11F\x1123\n\x11F\x3\x11F\x3\x11F\x5\x11F\x1127");
		sb.Append("\n\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x112C\n\x11F\x3\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1134\n\x11F");
		sb.Append("\x3\x11F\x5\x11F\x1137\n\x11F\x3\x11F\x5\x11F\x113A\n\x11F\x3");
		sb.Append("\x11F\x5\x11F\x113D\n\x11F\x3\x11F\x3\x11F\x5\x11F\x1141\n\x11F");
		sb.Append("\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1146\n\x11F\x3\x11F\x3\x11F");
		sb.Append("\x3\x11F\x5\x11F\x114B\n\x11F\x3\x11F\x3\x11F\x5\x11F\x114F");
		sb.Append("\n\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x1156");
		sb.Append("\n\x11F\x3\x11F\x3\x11F\x3\x11F\x5\x11F\x115B\n\x11F\x5\x11F");
		sb.Append("\x115D\n\x11F\x3\x120\x3\x120\x3\x121\x3\x121\x3\x122\x3\x122");
		sb.Append("\x3\x123\x3\x123\x3\x123\x5\x123\x1168\n\x123\x3\x123\x3\x123");
		sb.Append("\x5\x123\x116C\n\x123\x5\x123\x116E\n\x123\x3\x123\x3\x123\x3");
		sb.Append("\x124\x3\x124\x3\x124\x3\x124\x3\x124\x3\x124\x3\x124\x5\x124");
		sb.Append("\x1179\n\x124\x3\x125\x3\x125\x3\x126\x3\x126\x3\x126\x3\x126");
		sb.Append("\x3\x126\x3\x126\x3\x126\x5\x126\x1184\n\x126\x3\x127\x3\x127");
		sb.Append("\x3\x127\x3\x127\x3\x127\a\x127\x118B\n\x127\f\x127\xE\x127");
		sb.Append("\x118E\v\x127\x5\x127\x1190\n\x127\x3\x128\x3\x128\x5\x128\x1194");
		sb.Append("\n\x128\x3\x128\x5\x128\x1197\n\x128\x3\x128\x3\x128\x5\x128");
		sb.Append("\x119B\n\x128\x3\x129\x3\x129\x3\x129\x3\x129\x3\x12A\x3\x12A");
		sb.Append("\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x3\x12A\x5\x12A\x11A8\n\x12A");
		sb.Append("\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x11AD\n\x12B\x3\x12B\x3\x12B");
		sb.Append("\x3\x12B\x3\x12B\a\x12B\x11B3\n\x12B\f\x12B\xE\x12B\x11B6\v");
		sb.Append("\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x11BC\n\x12B\x3");
		sb.Append("\x12C\x3\x12C\x3\x12C\x5\x12C\x11C1\n\x12C\x3\x12C\x3\x12C\x5");
		sb.Append("\x12C\x11C5\n\x12C\x3\x12C\x3\x12C\x3\x12C\x5\x12C\x11CA\n\x12C");
		sb.Append("\x3\x12D\x3\x12D\x3\x12D\x5\x12D\x11CF\n\x12D\x3\x12D\x5\x12D");
		sb.Append("\x11D2\n\x12D\x3\x12D\x3\x12D\x3\x12D\a\x12D\x11D7\n\x12D\f");
		sb.Append("\x12D\xE\x12D\x11DA\v\x12D\x3\x12D\x3\x12D\x3\x12E\x3\x12E\x3");
		sb.Append("\x12E\x3\x12E\x3\x12E\x5\x12E\x11E3\n\x12E\x3\x12E\x3\x12E\x3");
		sb.Append("\x12E\x3\x12E\a\x12E\x11E9\n\x12E\f\x12E\xE\x12E\x11EC\v\x12E");
		sb.Append("\x3\x12E\x5\x12E\x11EF\n\x12E\x3\x12E\x3\x12E\x3\x12F\x3\x12F");
		sb.Append("\x3\x12F\x3\x12F\x3\x12F\x3\x12F\x5\x12F\x11F9\n\x12F\x3\x12F");
		sb.Append("\x5\x12F\x11FC\n\x12F\x5\x12F\x11FE\n\x12F\x3\x130\x3\x130\x3");
		sb.Append("\x130\x3\x131\x3\x131\x3\x131\x3\x131\x3\x131\x5\x131\x1208");
		sb.Append("\n\x131\x5\x131\x120A\n\x131\x3\x132\x3\x132\x3\x132\x3\x132");
		sb.Append("\x5\x132\x1210\n\x132\x3\x133\x3\x133\x3\x133\x3\x133\x5\x133");
		sb.Append("\x1216\n\x133\x5\x133\x1218\n\x133\x3\x134\x3\x134\x3\x134\x3");
		sb.Append("\x135\x3\x135\x3\x135\x3\x136\x3\x136\x3\x136\x3\x136\x3\x136");
		sb.Append("\x3\x136\x5\x136\x1226\n\x136\x5\x136\x1228\n\x136\x3\x137\x3");
		sb.Append("\x137\x3\x137\x3\x137\x3\x137\x3\x137\x5\x137\x1230\n\x137\x3");
		sb.Append("\x137\x5\x137\x1233\n\x137\x3\x138\x3\x138\x3\x138\x3\x138\x3");
		sb.Append("\x138\x3\x138\x3\x138\x5\x138\x123C\n\x138\x3\x139\x3\x139\x3");
		sb.Append("\x139\x3\x139\x3\x139\x3\x139\x3\x139\x5\x139\x1245\n\x139\x3");
		sb.Append("\x13A\x3\x13A\x3\x13B\x3\x13B\x3\x13C\x3\x13C\x3\x13C\x3\x13C");
		sb.Append("\x5\x13C\x124F\n\x13C\x3\x13D\x3\x13D\x5\x13D\x1253\n\x13D\x3");
		sb.Append("\x13D\x3\x13D\x3\x13E\x5\x13E\x1258\n\x13E\x3\x13E\x3\x13E\x5");
		sb.Append("\x13E\x125C\n\x13E\x3\x13E\x5\x13E\x125F\n\x13E\x3\x13F\x3\x13F");
		sb.Append("\x5\x13F\x1263\n\x13F\x3\x140\x3\x140\x3\x141\x3\x141\x3\x141");
		sb.Append("\x5\x141\x126A\n\x141\x3\x142\x3\x142\x3\x142\x3\x142\x3\x143");
		sb.Append("\x3\x143\x3\x143\x3\x143\a\x143\x1274\n\x143\f\x143\xE\x143");
		sb.Append("\x1277\v\x143\x3\x143\x3\x143\x3\x143\x3\x143\x3\x143\x3\x143");
		sb.Append("\a\x143\x127F\n\x143\f\x143\xE\x143\x1282\v\x143\x5\x143\x1284");
		sb.Append("\n\x143\x3\x144\x3\x144\x5\x144\x1288\n\x144\x3\x145\x3\x145");
		sb.Append("\x3\x146\x3\x146\x3\x147\x3\x147\x3\x148\x3\x148\x3\x149\x3");
		sb.Append("\x149\x3\x14A\x3\x14A\x3\x14B\x3\x14B\x3\x14B\a\x14B\x1299\n");
		sb.Append("\x14B\f\x14B\xE\x14B\x129C\v\x14B\x3\x14B\x3\x14B\x5\x14B\x12A0");
		sb.Append("\n\x14B\x3\x14C\x3\x14C\x3\x14D\x3\x14D\x3\x14D\x5\x14D\x12A7");
		sb.Append("\n\x14D\x3\x14E\x3\x14E\x3\x14F\x3\x14F\x3\x150\x3\x150\x3\x151");
		sb.Append("\x3\x151\x3\x151\a\x151\x12B2\n\x151\f\x151\xE\x151\x12B5\v");
		sb.Append("\x151\x3\x152\x3\x152\x3\x153\x3\x153\x3\x153\a\x153\x12BC\n");
		sb.Append("\x153\f\x153\xE\x153\x12BF\v\x153\x3\x153\x3\x153\x5\x153\x12C3");
		sb.Append("\n\x153\x3\x154\x3\x154\x3\x155\x3\x155\x3\x155\a\x155\x12CA");
		sb.Append("\n\x155\f\x155\xE\x155\x12CD\v\x155\x3\x156\x3\x156\x3\x156");
		sb.Append("\a\x156\x12D2\n\x156\f\x156\xE\x156\x12D5\v\x156\x3\x157\x3");
		sb.Append("\x157\x3\x157\a\x157\x12DA\n\x157\f\x157\xE\x157\x12DD\v\x157");
		sb.Append("\x3\x158\x3\x158\x3\x158\x5\x158\x12E2\n\x158\x3\x159\x3\x159");
		sb.Append("\x3\x159\x5\x159\x12E7\n\x159\x3\x15A\x3\x15A\x3\x15A\x5\x15A");
		sb.Append("\x12EC\n\x15A\x3\x15B\x3\x15B\x5\x15B\x12F0\n\x15B\x3\x15B\x3");
		sb.Append("\x15B\x3\x15B\x5\x15B\x12F5\n\x15B\x3\x15B\x5\x15B\x12F8\n\x15B");
		sb.Append("\x3\x15C\x3\x15C\x3\x15D\x3\x15D\x5\x15D\x12FE\n\x15D\x3\x15E");
		sb.Append("\x3\x15E\x5\x15E\x1302\n\x15E\x3\x15F\x3\x15F\x3\x15F\x5\x15F");
		sb.Append("\x1307\n\x15F\x3\x160\x3\x160\x3\x161\x3\x161\x3\x161\a\x161");
		sb.Append("\x130E\n\x161\f\x161\xE\x161\x1311\v\x161\x3\x162\x3\x162\x3");
		sb.Append("\x162\x5\x162\x1316\n\x162\x3\x162\x3\x162\x3\x162\x5\x162\x131B");
		sb.Append("\n\x162\x3\x163\x3\x163\x3\x163\a\x163\x1320\n\x163\f\x163\xE");
		sb.Append("\x163\x1323\v\x163\x3\x164\x3\x164\x3\x164\x3\x164\x3\x164\x3");
		sb.Append("\x164\x3\x164\x5\x164\x132C\n\x164\x3\x165\x3\x165\x5\x165\x1330");
		sb.Append("\n\x165\x3\x165\x3\x165\a\x165\x1334\n\x165\f\x165\xE\x165\x1337");
		sb.Append("\v\x165\x3\x165\x3\x165\x5\x165\x133B\n\x165\x3\x166\x3\x166");
		sb.Append("\x3\x166\x5\x166\x1340\n\x166\x5\x166\x1342\n\x166\x3\x166\x3");
		sb.Append("\x166\x3\x166\x5\x166\x1347\n\x166\a\x166\x1349\n\x166\f\x166");
		sb.Append("\xE\x166\x134C\v\x166\x3\x166\x3\x166\x5\x166\x1350\n\x166\x3");
		sb.Append("\x167\x3\x167\x3\x167\x3\x167\x3\x167\x5\x167\x1357\n\x167\x3");
		sb.Append("\x167\x3\x167\x3\x167\x5\x167\x135C\n\x167\x5\x167\x135E\n\x167");
		sb.Append("\x5\x167\x1360\n\x167\x3\x167\x3\x167\x3\x167\x3\x167\x3\x167");
		sb.Append("\x3\x167\x3\x167\x3\x167\x5\x167\x136A\n\x167\x3\x167\x3\x167");
		sb.Append("\x3\x167\x5\x167\x136F\n\x167\a\x167\x1371\n\x167\f\x167\xE");
		sb.Append("\x167\x1374\v\x167\x5\x167\x1376\n\x167\x3\x167\x3\x167\x5\x167");
		sb.Append("\x137A\n\x167\x3\x168\x3\x168\x3\x168\x3\x169\x3\x169\x3\x169");
		sb.Append("\x3\x169\x5\x169\x1383\n\x169\x3\x169\x3\x169\x3\x16A\x3\x16A");
		sb.Append("\x5\x16A\x1389\n\x16A\x3\x16A\x3\x16A\x5\x16A\x138D\n\x16A\x5");
		sb.Append("\x16A\x138F\n\x16A\x3\x16B\x3\x16B\x5\x16B\x1393\n\x16B\x3\x16B");
		sb.Append("\x3\x16B\x5\x16B\x1397\n\x16B\x3\x16B\x3\x16B\x5\x16B\x139B");
		sb.Append("\n\x16B\x3\x16B\x3\x16B\x3\x16B\x3\x16B\x3\x16B\x3\x16B\x5\x16B");
		sb.Append("\x13A3\n\x16B\x3\x16B\x3\x16B\x3\x16B\x3\x16B\x3\x16B\x3\x16B");
		sb.Append("\x5\x16B\x13AB\n\x16B\x5\x16B\x13AD\n\x16B\x3\x16C\x3\x16C\x3");
		sb.Append("\x16C\x3\x16C\x5\x16C\x13B3\n\x16C\x3\x16C\x5\x16C\x13B6\n\x16C");
		sb.Append("\x3\x16C\x3\x16C\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3");
		sb.Append("\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D");
		sb.Append("\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x5");
		sb.Append("\x16D\x13CE\n\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x5");
		sb.Append("\x16D\x13D5\n\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3");
		sb.Append("\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D");
		sb.Append("\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3");
		sb.Append("\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D\x3\x16D");
		sb.Append("\x3\x16D\x3\x16D\x3\x16D\x5\x16D\x13F6\n\x16D\x3\x16E\x3\x16E");
		sb.Append("\x3\x16E\x5\x16E\x13FB\n\x16E\x3\x16E\x5\x16E\x13FE\n\x16E\x3");
		sb.Append("\x16E\x3\x16E\x3\x16E\x5\x16E\x1403\n\x16E\x5\x16E\x1405\n\x16E");
		sb.Append("\x3\x16E\x3\x16E\a\x16E\x1409\n\x16E\f\x16E\xE\x16E\x140C\v");
		sb.Append("\x16E\x3\x16F\x3\x16F\x3\x16F\a\x16F\x1411\n\x16F\f\x16F\xE");
		sb.Append("\x16F\x1414\v\x16F\x3\x170\x3\x170\x5\x170\x1418\n\x170\x3\x170");
		sb.Append("\x3\x170\x3\x170\a\x170\x141D\n\x170\f\x170\xE\x170\x1420\v");
		sb.Append("\x170\x3\x170\x5\x170\x1423\n\x170\x3\x171\x3\x171\x5\x171\x1427");
		sb.Append("\n\x171\x3\x171\x3\x171\x3\x171\a\x171\x142C\n\x171\f\x171\xE");
		sb.Append("\x171\x142F\v\x171\x3\x172\x3\x172\x3\x172\x5\x172\x1434\n\x172");
		sb.Append("\x3\x172\x3\x172\x3\x172\x3\x172\x5\x172\x143A\n\x172\x3\x172");
		sb.Append("\x3\x172\x3\x172\x3\x172\x5\x172\x1440\n\x172\x3\x172\x3\x172");
		sb.Append("\x3\x172\x3\x172\x5\x172\x1446\n\x172\x3\x172\x3\x172\x3\x172");
		sb.Append("\x5\x172\x144B\n\x172\x5\x172\x144D\n\x172\x3\x172\x5\x172\x1450");
		sb.Append("\n\x172\x3\x172\x3\x172\x3\x172\x3\x172\x3\x172\x3\x172\x3\x172");
		sb.Append("\x3\x172\x5\x172\x145A\n\x172\x3\x172\x5\x172\x145D\n\x172\x5");
		sb.Append("\x172\x145F\n\x172\x5\x172\x1461\n\x172\x3\x172\x3\x172\x3\x172");
		sb.Append("\x3\x172\x3\x172\x3\x172\x3\x172\x3\x172\x3\x172\x3\x172\x3");
		sb.Append("\x172\x3\x172\x5\x172\x146F\n\x172\x3\x173\x3\x173\x3\x174\x3");
		sb.Append("\x174\x3\x174\x3\x175\x3\x175\x3\x176\x3\x176\x5\x176\x147A");
		sb.Append("\n\x176\x3\x176\x3\x176\x3\x177\x3\x177\x5\x177\x1480\n\x177");
		sb.Append("\x3\x178\x3\x178\x3\x178\x3\x178\x3\x178\x3\x178\x3\x178\x5");
		sb.Append("\x178\x1489\n\x178\x3\x179\x3\x179\x3\x179\x5\x179\x148E\n\x179");
		sb.Append("\x3\x17A\x3\x17A\x3\x17A\x5\x17A\x1493\n\x17A\x3\x17B\x3\x17B");
		sb.Append("\x3\x17B\x5\x17B\x1498\n\x17B\x3\x17C\x3\x17C\x3\x17C\x3\x17C");
		sb.Append("\x3\x17D\x3\x17D\x3\x17D\x2\x2\x17E\x2\x4\x6\b\n\f\xE\x10\x12");
		sb.Append("\x14\x16\x18\x1A\x1C\x1E \"$&(*,.\x30\x32\x34\x36\x38:<>@\x42");
		sb.Append("\x44\x46HJLNPRTVXZ\\^`\x62\x64\x66hjlnprtvxz|~\x80\x82\x84\x86");
		sb.Append("\x88\x8A\x8C\x8E\x90\x92\x94\x96\x98\x9A\x9C\x9E\xA0\xA2\xA4");
		sb.Append("\xA6\xA8\xAA\xAC\xAE\xB0\xB2\xB4\xB6\xB8\xBA\xBC\xBE\xC0\xC2");
		sb.Append("\xC4\xC6\xC8\xCA\xCC\xCE\xD0\xD2\xD4\xD6\xD8\xDA\xDC\xDE\xE0");
		sb.Append("\xE2\xE4\xE6\xE8\xEA\xEC\xEE\xF0\xF2\xF4\xF6\xF8\xFA\xFC\xFE");
		sb.Append("\x100\x102\x104\x106\x108\x10A\x10C\x10E\x110\x112\x114\x116");
		sb.Append("\x118\x11A\x11C\x11E\x120\x122\x124\x126\x128\x12A\x12C\x12E");
		sb.Append("\x130\x132\x134\x136\x138\x13A\x13C\x13E\x140\x142\x144\x146");
		sb.Append("\x148\x14A\x14C\x14E\x150\x152\x154\x156\x158\x15A\x15C\x15E");
		sb.Append("\x160\x162\x164\x166\x168\x16A\x16C\x16E\x170\x172\x174\x176");
		sb.Append("\x178\x17A\x17C\x17E\x180\x182\x184\x186\x188\x18A\x18C\x18E");
		sb.Append("\x190\x192\x194\x196\x198\x19A\x19C\x19E\x1A0\x1A2\x1A4\x1A6");
		sb.Append("\x1A8\x1AA\x1AC\x1AE\x1B0\x1B2\x1B4\x1B6\x1B8\x1BA\x1BC\x1BE");
		sb.Append("\x1C0\x1C2\x1C4\x1C6\x1C8\x1CA\x1CC\x1CE\x1D0\x1D2\x1D4\x1D6");
		sb.Append("\x1D8\x1DA\x1DC\x1DE\x1E0\x1E2\x1E4\x1E6\x1E8\x1EA\x1EC\x1EE");
		sb.Append("\x1F0\x1F2\x1F4\x1F6\x1F8\x1FA\x1FC\x1FE\x200\x202\x204\x206");
		sb.Append("\x208\x20A\x20C\x20E\x210\x212\x214\x216\x218\x21A\x21C\x21E");
		sb.Append("\x220\x222\x224\x226\x228\x22A\x22C\x22E\x230\x232\x234\x236");
		sb.Append("\x238\x23A\x23C\x23E\x240\x242\x244\x246\x248\x24A\x24C\x24E");
		sb.Append("\x250\x252\x254\x256\x258\x25A\x25C\x25E\x260\x262\x264\x266");
		sb.Append("\x268\x26A\x26C\x26E\x270\x272\x274\x276\x278\x27A\x27C\x27E");
		sb.Append("\x280\x282\x284\x286\x288\x28A\x28C\x28E\x290\x292\x294\x296");
		sb.Append("\x298\x29A\x29C\x29E\x2A0\x2A2\x2A4\x2A6\x2A8\x2AA\x2AC\x2AE");
		sb.Append("\x2B0\x2B2\x2B4\x2B6\x2B8\x2BA\x2BC\x2BE\x2C0\x2C2\x2C4\x2C6");
		sb.Append("\x2C8\x2CA\x2CC\x2CE\x2D0\x2D2\x2D4\x2D6\x2D8\x2DA\x2DC\x2DE");
		sb.Append("\x2E0\x2E2\x2E4\x2E6\x2E8\x2EA\x2EC\x2EE\x2F0\x2F2\x2F4\x2F6");
		sb.Append("\x2F8\x2R\x3\x2\x1F7\x1F7\x4\x2\xF\xF\xBC\xBC\x4\x2\b\b\x11D");
		sb.Append("\x11D\x4\x2\x9F\x9F\x12A\x12A\x4\x2\x38\x38\x10D\x10D\x5\x2");
		sb.Append("##\x114\x114\x167\x167\x4\x2mmyy\x4\x2\x6\x6\x1A\x1A\x5\x2h");
		sb.Append("h\xB3\xB3\x195\x195\x5\x2\xEF\xEF\x106\x106\x117\x117\x4\x2");
		sb.Append("\x97\x97\x19B\x19B\x4\x2##\x167\x167\x4\x2\x5\x5rr\x5\x2\x5");
		sb.Append("\x5rr\xE3\xE3\x5\x2UU\x10C\x10C\x168\x168\x4\x2\xD7\xD7\x10D");
		sb.Append("\x10D\x4\x2\xDB\xDB\x16F\x16F\x5\x2\x8F\x8F\xB4\xB4\x113\x113");
		sb.Append("\x4\x2SSgg\x6\x2\xA6\xA6\xB2\xB2\xF3\xF3\x110\x110\x4\x2\x64");
		sb.Append("\x64\x1F4\x1F4\x3\x2\x11B\x11C\x3\x3\x1F7\x1F7\x3\x2\x13A\x13B");
		sb.Append("\x4\x2\x108\x108\x1AF\x1AF\x3\x2\x44\x45\x4\x2\x66\x66\xA5\xA5");
		sb.Append("\x4\x2\xFC\xFC\x1A5\x1A5\x4\x2\x19\x19\xA5\xA5\x4\x2&&ii\x5");
		sb.Append("\x2\t\too\x191\x191\x4\x2PP\xE8\xE8\x5\x2\x99\x99\xC6\xC6\x13F");
		sb.Append("\x13F\x4\x2\x14B\x14B\x17C\x17C\x5\x2\x14B\x14B\x165\x165\x17C");
		sb.Append("\x17C\x4\x2\x84\x84\xA7\xA7\x4\x2QQ\x141\x141\x4\x2\xA4\xA4");
		sb.Append("\xC1\xC1\x4\x2\t\t\x196\x196\x4\x2\x17\x17\x153\x153\x4\x2\x10");
		sb.Append("\x10jj\x4\x2\x90\x90\xC3\xC3\x4\x2\t\t\x90\x90\x3\x2\x178\x179");
		sb.Append("\x4\x2\xDB\xDB\x172\x172\x3\x2\xC9\xCC\x3\x2\x1EF\x1F0\x4\x2");
		sb.Append("\x1EE\x1EE\x1F2\x1F2\x4\x2\x63\x63\xA9\xA9\x6\x2\t\t\r\r\x87");
		sb.Append("\x87\x166\x166\x4\x2\x30\x30\x1B3\x1B3\x4\x2oo\x191\x191\x4");
		sb.Append("\x2-->>\x4\x2\x91\x91\xC4\xC4\x4\x2\x32\x32\xEC\xEC\x5\x2%%");
		sb.Append("\xC5\xC5\x185\x185\x4\x2\x1B4\x1B4\x1B7\x1B7\x4\x2||\xF5\xF5");
		sb.Append("\x4\x2\x80\x80\xE6\xE6\x4\x2GGpp\x4\x2\xA1\xA1\x15C\x15C\x3");
		sb.Append("\x2\x1D0\x1DF\x3\x2\x1C9\x1CF\x3\x2\x1C3\x1C8\x4\x2\x12A\x12A");
		sb.Append("\x144\x144\x4\x2\x93\x93\x124\x124\x4\x2\xFA\xFA\x14A\x14A\x4");
		sb.Append("\x2\x10F\x10F\x169\x169\x5\x2\x8C\x8C\x176\x176\x1A6\x1A6\x4");
		sb.Append("\x2<<\x140\x140\x5\x2<<\xF8\xF8\x140\x140\x4\x2\x118\x118\x173");
		sb.Append("\x173\x4\x2\xA4\xA4\x136\x136\x4\x2ZZ\x1BF\x1BF\x4\x2\xE4\xE4");
		sb.Append("\x14D\x14D\x4\x2))\x31\x31\x6\x2ZZ\xA2\xA2\xDE\xDE\x14D\x14D");
		sb.Append("\x3\x2\x1E5\x1E6\x4\x2\x1E0\x1E0\x1E7\x1E7H\x2\x4\b\v\v\xE\xE");
		sb.Append("\x11\x1A\x1D%\'\')*,.\x30\x33\x35@\x43NPQSXZ`\x62\x63\x65gk");
		sb.Append("npqsuxz|\x80\x82\x84\x86\x86\x88\x8C\x8F\x94\x96\x97\x99\x9A");
		sb.Append("\x9E\x9F\xA1\xA2\xA4\xA5\xA7\xAA\xAC\xB2\xB4\xB7\xB9\xB9\xBB");
		sb.Append("\xBB\xBD\xC8\xCA\xCE\xD0\xDC\xDE\xE0\xE2\xF1\xF3\xF5\xF8\xF8");
		sb.Append("\xFA\xFA\xFE\x102\x104\x106\x108\x109\x10C\x10C\x10E\x11A\x11D");
		sb.Append("\x11D\x11F\x126\x129\x13D\x13F\x14B\x14D\x14F\x151\x151\x153");
		sb.Append("\x15A\x15C\x161\x163\x16A\x16C\x177\x17B\x183\x185\x18A\x18C");
		sb.Append("\x18F\x192\x192\x194\x194\x196\x199\x19B\x19C\x19E\x1A7\x1A9");
		sb.Append("\x1A9\x1AB\x1AB\x1AD\x1DF\x266\x266\x16F1\x2\x2FB\x3\x2\x2\x2");
		sb.Append("\x4\x302\x3\x2\x2\x2\x6\x30B\x3\x2\x2\x2\b\x323\x3\x2\x2\x2");
		sb.Append("\n\x325\x3\x2\x2\x2\f\x32A\x3\x2\x2\x2\xE\x342\x3\x2\x2\x2\x10");
		sb.Append("\x376\x3\x2\x2\x2\x12\x37A\x3\x2\x2\x2\x14\x392\x3\x2\x2\x2");
		sb.Append("\x16\x396\x3\x2\x2\x2\x18\x3A2\x3\x2\x2\x2\x1A\x3B0\x3\x2\x2");
		sb.Append("\x2\x1C\x3B8\x3\x2\x2\x2\x1E\x3CE\x3\x2\x2\x2 \x3DA\x3\x2\x2");
		sb.Append("\x2\"\x3EB\x3\x2\x2\x2$\x403\x3\x2\x2\x2&\x405\x3\x2\x2\x2(");
		sb.Append("\x416\x3\x2\x2\x2*\x439\x3\x2\x2\x2,\x43B\x3\x2\x2\x2.\x440");
		sb.Append("\x3\x2\x2\x2\x30\x458\x3\x2\x2\x2\x32\x47D\x3\x2\x2\x2\x34\x482");
		sb.Append("\x3\x2\x2\x2\x36\x49B\x3\x2\x2\x2\x38\x4B3\x3\x2\x2\x2:\x4BC");
		sb.Append("\x3\x2\x2\x2<\x4C5\x3\x2\x2\x2>\x4CE\x3\x2\x2\x2@\x4D2\x3\x2");
		sb.Append("\x2\x2\x42\x4D7\x3\x2\x2\x2\x44\x4EF\x3\x2\x2\x2\x46\x4F1\x3");
		sb.Append("\x2\x2\x2H\x4F5\x3\x2\x2\x2J\x529\x3\x2\x2\x2L\x545\x3\x2\x2");
		sb.Append("\x2N\x547\x3\x2\x2\x2P\x555\x3\x2\x2\x2R\x561\x3\x2\x2\x2T\x566");
		sb.Append("\x3\x2\x2\x2V\x56C\x3\x2\x2\x2X\x56F\x3\x2\x2\x2Z\x57A\x3\x2");
		sb.Append("\x2\x2\\\x589\x3\x2\x2\x2^\x59A\x3\x2\x2\x2`\x5AB\x3\x2\x2\x2");
		sb.Append("\x62\x5B3\x3\x2\x2\x2\x64\x5B8\x3\x2\x2\x2\x66\x5C8\x3\x2\x2");
		sb.Append("\x2h\x5CC\x3\x2\x2\x2j\x5E4\x3\x2\x2\x2l\x5E7\x3\x2\x2\x2n\x5ED");
		sb.Append("\x3\x2\x2\x2p\x5F9\x3\x2\x2\x2r\x602\x3\x2\x2\x2t\x61E\x3\x2");
		sb.Append("\x2\x2v\x624\x3\x2\x2\x2x\x627\x3\x2\x2\x2z\x62E\x3\x2\x2\x2");
		sb.Append("|\x636\x3\x2\x2\x2~\x642\x3\x2\x2\x2\x80\x644\x3\x2\x2\x2\x82");
		sb.Append("\x648\x3\x2\x2\x2\x84\x64E\x3\x2\x2\x2\x86\x66A\x3\x2\x2\x2");
		sb.Append("\x88\x68C\x3\x2\x2\x2\x8A\x6BC\x3\x2\x2\x2\x8C\x6C6\x3\x2\x2");
		sb.Append("\x2\x8E\x6C8\x3\x2\x2\x2\x90\x6CD\x3\x2\x2\x2\x92\x6DB\x3\x2");
		sb.Append("\x2\x2\x94\x6DD\x3\x2\x2\x2\x96\x6E2\x3\x2\x2\x2\x98\x6F2\x3");
		sb.Append("\x2\x2\x2\x9A\x713\x3\x2\x2\x2\x9C\x736\x3\x2\x2\x2\x9E\x73A");
		sb.Append("\x3\x2\x2\x2\xA0\x749\x3\x2\x2\x2\xA2\x74B\x3\x2\x2\x2\xA4\x74E");
		sb.Append("\x3\x2\x2\x2\xA6\x753\x3\x2\x2\x2\xA8\x75D\x3\x2\x2\x2\xAA\x779");
		sb.Append("\x3\x2\x2\x2\xAC\x77B\x3\x2\x2\x2\xAE\x77F\x3\x2\x2\x2\xB0\x782");
		sb.Append("\x3\x2\x2\x2\xB2\x786\x3\x2\x2\x2\xB4\x78B\x3\x2\x2\x2\xB6\x78F");
		sb.Append("\x3\x2\x2\x2\xB8\x7A0\x3\x2\x2\x2\xBA\x7AD\x3\x2\x2\x2\xBC\x7BE");
		sb.Append("\x3\x2\x2\x2\xBE\x7CB\x3\x2\x2\x2\xC0\x7D7\x3\x2\x2\x2\xC2\x7D9");
		sb.Append("\x3\x2\x2\x2\xC4\x7E7\x3\x2\x2\x2\xC6\x7F8\x3\x2\x2\x2\xC8\x811");
		sb.Append("\x3\x2\x2\x2\xCA\x81B\x3\x2\x2\x2\xCC\x81F\x3\x2\x2\x2\xCE\x844");
		sb.Append("\x3\x2\x2\x2\xD0\x846\x3\x2\x2\x2\xD2\x85F\x3\x2\x2\x2\xD4\x86A");
		sb.Append("\x3\x2\x2\x2\xD6\x871\x3\x2\x2\x2\xD8\x875\x3\x2\x2\x2\xDA\x887");
		sb.Append("\x3\x2\x2\x2\xDC\x88F\x3\x2\x2\x2\xDE\x89A\x3\x2\x2\x2\xE0\x8A1");
		sb.Append("\x3\x2\x2\x2\xE2\x8A5\x3\x2\x2\x2\xE4\x8C2\x3\x2\x2\x2\xE6\x8C6");
		sb.Append("\x3\x2\x2\x2\xE8\x8CB\x3\x2\x2\x2\xEA\x8D3\x3\x2\x2\x2\xEC\x8DB");
		sb.Append("\x3\x2\x2\x2\xEE\x8DE\x3\x2\x2\x2\xF0\x8EE\x3\x2\x2\x2\xF2\x8F3");
		sb.Append("\x3\x2\x2\x2\xF4\x8F7\x3\x2\x2\x2\xF6\x91B\x3\x2\x2\x2\xF8\x91D");
		sb.Append("\x3\x2\x2\x2\xFA\x933\x3\x2\x2\x2\xFC\x935\x3\x2\x2\x2\xFE\x93A");
		sb.Append("\x3\x2\x2\x2\x100\x93C\x3\x2\x2\x2\x102\x93E\x3\x2\x2\x2\x104");
		sb.Append("\x940\x3\x2\x2\x2\x106\x944\x3\x2\x2\x2\x108\x949\x3\x2\x2\x2");
		sb.Append("\x10A\x94F\x3\x2\x2\x2\x10C\x958\x3\x2\x2\x2\x10E\x95E\x3\x2");
		sb.Append("\x2\x2\x110\x972\x3\x2\x2\x2\x112\x977\x3\x2\x2\x2\x114\x984");
		sb.Append("\x3\x2\x2\x2\x116\x986\x3\x2\x2\x2\x118\x994\x3\x2\x2\x2\x11A");
		sb.Append("\x99E\x3\x2\x2\x2\x11C\x9A4\x3\x2\x2\x2\x11E\x9A6\x3\x2\x2\x2");
		sb.Append("\x120\x9A9\x3\x2\x2\x2\x122\x9AE\x3\x2\x2\x2\x124\x9C6\x3\x2");
		sb.Append("\x2\x2\x126\x9D5\x3\x2\x2\x2\x128\x9D7\x3\x2\x2\x2\x12A\x9EC");
		sb.Append("\x3\x2\x2\x2\x12C\x9FB\x3\x2\x2\x2\x12E\xA11\x3\x2\x2\x2\x130");
		sb.Append("\xA18\x3\x2\x2\x2\x132\xA25\x3\x2\x2\x2\x134\xA28\x3\x2\x2\x2");
		sb.Append("\x136\xA3D\x3\x2\x2\x2\x138\xA47\x3\x2\x2\x2\x13A\xA50\x3\x2");
		sb.Append("\x2\x2\x13C\xA6B\x3\x2\x2\x2\x13E\xA96\x3\x2\x2\x2\x140\xAA6");
		sb.Append("\x3\x2\x2\x2\x142\xAB3\x3\x2\x2\x2\x144\xABC\x3\x2\x2\x2\x146");
		sb.Append("\xABE\x3\x2\x2\x2\x148\xADD\x3\x2\x2\x2\x14A\xAE1\x3\x2\x2\x2");
		sb.Append("\x14C\xAE9\x3\x2\x2\x2\x14E\xAEB\x3\x2\x2\x2\x150\xAF3\x3\x2");
		sb.Append("\x2\x2\x152\xB1A\x3\x2\x2\x2\x154\xB26\x3\x2\x2\x2\x156\xB3B");
		sb.Append("\x3\x2\x2\x2\x158\xB3E\x3\x2\x2\x2\x15A\xB4A\x3\x2\x2\x2\x15C");
		sb.Append("\xB4E\x3\x2\x2\x2\x15E\xB67\x3\x2\x2\x2\x160\xB69\x3\x2\x2\x2");
		sb.Append("\x162\xB7A\x3\x2\x2\x2\x164\xB81\x3\x2\x2\x2\x166\xB90\x3\x2");
		sb.Append("\x2\x2\x168\xBA7\x3\x2\x2\x2\x16A\xBAD\x3\x2\x2\x2\x16C\xBAF");
		sb.Append("\x3\x2\x2\x2\x16E\xBC7\x3\x2\x2\x2\x170\xBDF\x3\x2\x2\x2\x172");
		sb.Append("\xC03\x3\x2\x2\x2\x174\xC05\x3\x2\x2\x2\x176\xC23\x3\x2\x2\x2");
		sb.Append("\x178\xC28\x3\x2\x2\x2\x17A\xC2A\x3\x2\x2\x2\x17C\xC36\x3\x2");
		sb.Append("\x2\x2\x17E\xC46\x3\x2\x2\x2\x180\xC48\x3\x2\x2\x2\x182\xC4B");
		sb.Append("\x3\x2\x2\x2\x184\xC65\x3\x2\x2\x2\x186\xC67\x3\x2\x2\x2\x188");
		sb.Append("\xC6B\x3\x2\x2\x2\x18A\xC7A\x3\x2\x2\x2\x18C\xC86\x3\x2\x2\x2");
		sb.Append("\x18E\xC8E\x3\x2\x2\x2\x190\xC92\x3\x2\x2\x2\x192\xC9D\x3\x2");
		sb.Append("\x2\x2\x194\xCA2\x3\x2\x2\x2\x196\xCAF\x3\x2\x2\x2\x198\xCC3");
		sb.Append("\x3\x2\x2\x2\x19A\xCCC\x3\x2\x2\x2\x19C\xCCE\x3\x2\x2\x2\x19E");
		sb.Append("\xCD5\x3\x2\x2\x2\x1A0\xCDA\x3\x2\x2\x2\x1A2\xCE7\x3\x2\x2\x2");
		sb.Append("\x1A4\xCEF\x3\x2\x2\x2\x1A6\xCF7\x3\x2\x2\x2\x1A8\xD05\x3\x2");
		sb.Append("\x2\x2\x1AA\xD07\x3\x2\x2\x2\x1AC\xD13\x3\x2\x2\x2\x1AE\xD36");
		sb.Append("\x3\x2\x2\x2\x1B0\xD38\x3\x2\x2\x2\x1B2\xD46\x3\x2\x2\x2\x1B4");
		sb.Append("\xD4B\x3\x2\x2\x2\x1B6\xD5D\x3\x2\x2\x2\x1B8\xD61\x3\x2\x2\x2");
		sb.Append("\x1BA\xD69\x3\x2\x2\x2\x1BC\xD73\x3\x2\x2\x2\x1BE\xD7B\x3\x2");
		sb.Append("\x2\x2\x1C0\xD81\x3\x2\x2\x2\x1C2\xD90\x3\x2\x2\x2\x1C4\xD93");
		sb.Append("\x3\x2\x2\x2\x1C6\xDAC\x3\x2\x2\x2\x1C8\xDBF\x3\x2\x2\x2\x1CA");
		sb.Append("\xDC3\x3\x2\x2\x2\x1CC\xDC6\x3\x2\x2\x2\x1CE\xDE2\x3\x2\x2\x2");
		sb.Append("\x1D0\xDE7\x3\x2\x2\x2\x1D2\xDFA\x3\x2\x2\x2\x1D4\xDFC\x3\x2");
		sb.Append("\x2\x2\x1D6\xE0C\x3\x2\x2\x2\x1D8\xE14\x3\x2\x2\x2\x1DA\xE19");
		sb.Append("\x3\x2\x2\x2\x1DC\xE24\x3\x2\x2\x2\x1DE\xE2F\x3\x2\x2\x2\x1E0");
		sb.Append("\xE32\x3\x2\x2\x2\x1E2\xE44\x3\x2\x2\x2\x1E4\xE46\x3\x2\x2\x2");
		sb.Append("\x1E6\xE55\x3\x2\x2\x2\x1E8\xE60\x3\x2\x2\x2\x1EA\xE6E\x3\x2");
		sb.Append("\x2\x2\x1EC\xE73\x3\x2\x2\x2\x1EE\xE78\x3\x2\x2\x2\x1F0\xE85");
		sb.Append("\x3\x2\x2\x2\x1F2\xE87\x3\x2\x2\x2\x1F4\xE92\x3\x2\x2\x2\x1F6");
		sb.Append("\xE94\x3\x2\x2\x2\x1F8\xE96\x3\x2\x2\x2\x1FA\xEA1\x3\x2\x2\x2");
		sb.Append("\x1FC\xEA3\x3\x2\x2\x2\x1FE\xEC8\x3\x2\x2\x2\x200\xED1\x3\x2");
		sb.Append("\x2\x2\x202\xED3\x3\x2\x2\x2\x204\xEE2\x3\x2\x2\x2\x206\xEF3");
		sb.Append("\x3\x2\x2\x2\x208\xEF5\x3\x2\x2\x2\x20A\xF0A\x3\x2\x2\x2\x20C");
		sb.Append("\xF0C\x3\x2\x2\x2\x20E\xF10\x3\x2\x2\x2\x210\xF19\x3\x2\x2\x2");
		sb.Append("\x212\xF1B\x3\x2\x2\x2\x214\xF23\x3\x2\x2\x2\x216\xF2B\x3\x2");
		sb.Append("\x2\x2\x218\xF4E\x3\x2\x2\x2\x21A\xF50\x3\x2\x2\x2\x21C\xF6E");
		sb.Append("\x3\x2\x2\x2\x21E\xF70\x3\x2\x2\x2\x220\xF80\x3\x2\x2\x2\x222");
		sb.Append("\xF83\x3\x2\x2\x2\x224\xF85\x3\x2\x2\x2\x226\xFB4\x3\x2\x2\x2");
		sb.Append("\x228\xFB8\x3\x2\x2\x2\x22A\xFBB\x3\x2\x2\x2\x22C\xFCE\x3\x2");
		sb.Append("\x2\x2\x22E\xFD6\x3\x2\x2\x2\x230\xFE8\x3\x2\x2\x2\x232\xFEF");
		sb.Append("\x3\x2\x2\x2\x234\x1008\x3\x2\x2\x2\x236\x100A\x3\x2\x2\x2\x238");
		sb.Append("\x100E\x3\x2\x2\x2\x23A\x1017\x3\x2\x2\x2\x23C\x115C\x3\x2\x2");
		sb.Append("\x2\x23E\x115E\x3\x2\x2\x2\x240\x1160\x3\x2\x2\x2\x242\x1162");
		sb.Append("\x3\x2\x2\x2\x244\x1164\x3\x2\x2\x2\x246\x1171\x3\x2\x2\x2\x248");
		sb.Append("\x117A\x3\x2\x2\x2\x24A\x1183\x3\x2\x2\x2\x24C\x1185\x3\x2\x2");
		sb.Append("\x2\x24E\x1196\x3\x2\x2\x2\x250\x119C\x3\x2\x2\x2\x252\x11A7");
		sb.Append("\x3\x2\x2\x2\x254\x11A9\x3\x2\x2\x2\x256\x11BD\x3\x2\x2\x2\x258");
		sb.Append("\x11CB\x3\x2\x2\x2\x25A\x11DD\x3\x2\x2\x2\x25C\x11F2\x3\x2\x2");
		sb.Append("\x2\x25E\x11FF\x3\x2\x2\x2\x260\x1202\x3\x2\x2\x2\x262\x120B");
		sb.Append("\x3\x2\x2\x2\x264\x1211\x3\x2\x2\x2\x266\x1219\x3\x2\x2\x2\x268");
		sb.Append("\x121C\x3\x2\x2\x2\x26A\x1227\x3\x2\x2\x2\x26C\x122F\x3\x2\x2");
		sb.Append("\x2\x26E\x1234\x3\x2\x2\x2\x270\x123D\x3\x2\x2\x2\x272\x1246");
		sb.Append("\x3\x2\x2\x2\x274\x1248\x3\x2\x2\x2\x276\x124E\x3\x2\x2\x2\x278");
		sb.Append("\x1250\x3\x2\x2\x2\x27A\x125E\x3\x2\x2\x2\x27C\x1262\x3\x2\x2");
		sb.Append("\x2\x27E\x1264\x3\x2\x2\x2\x280\x1266\x3\x2\x2\x2\x282\x126B");
		sb.Append("\x3\x2\x2\x2\x284\x1283\x3\x2\x2\x2\x286\x1287\x3\x2\x2\x2\x288");
		sb.Append("\x1289\x3\x2\x2\x2\x28A\x128B\x3\x2\x2\x2\x28C\x128D\x3\x2\x2");
		sb.Append("\x2\x28E\x128F\x3\x2\x2\x2\x290\x1291\x3\x2\x2\x2\x292\x1293");
		sb.Append("\x3\x2\x2\x2\x294\x1295\x3\x2\x2\x2\x296\x12A1\x3\x2\x2\x2\x298");
		sb.Append("\x12A3\x3\x2\x2\x2\x29A\x12A8\x3\x2\x2\x2\x29C\x12AA\x3\x2\x2");
		sb.Append("\x2\x29E\x12AC\x3\x2\x2\x2\x2A0\x12AE\x3\x2\x2\x2\x2A2\x12B6");
		sb.Append("\x3\x2\x2\x2\x2A4\x12B8\x3\x2\x2\x2\x2A6\x12C4\x3\x2\x2\x2\x2A8");
		sb.Append("\x12C6\x3\x2\x2\x2\x2AA\x12CE\x3\x2\x2\x2\x2AC\x12D6\x3\x2\x2");
		sb.Append("\x2\x2AE\x12DE\x3\x2\x2\x2\x2B0\x12E3\x3\x2\x2\x2\x2B2\x12E8");
		sb.Append("\x3\x2\x2\x2\x2B4\x12F7\x3\x2\x2\x2\x2B6\x12F9\x3\x2\x2\x2\x2B8");
		sb.Append("\x12FD\x3\x2\x2\x2\x2BA\x1301\x3\x2\x2\x2\x2BC\x1303\x3\x2\x2");
		sb.Append("\x2\x2BE\x1308\x3\x2\x2\x2\x2C0\x130A\x3\x2\x2\x2\x2C2\x1312");
		sb.Append("\x3\x2\x2\x2\x2C4\x131C\x3\x2\x2\x2\x2C6\x1324\x3\x2\x2\x2\x2C8");
		sb.Append("\x132D\x3\x2\x2\x2\x2CA\x133C\x3\x2\x2\x2\x2CC\x1351\x3\x2\x2");
		sb.Append("\x2\x2CE\x137B\x3\x2\x2\x2\x2D0\x1382\x3\x2\x2\x2\x2D2\x138E");
		sb.Append("\x3\x2\x2\x2\x2D4\x13AC\x3\x2\x2\x2\x2D6\x13AE\x3\x2\x2\x2\x2D8");
		sb.Append("\x13F5\x3\x2\x2\x2\x2DA\x13FA\x3\x2\x2\x2\x2DC\x140D\x3\x2\x2");
		sb.Append("\x2\x2DE\x1417\x3\x2\x2\x2\x2E0\x1426\x3\x2\x2\x2\x2E2\x146E");
		sb.Append("\x3\x2\x2\x2\x2E4\x1470\x3\x2\x2\x2\x2E6\x1472\x3\x2\x2\x2\x2E8");
		sb.Append("\x1475\x3\x2\x2\x2\x2EA\x1479\x3\x2\x2\x2\x2EC\x147F\x3\x2\x2");
		sb.Append("\x2\x2EE\x1488\x3\x2\x2\x2\x2F0\x148D\x3\x2\x2\x2\x2F2\x1492");
		sb.Append("\x3\x2\x2\x2\x2F4\x1497\x3\x2\x2\x2\x2F6\x1499\x3\x2\x2\x2\x2F8");
		sb.Append("\x149D\x3\x2\x2\x2\x2FA\x2FC\n\x2\x2\x2\x2FB\x2FA\x3\x2\x2\x2");
		sb.Append("\x2FC\x2FD\x3\x2\x2\x2\x2FD\x2FB\x3\x2\x2\x2\x2FD\x2FE\x3\x2");
		sb.Append("\x2\x2\x2FE\x3\x3\x2\x2\x2\x2FF\x301\x5\b\x5\x2\x300\x2FF\x3");
		sb.Append("\x2\x2\x2\x301\x304\x3\x2\x2\x2\x302\x300\x3\x2\x2\x2\x302\x303");
		sb.Append("\x3\x2\x2\x2\x303\x305\x3\x2\x2\x2\x304\x302\x3\x2\x2\x2\x305");
		sb.Append("\x306\a\x2\x2\x3\x306\x5\x3\x2\x2\x2\x307\x30A\x5\b\x5\x2\x308");
		sb.Append("\x30A\x5\x26C\x137\x2\x309\x307\x3\x2\x2\x2\x309\x308\x3\x2");
		sb.Append("\x2\x2\x30A\x30D\x3\x2\x2\x2\x30B\x309\x3\x2\x2\x2\x30B\x30C");
		sb.Append("\x3\x2\x2\x2\x30C\x30E\x3\x2\x2\x2\x30D\x30B\x3\x2\x2\x2\x30E");
		sb.Append("\x30F\a\x2\x2\x3\x30F\a\x3\x2\x2\x2\x310\x324\x5\f\a\x2\x311");
		sb.Append("\x324\x5\x1C\xF\x2\x312\x324\x5.\x18\x2\x313\x324\x5\xA6T\x2");
		sb.Append("\x314\x324\x5\x34\x1B\x2\x315\x324\x5Z.\x2\x316\x324\x5\xE\b");
		sb.Append("\x2\x317\x324\x5\x30\x19\x2\x318\x324\x5\x1E\x10\x2\x319\x324");
		sb.Append("\x5\xA8U\x2\x31A\x324\x5\x36\x1C\x2\x31B\x324\x5n\x38\x2\x31C");
		sb.Append("\x324\x5\n\x6\x2\x31D\x324\x5\x1A\xE\x2\x31E\x324\x5,\x17\x2");
		sb.Append("\x31F\x324\x5\xA4S\x2\x320\x324\x5\x32\x1A\x2\x321\x324\x5X");
		sb.Append("-\x2\x322\x324\x5\x11A\x8E\x2\x323\x310\x3\x2\x2\x2\x323\x311");
		sb.Append("\x3\x2\x2\x2\x323\x312\x3\x2\x2\x2\x323\x313\x3\x2\x2\x2\x323");
		sb.Append("\x314\x3\x2\x2\x2\x323\x315\x3\x2\x2\x2\x323\x316\x3\x2\x2\x2");
		sb.Append("\x323\x317\x3\x2\x2\x2\x323\x318\x3\x2\x2\x2\x323\x319\x3\x2");
		sb.Append("\x2\x2\x323\x31A\x3\x2\x2\x2\x323\x31B\x3\x2\x2\x2\x323\x31C");
		sb.Append("\x3\x2\x2\x2\x323\x31D\x3\x2\x2\x2\x323\x31E\x3\x2\x2\x2\x323");
		sb.Append("\x31F\x3\x2\x2\x2\x323\x320\x3\x2\x2\x2\x323\x321\x3\x2\x2\x2");
		sb.Append("\x323\x322\x3\x2\x2\x2\x324\t\x3\x2\x2\x2\x325\x326\ar\x2\x2");
		sb.Append("\x326\x327\a\x9A\x2\x2\x327\x328\x5\x2AE\x158\x2\x328\x329\a");
		sb.Append("\x1F7\x2\x2\x329\v\x3\x2\x2\x2\x32A\x32B\a\n\x2\x2\x32B\x32C");
		sb.Append("\a\x9A\x2\x2\x32C\x32D\x5\x2AE\x158\x2\x32D\x32F\a?\x2\x2\x32E");
		sb.Append("\x330\a^\x2\x2\x32F\x32E\x3\x2\x2\x2\x32F\x330\x3\x2\x2\x2\x330");
		sb.Append("\x334\x3\x2\x2\x2\x331\x333\x5\xB0Y\x2\x332\x331\x3\x2\x2\x2");
		sb.Append("\x333\x336\x3\x2\x2\x2\x334\x332\x3\x2\x2\x2\x334\x335\x3\x2");
		sb.Append("\x2\x2\x335\x339\x3\x2\x2\x2\x336\x334\x3\x2\x2\x2\x337\x338");
		sb.Append("\a\x13C\x2\x2\x338\x33A\a\x15A\x2\x2\x339\x337\x3\x2\x2\x2\x339");
		sb.Append("\x33A\x3\x2\x2\x2\x33A\x33B\x3\x2\x2\x2\x33B\x33C\a\x1F7\x2");
		sb.Append("\x2\x33C\r\x3\x2\x2\x2\x33D\x340\aO\x2\x2\x33E\x33F\a\x10B\x2");
		sb.Append("\x2\x33F\x341\a\x135\x2\x2\x340\x33E\x3\x2\x2\x2\x340\x341\x3");
		sb.Append("\x2\x2\x2\x341\x343\x3\x2\x2\x2\x342\x33D\x3\x2\x2\x2\x342\x343");
		sb.Append("\x3\x2\x2\x2\x343\x344\x3\x2\x2\x2\x344\x345\a\x9A\x2\x2\x345");
		sb.Append("\x351\x5\x2AE\x158\x2\x346\x347\a\x1EB\x2\x2\x347\x34C\x5\xBC");
		sb.Append("_\x2\x348\x349\a\x1F1\x2\x2\x349\x34B\x5\xBC_\x2\x34A\x348\x3");
		sb.Append("\x2\x2\x2\x34B\x34E\x3\x2\x2\x2\x34C\x34A\x3\x2\x2\x2\x34C\x34D");
		sb.Append("\x3\x2\x2\x2\x34D\x34F\x3\x2\x2\x2\x34E\x34C\x3\x2\x2\x2\x34F");
		sb.Append("\x350\a\x1EC\x2\x2\x350\x352\x3\x2\x2\x2\x351\x346\x3\x2\x2");
		sb.Append("\x2\x351\x352\x3\x2\x2\x2\x352\x353\x3\x2\x2\x2\x353\x354\a");
		sb.Append("\x13A\x2\x2\x354\x35B\x5\x2D2\x16A\x2\x355\x35A\x5\xAEX\x2\x356");
		sb.Append("\x35A\x5\x10\t\x2\x357\x35A\x5\x14\v\x2\x358\x35A\ak\x2\x2\x359");
		sb.Append("\x355\x3\x2\x2\x2\x359\x356\x3\x2\x2\x2\x359\x357\x3\x2\x2\x2");
		sb.Append("\x359\x358\x3\x2\x2\x2\x35A\x35D\x3\x2\x2\x2\x35B\x359\x3\x2");
		sb.Append("\x2\x2\x35B\x35C\x3\x2\x2\x2\x35C\x372\x3\x2\x2\x2\x35D\x35B");
		sb.Append("\x3\x2\x2\x2\x35E\x360\a\x11D\x2\x2\x35F\x35E\x3\x2\x2\x2\x35F");
		sb.Append("\x360\x3\x2\x2\x2\x360\x361\x3\x2\x2\x2\x361\x36D\t\x3\x2\x2");
		sb.Append("\x362\x364\a\x61\x2\x2\x363\x362\x3\x2\x2\x2\x363\x364\x3\x2");
		sb.Append("\x2\x2\x364\x368\x3\x2\x2\x2\x365\x367\x5\xC0\x61\x2\x366\x365");
		sb.Append("\x3\x2\x2\x2\x367\x36A\x3\x2\x2\x2\x368\x366\x3\x2\x2\x2\x368");
		sb.Append("\x369\x3\x2\x2\x2\x369\x36B\x3\x2\x2\x2\x36A\x368\x3\x2\x2\x2");
		sb.Append("\x36B\x36E\x5\x10A\x86\x2\x36C\x36E\x5\xB2Z\x2\x36D\x363\x3");
		sb.Append("\x2\x2\x2\x36D\x36C\x3\x2\x2\x2\x36E\x373\x3\x2\x2\x2\x36F\x370");
		sb.Append("\t\x4\x2\x2\x370\x371\a\x19A\x2\x2\x371\x373\x5\x298\x14D\x2");
		sb.Append("\x372\x35F\x3\x2\x2\x2\x372\x36F\x3\x2\x2\x2\x373\x374\x3\x2");
		sb.Append("\x2\x2\x374\x375\a\x1F7\x2\x2\x375\xF\x3\x2\x2\x2\x376\x378");
		sb.Append("\a\x115\x2\x2\x377\x379\x5\x12\n\x2\x378\x377\x3\x2\x2\x2\x378");
		sb.Append("\x379\x3\x2\x2\x2\x379\x11\x3\x2\x2\x2\x37A\x37B\a\x1EB\x2\x2");
		sb.Append("\x37B\x37C\a\x118\x2\x2\x37C\x37D\x5\x1F4\xFB\x2\x37D\x38B\a");
		sb.Append("(\x2\x2\x37E\x38C\a\r\x2\x2\x37F\x380\t\x5\x2\x2\x380\x381\a");
		sb.Append("\x1EB\x2\x2\x381\x386\x5\x2C0\x161\x2\x382\x383\a\x1F1\x2\x2");
		sb.Append("\x383\x385\x5\x2C0\x161\x2\x384\x382\x3\x2\x2\x2\x385\x388\x3");
		sb.Append("\x2\x2\x2\x386\x384\x3\x2\x2\x2\x386\x387\x3\x2\x2\x2\x387\x389");
		sb.Append("\x3\x2\x2\x2\x388\x386\x3\x2\x2\x2\x389\x38A\a\x1EC\x2\x2\x38A");
		sb.Append("\x38C\x3\x2\x2\x2\x38B\x37E\x3\x2\x2\x2\x38B\x37F\x3\x2\x2\x2");
		sb.Append("\x38C\x38E\x3\x2\x2\x2\x38D\x38F\x5\x18\r\x2\x38E\x38D\x3\x2");
		sb.Append("\x2\x2\x38E\x38F\x3\x2\x2\x2\x38F\x390\x3\x2\x2\x2\x390\x391");
		sb.Append("\a\x1EC\x2\x2\x391\x13\x3\x2\x2\x2\x392\x394\a\x139\x2\x2\x393");
		sb.Append("\x395\x5\x16\f\x2\x394\x393\x3\x2\x2\x2\x394\x395\x3\x2\x2\x2");
		sb.Append("\x395\x15\x3\x2\x2\x2\x396\x397\a\x133\x2\x2\x397\x398\a\x1EB");
		sb.Append("\x2\x2\x398\x39D\x5\x2C2\x162\x2\x399\x39A\a\x1F1\x2\x2\x39A");
		sb.Append("\x39C\x5\x2C2\x162\x2\x39B\x399\x3\x2\x2\x2\x39C\x39F\x3\x2");
		sb.Append("\x2\x2\x39D\x39B\x3\x2\x2\x2\x39D\x39E\x3\x2\x2\x2\x39E\x3A0");
		sb.Append("\x3\x2\x2\x2\x39F\x39D\x3\x2\x2\x2\x3A0\x3A1\a\x1EC\x2\x2\x3A1");
		sb.Append("\x17\x3\x2\x2\x2\x3A2\x3A3\t\x6\x2\x2\x3A3\x3A4\x5\x1F4\xFB");
		sb.Append("\x2\x3A4\x3A5\a(\x2\x2\x3A5\x3A6\a\x1EB\x2\x2\x3A6\x3AB\x5\x2C0");
		sb.Append("\x161\x2\x3A7\x3A8\a\x1F1\x2\x2\x3A8\x3AA\x5\x2C0\x161\x2\x3A9");
		sb.Append("\x3A7\x3\x2\x2\x2\x3AA\x3AD\x3\x2\x2\x2\x3AB\x3A9\x3\x2\x2\x2");
		sb.Append("\x3AB\x3AC\x3\x2\x2\x2\x3AC\x3AE\x3\x2\x2\x2\x3AD\x3AB\x3\x2");
		sb.Append("\x2\x2\x3AE\x3AF\a\x1EC\x2\x2\x3AF\x19\x3\x2\x2\x2\x3B0\x3B1");
		sb.Append("\ar\x2\x2\x3B1\x3B3\a\x114\x2\x2\x3B2\x3B4\a#\x2\x2\x3B3\x3B2");
		sb.Append("\x3\x2\x2\x2\x3B3\x3B4\x3\x2\x2\x2\x3B4\x3B5\x3\x2\x2\x2\x3B5");
		sb.Append("\x3B6\x5\x296\x14C\x2\x3B6\x3B7\a\x1F7\x2\x2\x3B7\x1B\x3\x2");
		sb.Append("\x2\x2\x3B8\x3B9\a\n\x2\x2\x3B9\x3BA\a\x114\x2\x2\x3BA\x3BB");
		sb.Append("\x5\x296\x14C\x2\x3BB\x3BD\a?\x2\x2\x3BC\x3BE\a^\x2\x2\x3BD");
		sb.Append("\x3BC\x3\x2\x2\x2\x3BD\x3BE\x3\x2\x2\x2\x3BE\x3C0\x3\x2\x2\x2");
		sb.Append("\x3BF\x3C1\t\a\x2\x2\x3C0\x3BF\x3\x2\x2\x2\x3C0\x3C1\x3\x2\x2");
		sb.Append("\x2\x3C1\x3C5\x3\x2\x2\x2\x3C2\x3C4\x5\xB0Y\x2\x3C3\x3C2\x3");
		sb.Append("\x2\x2\x2\x3C4\x3C7\x3\x2\x2\x2\x3C5\x3C3\x3\x2\x2\x2\x3C5\x3C6");
		sb.Append("\x3\x2\x2\x2\x3C6\x3CA\x3\x2\x2\x2\x3C7\x3C5\x3\x2\x2\x2\x3C8");
		sb.Append("\x3C9\a\x13C\x2\x2\x3C9\x3CB\a\x15A\x2\x2\x3CA\x3C8\x3\x2\x2");
		sb.Append("\x2\x3CA\x3CB\x3\x2\x2\x2\x3CB\x3CC\x3\x2\x2\x2\x3CC\x3CD\a");
		sb.Append("\x1F7\x2\x2\x3CD\x1D\x3\x2\x2\x2\x3CE\x3D1\aO\x2\x2\x3CF\x3D0");
		sb.Append("\a\x10B\x2\x2\x3D0\x3D2\a\x135\x2\x2\x3D1\x3CF\x3\x2\x2\x2\x3D1");
		sb.Append("\x3D2\x3\x2\x2\x2\x3D2\x3D3\x3\x2\x2\x2\x3D3\x3D6\a\x114\x2");
		sb.Append("\x2\x3D4\x3D7\x5\"\x12\x2\x3D5\x3D7\x5 \x11\x2\x3D6\x3D4\x3");
		sb.Append("\x2\x2\x2\x3D6\x3D5\x3\x2\x2\x2\x3D6\x3D7\x3\x2\x2\x2\x3D7\x3D8");
		sb.Append("\x3\x2\x2\x2\x3D8\x3D9\a\x1F7\x2\x2\x3D9\x1F\x3\x2\x2\x2\x3DA");
		sb.Append("\x3DB\a#\x2\x2\x3DB\x3DC\x5\x296\x14C\x2\x3DC\x3E0\t\x3\x2\x2");
		sb.Append("\x3DD\x3DF\x5*\x16\x2\x3DE\x3DD\x3\x2\x2\x2\x3DF\x3E2\x3\x2");
		sb.Append("\x2\x2\x3E0\x3DE\x3\x2\x2\x2\x3E0\x3E1\x3\x2\x2\x2\x3E1\x3E9");
		sb.Append("\x3\x2\x2\x2\x3E2\x3E0\x3\x2\x2\x2\x3E3\x3E4\a\x1B\x2\x2\x3E4");
		sb.Append("\x3EA\x5\xE0q\x2\x3E5\x3E7\a{\x2\x2\x3E6\x3E8\x5\x296\x14C\x2");
		sb.Append("\x3E7\x3E6\x3\x2\x2\x2\x3E7\x3E8\x3\x2\x2\x2\x3E8\x3EA\x3\x2");
		sb.Append("\x2\x2\x3E9\x3E3\x3\x2\x2\x2\x3E9\x3E5\x3\x2\x2\x2\x3EA!\x3");
		sb.Append("\x2\x2\x2\x3EB\x3ED\x5\x296\x14C\x2\x3EC\x3EE\x5\xAEX\x2\x3ED");
		sb.Append("\x3EC\x3\x2\x2\x2\x3ED\x3EE\x3\x2\x2\x2\x3EE\x3EF\x3\x2\x2\x2");
		sb.Append("\x3EF\x3F3\t\x3\x2\x2\x3F0\x3F2\x5$\x13\x2\x3F1\x3F0\x3\x2\x2");
		sb.Append("\x2\x3F2\x3F5\x3\x2\x2\x2\x3F3\x3F1\x3\x2\x2\x2\x3F3\x3F4\x3");
		sb.Append("\x2\x2\x2\x3F4\x3F6\x3\x2\x2\x2\x3F5\x3F3\x3\x2\x2\x2\x3F6\x3F8");
		sb.Append("\a{\x2\x2\x3F7\x3F9\x5\x296\x14C\x2\x3F8\x3F7\x3\x2\x2\x2\x3F8");
		sb.Append("\x3F9\x3\x2\x2\x2\x3F9#\x3\x2\x2\x2\x3FA\x404\x5\xC2\x62\x2");
		sb.Append("\x3FB\x404\x5\xC4\x63\x2\x3FC\x404\x5\xC6\x64\x2\x3FD\x404\x5");
		sb.Append("\xCA\x66\x2\x3FE\x404\x5\xCCg\x2\x3FF\x404\x5\xCEh\x2\x400\x404");
		sb.Append("\x5\xD6l\x2\x401\x404\x5&\x14\x2\x402\x404\x5(\x15\x2\x403\x3FA");
		sb.Append("\x3\x2\x2\x2\x403\x3FB\x3\x2\x2\x2\x403\x3FC\x3\x2\x2\x2\x403");
		sb.Append("\x3FD\x3\x2\x2\x2\x403\x3FE\x3\x2\x2\x2\x403\x3FF\x3\x2\x2\x2");
		sb.Append("\x403\x400\x3\x2\x2\x2\x403\x401\x3\x2\x2\x2\x403\x402\x3\x2");
		sb.Append("\x2\x2\x404%\x3\x2\x2\x2\x405\x406\a\x128\x2\x2\x406\x412\x5");
		sb.Append("\x2B0\x159\x2\x407\x408\a\x1EB\x2\x2\x408\x40D\x5\xBC_\x2\x409");
		sb.Append("\x40A\a\x1F1\x2\x2\x40A\x40C\x5\xBC_\x2\x40B\x409\x3\x2\x2\x2");
		sb.Append("\x40C\x40F\x3\x2\x2\x2\x40D\x40B\x3\x2\x2\x2\x40D\x40E\x3\x2");
		sb.Append("\x2\x2\x40E\x410\x3\x2\x2\x2\x40F\x40D\x3\x2\x2\x2\x410\x411");
		sb.Append("\a\x1EC\x2\x2\x411\x413\x3\x2\x2\x2\x412\x407\x3\x2\x2\x2\x412");
		sb.Append("\x413\x3\x2\x2\x2\x413\x414\x3\x2\x2\x2\x414\x415\a\x1F7\x2");
		sb.Append("\x2\x415\'\x3\x2\x2\x2\x416\x417\a\x9A\x2\x2\x417\x423\x5\x2AE");
		sb.Append("\x158\x2\x418\x419\a\x1EB\x2\x2\x419\x41E\x5\xBC_\x2\x41A\x41B");
		sb.Append("\a\x1F1\x2\x2\x41B\x41D\x5\xBC_\x2\x41C\x41A\x3\x2\x2\x2\x41D");
		sb.Append("\x420\x3\x2\x2\x2\x41E\x41C\x3\x2\x2\x2\x41E\x41F\x3\x2\x2\x2");
		sb.Append("\x41F\x421\x3\x2\x2\x2\x420\x41E\x3\x2\x2\x2\x421\x422\a\x1EC");
		sb.Append("\x2\x2\x422\x424\x3\x2\x2\x2\x423\x418\x3\x2\x2\x2\x423\x424");
		sb.Append("\x3\x2\x2\x2\x424\x425\x3\x2\x2\x2\x425\x426\a\x13A\x2\x2\x426");
		sb.Append("\x428\x5\x2D2\x16A\x2\x427\x429\ak\x2\x2\x428\x427\x3\x2\x2");
		sb.Append("\x2\x428\x429\x3\x2\x2\x2\x429\x42B\x3\x2\x2\x2\x42A\x42C\a");
		sb.Append("\x139\x2\x2\x42B\x42A\x3\x2\x2\x2\x42B\x42C\x3\x2\x2\x2\x42C");
		sb.Append("\x42D\x3\x2\x2\x2\x42D\x42E\a\x1F7\x2\x2\x42E)\x3\x2\x2\x2\x42F");
		sb.Append("\x43A\x5\xC2\x62\x2\x430\x43A\x5\xC4\x63\x2\x431\x43A\x5\xC6");
		sb.Append("\x64\x2\x432\x43A\x5\xCA\x66\x2\x433\x43A\x5\xCEh\x2\x434\x43A");
		sb.Append("\x5\xD6l\x2\x435\x43A\x5\x30\x19\x2\x436\x43A\x5\xE\b\x2\x437");
		sb.Append("\x43A\x5&\x14\x2\x438\x43A\x5(\x15\x2\x439\x42F\x3\x2\x2\x2");
		sb.Append("\x439\x430\x3\x2\x2\x2\x439\x431\x3\x2\x2\x2\x439\x432\x3\x2");
		sb.Append("\x2\x2\x439\x433\x3\x2\x2\x2\x439\x434\x3\x2\x2\x2\x439\x435");
		sb.Append("\x3\x2\x2\x2\x439\x436\x3\x2\x2\x2\x439\x437\x3\x2\x2\x2\x439");
		sb.Append("\x438\x3\x2\x2\x2\x43A+\x3\x2\x2\x2\x43B\x43C\ar\x2\x2\x43C");
		sb.Append("\x43D\a\x128\x2\x2\x43D\x43E\x5\x2B0\x159\x2\x43E\x43F\a\x1F7");
		sb.Append("\x2\x2\x43F-\x3\x2\x2\x2\x440\x441\a\n\x2\x2\x441\x442\a\x128");
		sb.Append("\x2\x2\x442\x443\x5\x2B0\x159\x2\x443\x445\a?\x2\x2\x444\x446");
		sb.Append("\a^\x2\x2\x445\x444\x3\x2\x2\x2\x445\x446\x3\x2\x2\x2\x446\x44A");
		sb.Append("\x3\x2\x2\x2\x447\x449\x5\xB0Y\x2\x448\x447\x3\x2\x2\x2\x449");
		sb.Append("\x44C\x3\x2\x2\x2\x44A\x448\x3\x2\x2\x2\x44A\x44B\x3\x2\x2\x2");
		sb.Append("\x44B\x44F\x3\x2\x2\x2\x44C\x44A\x3\x2\x2\x2\x44D\x44E\a\x13C");
		sb.Append("\x2\x2\x44E\x450\a\x15A\x2\x2\x44F\x44D\x3\x2\x2\x2\x44F\x450");
		sb.Append("\x3\x2\x2\x2\x450\x451\x3\x2\x2\x2\x451\x452\a\x1F7\x2\x2\x452");
		sb.Append("/\x3\x2\x2\x2\x453\x456\aO\x2\x2\x454\x455\a\x10B\x2\x2\x455");
		sb.Append("\x457\a\x135\x2\x2\x456\x454\x3\x2\x2\x2\x456\x457\x3\x2\x2");
		sb.Append("\x2\x457\x459\x3\x2\x2\x2\x458\x453\x3\x2\x2\x2\x458\x459\x3");
		sb.Append("\x2\x2\x2\x459\x45A\x3\x2\x2\x2\x45A\x45B\a\x128\x2\x2\x45B");
		sb.Append("\x467\x5\x2B0\x159\x2\x45C\x45D\a\x1EB\x2\x2\x45D\x462\x5\xBC");
		sb.Append("_\x2\x45E\x45F\a\x1F1\x2\x2\x45F\x461\x5\xBC_\x2\x460\x45E\x3");
		sb.Append("\x2\x2\x2\x461\x464\x3\x2\x2\x2\x462\x460\x3\x2\x2\x2\x462\x463");
		sb.Append("\x3\x2\x2\x2\x463\x465\x3\x2\x2\x2\x464\x462\x3\x2\x2\x2\x465");
		sb.Append("\x466\a\x1EC\x2\x2\x466\x468\x3\x2\x2\x2\x467\x45C\x3\x2\x2");
		sb.Append("\x2\x467\x468\x3\x2\x2\x2\x468\x46A\x3\x2\x2\x2\x469\x46B\x5");
		sb.Append("\xAEX\x2\x46A\x469\x3\x2\x2\x2\x46A\x46B\x3\x2\x2\x2\x46B\x46C");
		sb.Append("\x3\x2\x2\x2\x46C\x479\t\x3\x2\x2\x46D\x46F\a\x61\x2\x2\x46E");
		sb.Append("\x46D\x3\x2\x2\x2\x46E\x46F\x3\x2\x2\x2\x46F\x473\x3\x2\x2\x2");
		sb.Append("\x470\x472\x5\xC0\x61\x2\x471\x470\x3\x2\x2\x2\x472\x475\x3");
		sb.Append("\x2\x2\x2\x473\x471\x3\x2\x2\x2\x473\x474\x3\x2\x2\x2\x474\x476");
		sb.Append("\x3\x2\x2\x2\x475\x473\x3\x2\x2\x2\x476\x47A\x5\x10A\x86\x2");
		sb.Append("\x477\x47A\x5\xB2Z\x2\x478\x47A\a\x8A\x2\x2\x479\x46E\x3\x2");
		sb.Append("\x2\x2\x479\x477\x3\x2\x2\x2\x479\x478\x3\x2\x2\x2\x47A\x47B");
		sb.Append("\x3\x2\x2\x2\x47B\x47C\a\x1F7\x2\x2\x47C\x31\x3\x2\x2\x2\x47D");
		sb.Append("\x47E\ar\x2\x2\x47E\x47F\a\x189\x2\x2\x47F\x480\x5\x2B2\x15A");
		sb.Append("\x2\x480\x481\a\x1F7\x2\x2\x481\x33\x3\x2\x2\x2\x482\x483\a");
		sb.Append("\n\x2\x2\x483\x484\a\x189\x2\x2\x484\x497\x5\x2B2\x15A\x2\x485");
		sb.Append("\x498\t\b\x2\x2\x486\x487\a\x134\x2\x2\x487\x488\a\x184\x2\x2");
		sb.Append("\x488\x498\x5\x2B2\x15A\x2\x489\x48B\a?\x2\x2\x48A\x48C\a^\x2");
		sb.Append("\x2\x48B\x48A\x3\x2\x2\x2\x48B\x48C\x3\x2\x2\x2\x48C\x490\x3");
		sb.Append("\x2\x2\x2\x48D\x48F\x5\xB0Y\x2\x48E\x48D\x3\x2\x2\x2\x48F\x492");
		sb.Append("\x3\x2\x2\x2\x490\x48E\x3\x2\x2\x2\x490\x491\x3\x2\x2\x2\x491");
		sb.Append("\x495\x3\x2\x2\x2\x492\x490\x3\x2\x2\x2\x493\x494\a\x13C\x2");
		sb.Append("\x2\x494\x496\a\x15A\x2\x2\x495\x493\x3\x2\x2\x2\x495\x496\x3");
		sb.Append("\x2\x2\x2\x496\x498\x3\x2\x2\x2\x497\x485\x3\x2\x2\x2\x497\x486");
		sb.Append("\x3\x2\x2\x2\x497\x489\x3\x2\x2\x2\x498\x499\x3\x2\x2\x2\x499");
		sb.Append("\x49A\a\x1F7\x2\x2\x49A\x35\x3\x2\x2\x2\x49B\x49E\aO\x2\x2\x49C");
		sb.Append("\x49D\a\x10B\x2\x2\x49D\x49F\a\x135\x2\x2\x49E\x49C\x3\x2\x2");
		sb.Append("\x2\x49E\x49F\x3\x2\x2\x2\x49F\x4A0\x3\x2\x2\x2\x4A0\x4A1\a");
		sb.Append("\x189\x2\x2\x4A1\x4A5\x5\x2B2\x15A\x2\x4A2\x4A6\x5<\x1F\x2\x4A3");
		sb.Append("\x4A6\x5@!\x2\x4A4\x4A6\x5\x42\"\x2\x4A5\x4A2\x3\x2\x2\x2\x4A5");
		sb.Append("\x4A3\x3\x2\x2\x2\x4A5\x4A4\x3\x2\x2\x2\x4A6\x4A8\x3\x2\x2\x2");
		sb.Append("\x4A7\x4A9\x5\x38\x1D\x2\x4A8\x4A7\x3\x2\x2\x2\x4A8\x4A9\x3");
		sb.Append("\x2\x2\x2\x4A9\x4AB\x3\x2\x2\x2\x4AA\x4AC\t\b\x2\x2\x4AB\x4AA");
		sb.Append("\x3\x2\x2\x2\x4AB\x4AC\x3\x2\x2\x2\x4AC\x4AE\x3\x2\x2\x2\x4AD");
		sb.Append("\x4AF\x5:\x1E\x2\x4AE\x4AD\x3\x2\x2\x2\x4AE\x4AF\x3\x2\x2\x2");
		sb.Append("\x4AF\x4B0\x3\x2\x2\x2\x4B0\x4B1\x5\x44#\x2\x4B1\x4B2\a\x1F7");
		sb.Append("\x2\x2\x4B2\x37\x3\x2\x2\x2\x4B3\x4B4\a\x94\x2\x2\x4B4\x4B9");
		sb.Append("\x5\x2B2\x15A\x2\x4B5\x4B6\a\x1F1\x2\x2\x4B6\x4B8\x5\x2B2\x15A");
		sb.Append("\x2\x4B7\x4B5\x3\x2\x2\x2\x4B8\x4BB\x3\x2\x2\x2\x4B9\x4B7\x3");
		sb.Append("\x2\x2\x2\x4B9\x4BA\x3\x2\x2\x2\x4BA\x39\x3\x2\x2\x2\x4BB\x4B9");
		sb.Append("\x3\x2\x2\x2\x4BC\x4BD\a\x1A8\x2\x2\x4BD\x4BE\a\x1EB\x2\x2\x4BE");
		sb.Append("\x4BF\x5\x1F0\xF9\x2\x4BF\x4C0\a\x1EC\x2\x2\x4C0;\x3\x2\x2\x2");
		sb.Append("\x4C1\x4C6\a\x1A\x2\x2\x4C2\x4C6\a\x6\x2\x2\x4C3\x4C4\a\xB5");
		sb.Append("\x2\x2\x4C4\x4C6\a\x103\x2\x2\x4C5\x4C1\x3\x2\x2\x2\x4C5\x4C2");
		sb.Append("\x3\x2\x2\x2\x4C5\x4C3\x3\x2\x2\x2\x4C6\x4C7\x3\x2\x2\x2\x4C7");
		sb.Append("\x4C9\x5N(\x2\x4C8\x4CA\x5T+\x2\x4C9\x4C8\x3\x2\x2\x2\x4C9\x4CA");
		sb.Append("\x3\x2\x2\x2\x4CA\x4CC\x3\x2\x2\x2\x4CB\x4CD\x5> \x2\x4CC\x4CB");
		sb.Append("\x3\x2\x2\x2\x4CC\x4CD\x3\x2\x2\x2\x4CD=\x3\x2\x2\x2\x4CE\x4CF");
		sb.Append("\a\x95\x2\x2\x4CF\x4D0\at\x2\x2\x4D0\x4D1\a\x142\x2\x2\x4D1");
		sb.Append("?\x3\x2\x2\x2\x4D2\x4D3\a\x95\x2\x2\x4D3\x4D5\x5N(\x2\x4D4\x4D6");
		sb.Append("\x5T+\x2\x4D5\x4D4\x3\x2\x2\x2\x4D5\x4D6\x3\x2\x2\x2\x4D6\x41");
		sb.Append("\x3\x2\x2\x2\x4D7\x4D8\t\t\x2\x2\x4D8\x4DD\x5L\'\x2\x4D9\x4DA");
		sb.Append("\a\x10B\x2\x2\x4DA\x4DC\x5L\'\x2\x4DB\x4D9\x3\x2\x2\x2\x4DC");
		sb.Append("\x4DF\x3\x2\x2\x2\x4DD\x4DB\x3\x2\x2\x2\x4DD\x4DE\x3\x2\x2\x2");
		sb.Append("\x4DE\x4E0\x3\x2\x2\x2\x4DF\x4DD\x3\x2\x2\x2\x4E0\x4E8\a\x107");
		sb.Append("\x2\x2\x4E1\x4E9\aX\x2\x2\x4E2\x4E3\x5\x292\x14A\x2\x4E3\x4E4");
		sb.Append("\a\x1E4\x2\x2\x4E4\x4E6\x3\x2\x2\x2\x4E5\x4E2\x3\x2\x2\x2\x4E5");
		sb.Append("\x4E6\x3\x2\x2\x2\x4E6\x4E7\x3\x2\x2\x2\x4E7\x4E9\a\x149\x2");
		sb.Append("\x2\x4E8\x4E1\x3\x2\x2\x2\x4E8\x4E5\x3\x2\x2\x2\x4E9\x43\x3");
		sb.Append("\x2\x2\x2\x4EA\x4EB\a@\x2\x2\x4EB\x4F0\a\x189\x2\x2\x4EC\x4ED");
		sb.Append("\a,\x2\x2\x4ED\x4F0\x5\x2EA\x176\x2\x4EE\x4F0\x5\x110\x89\x2");
		sb.Append("\x4EF\x4EA\x3\x2\x2\x2\x4EF\x4EC\x3\x2\x2\x2\x4EF\x4EE\x3\x2");
		sb.Append("\x2\x2\x4F0\x45\x3\x2\x2\x2\x4F1\x4F3\x5\x294\x14B\x2\x4F2\x4F4");
		sb.Append("\x5\x2C8\x165\x2\x4F3\x4F2\x3\x2\x2\x2\x4F3\x4F4\x3\x2\x2\x2");
		sb.Append("\x4F4G\x3\x2\x2\x2\x4F5\x4F6\a@\x2\x2\x4F6\x4FA\a\x189\x2\x2");
		sb.Append("\x4F7\x4F9\x5\xC0\x61\x2\x4F8\x4F7\x3\x2\x2\x2\x4F9\x4FC\x3");
		sb.Append("\x2\x2\x2\x4FA\x4F8\x3\x2\x2\x2\x4FA\x4FB\x3\x2\x2\x2\x4FB\x4FE");
		sb.Append("\x3\x2\x2\x2\x4FC\x4FA\x3\x2\x2\x2\x4FD\x4FF\x5J&\x2\x4FE\x4FD");
		sb.Append("\x3\x2\x2\x2\x4FF\x500\x3\x2\x2\x2\x500\x4FE\x3\x2\x2\x2\x500");
		sb.Append("\x501\x3\x2\x2\x2\x501\x502\x3\x2\x2\x2\x502\x503\a{\x2\x2\x503");
		sb.Append("\x504\x5\x2B2\x15A\x2\x504I\x3\x2\x2\x2\x505\x506\a\x1A\x2\x2");
		sb.Append("\x506\x507\a\x16D\x2\x2\x507\x508\a\xBC\x2\x2\x508\x509\x5\x110");
		sb.Append("\x89\x2\x509\x50A\a\x1A\x2\x2\x50A\x50B\a\x16D\x2\x2\x50B\x50C");
		sb.Append("\a\x1F7\x2\x2\x50C\x52A\x3\x2\x2\x2\x50D\x50E\a\x1A\x2\x2\x50E");
		sb.Append("\x50F\at\x2\x2\x50F\x510\a\x142\x2\x2\x510\x511\a\xBC\x2\x2");
		sb.Append("\x511\x512\x5\x110\x89\x2\x512\x513\a\x1A\x2\x2\x513\x514\a");
		sb.Append("t\x2\x2\x514\x515\a\x142\x2\x2\x515\x516\a\x1F7\x2\x2\x516\x52A");
		sb.Append("\x3\x2\x2\x2\x517\x518\a\x6\x2\x2\x518\x519\a\x16D\x2\x2\x519");
		sb.Append("\x51A\a\xBC\x2\x2\x51A\x51B\x5\x110\x89\x2\x51B\x51C\a\x6\x2");
		sb.Append("\x2\x51C\x51D\a\x16D\x2\x2\x51D\x51E\a\x1F7\x2\x2\x51E\x52A");
		sb.Append("\x3\x2\x2\x2\x51F\x520\a\x6\x2\x2\x520\x521\at\x2\x2\x521\x522");
		sb.Append("\a\x142\x2\x2\x522\x523\a\xBC\x2\x2\x523\x524\x5\x110\x89\x2");
		sb.Append("\x524\x525\a\x6\x2\x2\x525\x526\at\x2\x2\x526\x527\a\x142\x2");
		sb.Append("\x2\x527\x528\a\x1F7\x2\x2\x528\x52A\x3\x2\x2\x2\x529\x505\x3");
		sb.Append("\x2\x2\x2\x529\x50D\x3\x2\x2\x2\x529\x517\x3\x2\x2\x2\x529\x51F");
		sb.Append("\x3\x2\x2\x2\x52AK\x3\x2\x2\x2\x52B\x546\a\n\x2\x2\x52C\x546");
		sb.Append("\a\v\x2\x2\x52D\x52E\a\x11\x2\x2\x52E\x546\a\x170\x2\x2\x52F");
		sb.Append("\x546\a\x14\x2\x2\x530\x546\a;\x2\x2\x531\x546\aO\x2\x2\x532");
		sb.Append("\x533\an\x2\x2\x533\x546\a\x170\x2\x2\x534\x546\ar\x2\x2\x535");
		sb.Append("\x546\a\x9C\x2\x2\x536\x546\a\xF1\x2\x2\x537\x546\a\x134\x2");
		sb.Append("\x2\x538\x546\a\x13E\x2\x2\x539\x546\a\x18C\x2\x2\x53A\x546");
		sb.Append("\a]\x2\x2\x53B\x546\a\x16C\x2\x2\x53C\x546\a\x15D\x2\x2\x53D");
		sb.Append("\x546\a[\x2\x2\x53E\x546\a\xD3\x2\x2\x53F\x546\a\xD2\x2\x2\x540");
		sb.Append("\x546\a\x156\x2\x2\x541\x546\a\x177\x2\x2\x542\x546\aX\x2\x2");
		sb.Append("\x543\x546\a\x149\x2\x2\x544\x546\a\x94\x2\x2\x545\x52B\x3\x2");
		sb.Append("\x2\x2\x545\x52C\x3\x2\x2\x2\x545\x52D\x3\x2\x2\x2\x545\x52F");
		sb.Append("\x3\x2\x2\x2\x545\x530\x3\x2\x2\x2\x545\x531\x3\x2\x2\x2\x545");
		sb.Append("\x532\x3\x2\x2\x2\x545\x534\x3\x2\x2\x2\x545\x535\x3\x2\x2\x2");
		sb.Append("\x545\x536\x3\x2\x2\x2\x545\x537\x3\x2\x2\x2\x545\x538\x3\x2");
		sb.Append("\x2\x2\x545\x539\x3\x2\x2\x2\x545\x53A\x3\x2\x2\x2\x545\x53B");
		sb.Append("\x3\x2\x2\x2\x545\x53C\x3\x2\x2\x2\x545\x53D\x3\x2\x2\x2\x545");
		sb.Append("\x53E\x3\x2\x2\x2\x545\x53F\x3\x2\x2\x2\x545\x540\x3\x2\x2\x2");
		sb.Append("\x545\x541\x3\x2\x2\x2\x545\x542\x3\x2\x2\x2\x545\x543\x3\x2");
		sb.Append("\x2\x2\x545\x544\x3\x2\x2\x2\x546M\x3\x2\x2\x2\x547\x54C\x5");
		sb.Append("P)\x2\x548\x549\a\x10B\x2\x2\x549\x54B\x5P)\x2\x54A\x548\x3");
		sb.Append("\x2\x2\x2\x54B\x54E\x3\x2\x2\x2\x54C\x54A\x3\x2\x2\x2\x54C\x54D");
		sb.Append("\x3\x2\x2\x2\x54D\x54F\x3\x2\x2\x2\x54E\x54C\x3\x2\x2\x2\x54F");
		sb.Append("\x551\a\x107\x2\x2\x550\x552\x5R*\x2\x551\x550\x3\x2\x2\x2\x551");
		sb.Append("\x552\x3\x2\x2\x2\x552\x553\x3\x2\x2\x2\x553\x554\x5\x2C2\x162");
		sb.Append("\x2\x554O\x3\x2\x2\x2\x555\x55F\t\n\x2\x2\x556\x557\a\x103\x2");
		sb.Append("\x2\x557\x55C\x5\x2C0\x161\x2\x558\x559\a\x1F1\x2\x2\x559\x55B");
		sb.Append("\x5\x2C0\x161\x2\x55A\x558\x3\x2\x2\x2\x55B\x55E\x3\x2\x2\x2");
		sb.Append("\x55C\x55A\x3\x2\x2\x2\x55C\x55D\x3\x2\x2\x2\x55D\x560\x3\x2");
		sb.Append("\x2\x2\x55E\x55C\x3\x2\x2\x2\x55F\x556\x3\x2\x2\x2\x55F\x560");
		sb.Append("\x3\x2\x2\x2\x560Q\x3\x2\x2\x2\x561\x562\a\xEE\x2\x2\x562\x563");
		sb.Append("\a\x178\x2\x2\x563\x564\x5\x2C2\x162\x2\x564\x565\a\x103\x2");
		sb.Append("\x2\x565S\x3\x2\x2\x2\x566\x568\a\x131\x2\x2\x567\x569\x5V,");
		sb.Append("\x2\x568\x567\x3\x2\x2\x2\x569\x56A\x3\x2\x2\x2\x56A\x568\x3");
		sb.Append("\x2\x2\x2\x56A\x56B\x3\x2\x2\x2\x56BU\x3\x2\x2\x2\x56C\x56D");
		sb.Append("\t\v\x2\x2\x56D\x56E\x5\x27A\x13E\x2\x56EW\x3\x2\x2\x2\x56F");
		sb.Append("\x570\ar\x2\x2\x570\x572\a\x18D\x2\x2\x571\x573\a#\x2\x2\x572");
		sb.Append("\x571\x3\x2\x2\x2\x572\x573\x3\x2\x2\x2\x573\x574\x3\x2\x2\x2");
		sb.Append("\x574\x576\x5\x2A8\x155\x2\x575\x577\t\f\x2\x2\x576\x575\x3");
		sb.Append("\x2\x2\x2\x576\x577\x3\x2\x2\x2\x577\x578\x3\x2\x2\x2\x578\x579");
		sb.Append("\a\x1F7\x2\x2\x579Y\x3\x2\x2\x2\x57A\x57B\a\n\x2\x2\x57B\x57C");
		sb.Append("\a\x18D\x2\x2\x57C\x582\x5\x2A8\x155\x2\x57D\x583\x5\\/\x2\x57E");
		sb.Append("\x583\x5^\x30\x2\x57F\x583\x5`\x31\x2\x580\x583\x5h\x35\x2\x581");
		sb.Append("\x583\x5\x8A\x46\x2\x582\x57D\x3\x2\x2\x2\x582\x57E\x3\x2\x2");
		sb.Append("\x2\x582\x57F\x3\x2\x2\x2\x582\x580\x3\x2\x2\x2\x582\x581\x3");
		sb.Append("\x2\x2\x2\x583\x585\x3\x2\x2\x2\x584\x586\x5j\x36\x2\x585\x584");
		sb.Append("\x3\x2\x2\x2\x585\x586\x3\x2\x2\x2\x586\x587\x3\x2\x2\x2\x587");
		sb.Append("\x588\a\x1F7\x2\x2\x588[\x3\x2\x2\x2\x589\x58B\a?\x2\x2\x58A");
		sb.Append("\x58C\a^\x2\x2\x58B\x58A\x3\x2\x2\x2\x58B\x58C\x3\x2\x2\x2\x58C");
		sb.Append("\x58E\x3\x2\x2\x2\x58D\x58F\t\r\x2\x2\x58E\x58D\x3\x2\x2\x2");
		sb.Append("\x58E\x58F\x3\x2\x2\x2\x58F\x593\x3\x2\x2\x2\x590\x592\x5\xB0");
		sb.Append("Y\x2\x591\x590\x3\x2\x2\x2\x592\x595\x3\x2\x2\x2\x593\x591\x3");
		sb.Append("\x2\x2\x2\x593\x594\x3\x2\x2\x2\x594\x598\x3\x2\x2\x2\x595\x593");
		sb.Append("\x3\x2\x2\x2\x596\x597\a\x13C\x2\x2\x597\x599\a\x15A\x2\x2\x598");
		sb.Append("\x596\x3\x2\x2\x2\x598\x599\x3\x2\x2\x2\x599]\x3\x2\x2\x2\x59A");
		sb.Append("\x59C\a\x135\x2\x2\x59B\x59D\x5\xAEX\x2\x59C\x59B\x3\x2\x2\x2");
		sb.Append("\x59C\x59D\x3\x2\x2\x2\x59D\x59E\x3\x2\x2\x2\x59E\x59F\a\xF");
		sb.Append("\x2\x2\x59F\x5A0\a\x102\x2\x2\x5A0\x5A1\a\x1EB\x2\x2\x5A1\x5A6");
		sb.Append("\x5\x8CG\x2\x5A2\x5A3\a\x1F1\x2\x2\x5A3\x5A5\x5\x8CG\x2\x5A4");
		sb.Append("\x5A2\x3\x2\x2\x2\x5A5\x5A8\x3\x2\x2\x2\x5A6\x5A4\x3\x2\x2\x2");
		sb.Append("\x5A6\x5A7\x3\x2\x2\x2\x5A7\x5A9\x3\x2\x2\x2\x5A8\x5A6\x3\x2");
		sb.Append("\x2\x2\x5A9\x5AA\a\x1EC\x2\x2\x5AA_\x3\x2\x2\x2\x5AB\x5B0\x5");
		sb.Append("\x62\x32\x2\x5AC\x5AD\a\x1F1\x2\x2\x5AD\x5AF\x5\x62\x32\x2\x5AE");
		sb.Append("\x5AC\x3\x2\x2\x2\x5AF\x5B2\x3\x2\x2\x2\x5B0\x5AE\x3\x2\x2\x2");
		sb.Append("\x5B0\x5B1\x3\x2\x2\x2\x5B1\x61\x3\x2\x2\x2\x5B2\x5B0\x3\x2");
		sb.Append("\x2\x2\x5B3\x5B6\t\xE\x2\x2\x5B4\x5B7\x5\x9CO\x2\x5B5\x5B7\x5");
		sb.Append("\x94K\x2\x5B6\x5B4\x3\x2\x2\x2\x5B6\x5B5\x3\x2\x2\x2\x5B7\x63");
		sb.Append("\x3\x2\x2\x2\x5B8\x5B9\t\xF\x2\x2\x5B9\x5C6\a\x13\x2\x2\x5BA");
		sb.Append("\x5C7\x5\x66\x34\x2\x5BB\x5BC\a\x1EB\x2\x2\x5BC\x5C1\x5\x66");
		sb.Append("\x34\x2\x5BD\x5BE\a\x1F1\x2\x2\x5BE\x5C0\x5\x66\x34\x2\x5BF");
		sb.Append("\x5BD\x3\x2\x2\x2\x5C0\x5C3\x3\x2\x2\x2\x5C1\x5BF\x3\x2\x2\x2");
		sb.Append("\x5C1\x5C2\x3\x2\x2\x2\x5C2\x5C4\x3\x2\x2\x2\x5C3\x5C1\x3\x2");
		sb.Append("\x2\x2\x5C4\x5C5\a\x1EC\x2\x2\x5C5\x5C7\x3\x2\x2\x2\x5C6\x5BA");
		sb.Append("\x3\x2\x2\x2\x5C6\x5BB\x3\x2\x2\x2\x5C7\x65\x3\x2\x2\x2\x5C8");
		sb.Append("\x5CA\x5\x28A\x146\x2\x5C9\x5CB\x5\x2D2\x16A\x2\x5CA\x5C9\x3");
		sb.Append("\x2\x2\x2\x5CA\x5CB\x3\x2\x2\x2\x5CBg\x3\x2\x2\x2\x5CC\x5D2");
		sb.Append("\a\xE3\x2\x2\x5CD\x5CE\a\xCD\x2\x2\x5CE\x5D3\x5\x1F4\xFB\x2");
		sb.Append("\x5CF\x5D0\au\x2\x2\x5D0\x5D1\a\x18D\x2\x2\x5D1\x5D3\x5\x2D2");
		sb.Append("\x16A\x2\x5D2\x5CD\x3\x2\x2\x2\x5D2\x5CF\x3\x2\x2\x2\x5D3i\x3");
		sb.Append("\x2\x2\x2\x5D4\x5E5\a\xBB\x2\x2\x5D5\x5DF\a.\x2\x2\x5D6\x5D7");
		sb.Append("\aJ\x2\x2\x5D7\x5D8\a\x184\x2\x2\x5D8\x5E0\a\x174\x2\x2\x5D9");
		sb.Append("\x5DB\a\xFB\x2\x2\x5DA\x5D9\x3\x2\x2\x2\x5DA\x5DB\x3\x2\x2\x2");
		sb.Append("\x5DB\x5DC\x3\x2\x2\x2\x5DC\x5DD\a\xA8\x2\x2\x5DD\x5DE\a\x178");
		sb.Append("\x2\x2\x5DE\x5E0\aW\x2\x2\x5DF\x5D6\x3\x2\x2\x2\x5DF\x5DA\x3");
		sb.Append("\x2\x2\x2\x5DF\x5E0\x3\x2\x2\x2\x5E0\x5E2\x3\x2\x2\x2\x5E1\x5E3");
		sb.Append("\x5l\x37\x2\x5E2\x5E1\x3\x2\x2\x2\x5E2\x5E3\x3\x2\x2\x2\x5E3");
		sb.Append("\x5E5\x3\x2\x2\x2\x5E4\x5D4\x3\x2\x2\x2\x5E4\x5D5\x3\x2\x2\x2");
		sb.Append("\x5E5k\x3\x2\x2\x2\x5E6\x5E8\a\x97\x2\x2\x5E7\x5E6\x3\x2\x2");
		sb.Append("\x2\x5E7\x5E8\x3\x2\x2\x2\x5E8\x5E9\x3\x2\x2\x2\x5E9\x5EA\a");
		sb.Append("\x83\x2\x2\x5EA\x5EB\a\xBA\x2\x2\x5EB\x5EC\x5\x2C2\x162\x2\x5EC");
		sb.Append("m\x3\x2\x2\x2\x5ED\x5F0\aO\x2\x2\x5EE\x5EF\a\x10B\x2\x2\x5EF");
		sb.Append("\x5F1\a\x135\x2\x2\x5F0\x5EE\x3\x2\x2\x2\x5F0\x5F1\x3\x2\x2");
		sb.Append("\x2\x5F1\x5F2\x3\x2\x2\x2\x5F2\x5F5\a\x18D\x2\x2\x5F3\x5F6\x5");
		sb.Append("p\x39\x2\x5F4\x5F6\x5|?\x2\x5F5\x5F3\x3\x2\x2\x2\x5F5\x5F4\x3");
		sb.Append("\x2\x2\x2\x5F6\x5F7\x3\x2\x2\x2\x5F7\x5F8\a\x1F7\x2\x2\x5F8");
		sb.Append("o\x3\x2\x2\x2\x5F9\x5FC\x5\x2A8\x155\x2\x5FA\x5FB\a\x105\x2");
		sb.Append("\x2\x5FB\x5FD\a\x1E7\x2\x2\x5FC\x5FA\x3\x2\x2\x2\x5FC\x5FD\x3");
		sb.Append("\x2\x2\x2\x5FD\x5FF\x3\x2\x2\x2\x5FE\x600\x5r:\x2\x5FF\x5FE");
		sb.Append("\x3\x2\x2\x2\x5FF\x600\x3\x2\x2\x2\x600q\x3\x2\x2\x2\x601\x603");
		sb.Append("\x5\xAEX\x2\x602\x601\x3\x2\x2\x2\x602\x603\x3\x2\x2\x2\x603");
		sb.Append("\x606\x3\x2\x2\x2\x604\x607\x5t;\x2\x605\x607\x5v<\x2\x606\x604");
		sb.Append("\x3\x2\x2\x2\x606\x605\x3\x2\x2\x2\x607\x609\x3\x2\x2\x2\x608");
		sb.Append("\x60A\x5z>\x2\x609\x608\x3\x2\x2\x2\x609\x60A\x3\x2\x2\x2\x60A");
		sb.Append("\x616\x3\x2\x2\x2\x60B\x60C\a\x1EB\x2\x2\x60C\x611\x5\x8CG\x2");
		sb.Append("\x60D\x60E\a\x1F1\x2\x2\x60E\x610\x5\x8CG\x2\x60F\x60D\x3\x2");
		sb.Append("\x2\x2\x610\x613\x3\x2\x2\x2\x611\x60F\x3\x2\x2\x2\x611\x612");
		sb.Append("\x3\x2\x2\x2\x612\x614\x3\x2\x2\x2\x613\x611\x3\x2\x2\x2\x614");
		sb.Append("\x615\a\x1EC\x2\x2\x615\x617\x3\x2\x2\x2\x616\x60B\x3\x2\x2");
		sb.Append("\x2\x616\x617\x3\x2\x2\x2\x617\x61B\x3\x2\x2\x2\x618\x61A\x5");
		sb.Append("\x8A\x46\x2\x619\x618\x3\x2\x2\x2\x61A\x61D\x3\x2\x2\x2\x61B");
		sb.Append("\x619\x3\x2\x2\x2\x61B\x61C\x3\x2\x2\x2\x61Cs\x3\x2\x2\x2\x61D");
		sb.Append("\x61B\x3\x2\x2\x2\x61E\x622\t\x3\x2\x2\x61F\x623\a\x102\x2\x2");
		sb.Append("\x620\x623\x5\xDCo\x2\x621\x623\x5x=\x2\x622\x61F\x3\x2\x2\x2");
		sb.Append("\x622\x620\x3\x2\x2\x2\x622\x621\x3\x2\x2\x2\x623u\x3\x2\x2");
		sb.Append("\x2\x624\x625\a\x18F\x2\x2\x625\x626\x5\x2D2\x16A\x2\x626w\x3");
		sb.Append("\x2\x2\x2\x627\x628\a\x178\x2\x2\x628\x629\a\x103\x2\x2\x629");
		sb.Append("\x62C\x5\x2D2\x16A\x2\x62A\x62B\a\xFB\x2\x2\x62B\x62D\a\xFD");
		sb.Append("\x2\x2\x62C\x62A\x3\x2\x2\x2\x62C\x62D\x3\x2\x2\x2\x62Dy\x3");
		sb.Append("\x2\x2\x2\x62E\x62F\a\x8A\x2\x2\x62F\x630\a\xE6\x2\x2\x630\x631");
		sb.Append("\x5\x1F4\xFB\x2\x631\x632\a\xC2\x2\x2\x632\x633\a\xBF\x2\x2");
		sb.Append("\x633\x634\a\x19A\x2\x2\x634\x635\t\x10\x2\x2\x635{\x3\x2\x2");
		sb.Append("\x2\x636\x637\a#\x2\x2\x637\x638\x5\x2A8\x155\x2\x638\x63A\t");
		sb.Append("\x3\x2\x2\x639\x63B\x5~@\x2\x63A\x639\x3\x2\x2\x2\x63B\x63C");
		sb.Append("\x3\x2\x2\x2\x63C\x63A\x3\x2\x2\x2\x63C\x63D\x3\x2\x2\x2\x63D");
		sb.Append("\x63E\x3\x2\x2\x2\x63E\x63F\a{\x2\x2\x63F}\x3\x2\x2\x2\x640");
		sb.Append("\x643\x5\x80\x41\x2\x641\x643\x5\x82\x42\x2\x642\x640\x3\x2");
		sb.Append("\x2\x2\x642\x641\x3\x2\x2\x2\x643\x7F\x3\x2\x2\x2\x644\x645");
		sb.Append("\t\x11\x2\x2\x645\x646\a\xDB\x2\x2\x646\x647\x5\x86\x44\x2\x647");
		sb.Append("\x81\x3\x2\x2\x2\x648\x64C\t\x12\x2\x2\x649\x64D\x5\x84\x43");
		sb.Append("\x2\x64A\x64D\x5\x86\x44\x2\x64B\x64D\x5\x88\x45\x2\x64C\x649");
		sb.Append("\x3\x2\x2\x2\x64C\x64A\x3\x2\x2\x2\x64C\x64B\x3\x2\x2\x2\x64D");
		sb.Append("\x83\x3\x2\x2\x2\x64E\x64F\a\x128\x2\x2\x64F\x650\x5\x2B0\x159");
		sb.Append("\x2\x650\x651\a\x1EB\x2\x2\x651\x656\x5\xA2R\x2\x652\x653\a");
		sb.Append("\x1F1\x2\x2\x653\x655\x5\xA2R\x2\x654\x652\x3\x2\x2\x2\x655");
		sb.Append("\x658\x3\x2\x2\x2\x656\x654\x3\x2\x2\x2\x656\x657\x3\x2\x2\x2");
		sb.Append("\x657\x659\x3\x2\x2\x2\x658\x656\x3\x2\x2\x2\x659\x65A\a\x1EC");
		sb.Append("\x2\x2\x65A\x668\t\x3\x2\x2\x65B\x669\x5\xB2Z\x2\x65C\x65E\a");
		sb.Append("\x61\x2\x2\x65D\x65C\x3\x2\x2\x2\x65D\x65E\x3\x2\x2\x2\x65E");
		sb.Append("\x662\x3\x2\x2\x2\x65F\x661\x5\xC0\x61\x2\x660\x65F\x3\x2\x2");
		sb.Append("\x2\x661\x664\x3\x2\x2\x2\x662\x660\x3\x2\x2\x2\x662\x663\x3");
		sb.Append("\x2\x2\x2\x663\x665\x3\x2\x2\x2\x664\x662\x3\x2\x2\x2\x665\x666");
		sb.Append("\x5\x10A\x86\x2\x666\x667\a\x1F7\x2\x2\x667\x669\x3\x2\x2\x2");
		sb.Append("\x668\x65B\x3\x2\x2\x2\x668\x65D\x3\x2\x2\x2\x669\x85\x3\x2");
		sb.Append("\x2\x2\x66A\x66B\a\x9A\x2\x2\x66B\x677\x5\x2AE\x158\x2\x66C");
		sb.Append("\x66D\a\x1EB\x2\x2\x66D\x672\x5\xA2R\x2\x66E\x66F\a\x1F1\x2");
		sb.Append("\x2\x66F\x671\x5\xA2R\x2\x670\x66E\x3\x2\x2\x2\x671\x674\x3");
		sb.Append("\x2\x2\x2\x672\x670\x3\x2\x2\x2\x672\x673\x3\x2\x2\x2\x673\x675");
		sb.Append("\x3\x2\x2\x2\x674\x672\x3\x2\x2\x2\x675\x676\a\x1EC\x2\x2\x676");
		sb.Append("\x678\x3\x2\x2\x2\x677\x66C\x3\x2\x2\x2\x677\x678\x3\x2\x2\x2");
		sb.Append("\x678\x679\x3\x2\x2\x2\x679\x67A\a\x13A\x2\x2\x67A\x67B\x5\x2D2");
		sb.Append("\x16A\x2\x67B\x689\t\x3\x2\x2\x67C\x68A\x5\xB2Z\x2\x67D\x67F");
		sb.Append("\a\x61\x2\x2\x67E\x67D\x3\x2\x2\x2\x67E\x67F\x3\x2\x2\x2\x67F");
		sb.Append("\x683\x3\x2\x2\x2\x680\x682\x5\xC0\x61\x2\x681\x680\x3\x2\x2");
		sb.Append("\x2\x682\x685\x3\x2\x2\x2\x683\x681\x3\x2\x2\x2\x683\x684\x3");
		sb.Append("\x2\x2\x2\x684\x686\x3\x2\x2\x2\x685\x683\x3\x2\x2\x2\x686\x687");
		sb.Append("\x5\x10A\x86\x2\x687\x688\a\x1F7\x2\x2\x688\x68A\x3\x2\x2\x2");
		sb.Append("\x689\x67C\x3\x2\x2\x2\x689\x67E\x3\x2\x2\x2\x68A\x87\x3\x2");
		sb.Append("\x2\x2\x68B\x68D\a\x8F\x2\x2\x68C\x68B\x3\x2\x2\x2\x68C\x68D");
		sb.Append("\x3\x2\x2\x2\x68D\x68F\x3\x2\x2\x2\x68E\x690\a\xB4\x2\x2\x68F");
		sb.Append("\x68E\x3\x2\x2\x2\x68F\x690\x3\x2\x2\x2\x690\x691\x3\x2\x2\x2");
		sb.Append("\x691\x692\a\x46\x2\x2\x692\x693\a\x9A\x2\x2\x693\x6A5\x5\x2D2");
		sb.Append("\x16A\x2\x694\x695\a\x1EB\x2\x2\x695\x696\a\x151\x2\x2\x696");
		sb.Append("\x697\a\xA6\x2\x2\x697\x698\a\x110\x2\x2\x698\x699\x5\x2D2\x16A");
		sb.Append("\x2\x699\x69A\a\x1F1\x2\x2\x69A\x69B\x3\x2\x2\x2\x69B\x6A0\x5");
		sb.Append("\xA2R\x2\x69C\x69D\a\x1F1\x2\x2\x69D\x69F\x5\xA2R\x2\x69E\x69C");
		sb.Append("\x3\x2\x2\x2\x69F\x6A2\x3\x2\x2\x2\x6A0\x69E\x3\x2\x2\x2\x6A0");
		sb.Append("\x6A1\x3\x2\x2\x2\x6A1\x6A3\x3\x2\x2\x2\x6A2\x6A0\x3\x2\x2\x2");
		sb.Append("\x6A3\x6A4\a\x1EC\x2\x2\x6A4\x6A6\x3\x2\x2\x2\x6A5\x694\x3\x2");
		sb.Append("\x2\x2\x6A5\x6A6\x3\x2\x2\x2\x6A6\x6A7\x3\x2\x2\x2\x6A7\x6A8");
		sb.Append("\a\x13A\x2\x2\x6A8\x6A9\a\x151\x2\x2\x6A9\x6AA\a\xF\x2\x2\x6AA");
		sb.Append("\x6AB\a\x138\x2\x2\x6AB\x6B9\t\x3\x2\x2\x6AC\x6BA\x5\xB2Z\x2");
		sb.Append("\x6AD\x6AF\a\x61\x2\x2\x6AE\x6AD\x3\x2\x2\x2\x6AE\x6AF\x3\x2");
		sb.Append("\x2\x2\x6AF\x6B3\x3\x2\x2\x2\x6B0\x6B2\x5\xC0\x61\x2\x6B1\x6B0");
		sb.Append("\x3\x2\x2\x2\x6B2\x6B5\x3\x2\x2\x2\x6B3\x6B1\x3\x2\x2\x2\x6B3");
		sb.Append("\x6B4\x3\x2\x2\x2\x6B4\x6B6\x3\x2\x2\x2\x6B5\x6B3\x3\x2\x2\x2");
		sb.Append("\x6B6\x6B7\x5\x10A\x86\x2\x6B7\x6B8\a\x1F7\x2\x2\x6B8\x6BA\x3");
		sb.Append("\x2\x2\x2\x6B9\x6AC\x3\x2\x2\x2\x6B9\x6AE\x3\x2\x2\x2\x6BA\x89");
		sb.Append("\x3\x2\x2\x2\x6BB\x6BD\a\xFB\x2\x2\x6BC\x6BB\x3\x2\x2\x2\x6BC");
		sb.Append("\x6BD\x3\x2\x2\x2\x6BD\x6BE\x3\x2\x2\x2\x6BE\x6BF\t\x13\x2\x2");
		sb.Append("\x6BF\x8B\x3\x2\x2\x2\x6C0\x6C1\x5\x2EA\x176\x2\x6C1\x6C3\x5");
		sb.Append("\x2D2\x16A\x2\x6C2\x6C4\x5\x8EH\x2\x6C3\x6C2\x3\x2\x2\x2\x6C3");
		sb.Append("\x6C4\x3\x2\x2\x2\x6C4\x6C7\x3\x2\x2\x2\x6C5\x6C7\x5\x90I\x2");
		sb.Append("\x6C6\x6C0\x3\x2\x2\x2\x6C6\x6C5\x3\x2\x2\x2\x6C7\x8D\x3\x2");
		sb.Append("\x2\x2\x6C8\x6C9\a\x8A\x2\x2\x6C9\x6CA\a\xE6\x2\x2\x6CA\x6CB");
		sb.Append("\x5\x1F4\xFB\x2\x6CB\x8F\x3\x2\x2\x2\x6CC\x6CE\x5\x8A\x46\x2");
		sb.Append("\x6CD\x6CC\x3\x2\x2\x2\x6CD\x6CE\x3\x2\x2\x2\x6CE\x6D0\x3\x2");
		sb.Append("\x2\x2\x6CF\x6D1\x5\x92J\x2\x6D0\x6CF\x3\x2\x2\x2\x6D1\x6D2");
		sb.Append("\x3\x2\x2\x2\x6D2\x6D0\x3\x2\x2\x2\x6D2\x6D3\x3\x2\x2\x2\x6D3");
		sb.Append("\x6D6\x3\x2\x2\x2\x6D4\x6D5\a\x1F1\x2\x2\x6D5\x6D7\x5\x9EP\x2");
		sb.Append("\x6D6\x6D4\x3\x2\x2\x2\x6D6\x6D7\x3\x2\x2\x2\x6D7\x91\x3\x2");
		sb.Append("\x2\x2\x6D8\x6DC\x5\x94K\x2\x6D9\x6DC\x5\x9AN\x2\x6DA\x6DC\x5");
		sb.Append("\x9CO\x2\x6DB\x6D8\x3\x2\x2\x2\x6DB\x6D9\x3\x2\x2\x2\x6DB\x6DA");
		sb.Append("\x3\x2\x2\x2\x6DC\x93\x3\x2\x2\x2\x6DD\x6E0\t\x12\x2\x2\x6DE");
		sb.Append("\x6E1\x5\x96L\x2\x6DF\x6E1\x5\x98M\x2\x6E0\x6DE\x3\x2\x2\x2");
		sb.Append("\x6E0\x6DF\x3\x2\x2\x2\x6E1\x95\x3\x2\x2\x2\x6E2\x6E3\a\x128");
		sb.Append("\x2\x2\x6E3\x6E4\x5\x2B0\x159\x2\x6E4\x6E5\a\x1EB\x2\x2\x6E5");
		sb.Append("\x6EA\x5\xA2R\x2\x6E6\x6E7\a\x1F1\x2\x2\x6E7\x6E9\x5\xA2R\x2");
		sb.Append("\x6E8\x6E6\x3\x2\x2\x2\x6E9\x6EC\x3\x2\x2\x2\x6EA\x6E8\x3\x2");
		sb.Append("\x2\x2\x6EA\x6EB\x3\x2\x2\x2\x6EB\x6ED\x3\x2\x2\x2\x6EC\x6EA");
		sb.Append("\x3\x2\x2\x2\x6ED\x6F0\a\x1EC\x2\x2\x6EE\x6EF\t\x3\x2\x2\x6EF");
		sb.Append("\x6F1\x5\xB2Z\x2\x6F0\x6EE\x3\x2\x2\x2\x6F0\x6F1\x3\x2\x2\x2");
		sb.Append("\x6F1\x97\x3\x2\x2\x2\x6F2\x6F3\a\x9A\x2\x2\x6F3\x6FF\x5\x2AE");
		sb.Append("\x158\x2\x6F4\x6F5\a\x1EB\x2\x2\x6F5\x6FA\x5\xA2R\x2\x6F6\x6F7");
		sb.Append("\a\x1F1\x2\x2\x6F7\x6F9\x5\xA2R\x2\x6F8\x6F6\x3\x2\x2\x2\x6F9");
		sb.Append("\x6FC\x3\x2\x2\x2\x6FA\x6F8\x3\x2\x2\x2\x6FA\x6FB\x3\x2\x2\x2");
		sb.Append("\x6FB\x6FD\x3\x2\x2\x2\x6FC\x6FA\x3\x2\x2\x2\x6FD\x6FE\a\x1EC");
		sb.Append("\x2\x2\x6FE\x700\x3\x2\x2\x2\x6FF\x6F4\x3\x2\x2\x2\x6FF\x700");
		sb.Append("\x3\x2\x2\x2\x700\x701\x3\x2\x2\x2\x701\x706\a\x13A\x2\x2\x702");
		sb.Append("\x707\x5\x2D2\x16A\x2\x703\x704\a\x151\x2\x2\x704\x705\a\xF");
		sb.Append("\x2\x2\x705\x707\a\x138\x2\x2\x706\x702\x3\x2\x2\x2\x706\x703");
		sb.Append("\x3\x2\x2\x2\x707\x710\x3\x2\x2\x2\x708\x709\t\x3\x2\x2\x709");
		sb.Append("\x711\x5\xB2Z\x2\x70A\x70C\a\x8A\x2\x2\x70B\x70D\a\x1A0\x2\x2");
		sb.Append("\x70C\x70B\x3\x2\x2\x2\x70C\x70D\x3\x2\x2\x2\x70D\x70E\x3\x2");
		sb.Append("\x2\x2\x70E\x70F\a\xE6\x2\x2\x70F\x711\x5\x1F4\xFB\x2\x710\x708");
		sb.Append("\x3\x2\x2\x2\x710\x70A\x3\x2\x2\x2\x710\x711\x3\x2\x2\x2\x711");
		sb.Append("\x99\x3\x2\x2\x2\x712\x714\a\x8F\x2\x2\x713\x712\x3\x2\x2\x2");
		sb.Append("\x713\x714\x3\x2\x2\x2\x714\x716\x3\x2\x2\x2\x715\x717\a\xB4");
		sb.Append("\x2\x2\x716\x715\x3\x2\x2\x2\x716\x717\x3\x2\x2\x2\x717\x718");
		sb.Append("\x3\x2\x2\x2\x718\x719\a\x46\x2\x2\x719\x71A\a\x9A\x2\x2\x71A");
		sb.Append("\x72C\x5\x2D2\x16A\x2\x71B\x71C\a\x1EB\x2\x2\x71C\x71D\a\x151");
		sb.Append("\x2\x2\x71D\x71E\a\xA6\x2\x2\x71E\x71F\a\x110\x2\x2\x71F\x720");
		sb.Append("\x5\x2D2\x16A\x2\x720\x721\a\x1F1\x2\x2\x721\x722\x3\x2\x2\x2");
		sb.Append("\x722\x727\x5\xA2R\x2\x723\x724\a\x1F1\x2\x2\x724\x726\x5\xA2");
		sb.Append("R\x2\x725\x723\x3\x2\x2\x2\x726\x729\x3\x2\x2\x2\x727\x725\x3");
		sb.Append("\x2\x2\x2\x727\x728\x3\x2\x2\x2\x728\x72A\x3\x2\x2\x2\x729\x727");
		sb.Append("\x3\x2\x2\x2\x72A\x72B\a\x1EC\x2\x2\x72B\x72D\x3\x2\x2\x2\x72C");
		sb.Append("\x71B\x3\x2\x2\x2\x72C\x72D\x3\x2\x2\x2\x72D\x72E\x3\x2\x2\x2");
		sb.Append("\x72E\x72F\a\x13A\x2\x2\x72F\x730\a\x151\x2\x2\x730\x731\a\xF");
		sb.Append("\x2\x2\x731\x734\a\x138\x2\x2\x732\x733\t\x3\x2\x2\x733\x735");
		sb.Append("\x5\xB2Z\x2\x734\x732\x3\x2\x2\x2\x734\x735\x3\x2\x2\x2\x735");
		sb.Append("\x9B\x3\x2\x2\x2\x736\x737\t\x11\x2\x2\x737\x738\a\xDB\x2\x2");
		sb.Append("\x738\x739\x5\x98M\x2\x739\x9D\x3\x2\x2\x2\x73A\x73B\a\x123");
		sb.Append("\x2\x2\x73B\x73C\a\x137\x2\x2\x73C\x73D\a\x1EB\x2\x2\x73D\x742");
		sb.Append("\x5\xA0Q\x2\x73E\x73F\a\x1F1\x2\x2\x73F\x741\x5\xA0Q\x2\x740");
		sb.Append("\x73E\x3\x2\x2\x2\x741\x744\x3\x2\x2\x2\x742\x740\x3\x2\x2\x2");
		sb.Append("\x742\x743\x3\x2\x2\x2\x743\x745\x3\x2\x2\x2\x744\x742\x3\x2");
		sb.Append("\x2\x2\x745\x746\a\x1EC\x2\x2\x746\x9F\x3\x2\x2\x2\x747\x74A");
		sb.Append("\x5\x2EA\x176\x2\x748\x74A\a\x64\x2\x2\x749\x747\x3\x2\x2\x2");
		sb.Append("\x749\x748\x3\x2\x2\x2\x74A\xA1\x3\x2\x2\x2\x74B\x74C\x5\x29A");
		sb.Append("\x14E\x2\x74C\x74D\x5\x2D2\x16A\x2\x74D\xA3\x3\x2\x2\x2\x74E");
		sb.Append("\x74F\ar\x2\x2\x74F\x750\a\x152\x2\x2\x750\x751\x5\x2AA\x156");
		sb.Append("\x2\x751\x752\a\x1F7\x2\x2\x752\xA5\x3\x2\x2\x2\x753\x754\a");
		sb.Append("\n\x2\x2\x754\x755\a\x152\x2\x2\x755\x757\x5\x2AA\x156\x2\x756");
		sb.Append("\x758\x5\xAAV\x2\x757\x756\x3\x2\x2\x2\x758\x759\x3\x2\x2\x2");
		sb.Append("\x759\x757\x3\x2\x2\x2\x759\x75A\x3\x2\x2\x2\x75A\x75B\x3\x2");
		sb.Append("\x2\x2\x75B\x75C\a\x1F7\x2\x2\x75C\xA7\x3\x2\x2\x2\x75D\x75E");
		sb.Append("\aO\x2\x2\x75E\x75F\a\x152\x2\x2\x75F\x764\x5\x2AA\x156\x2\x760");
		sb.Append("\x763\x5\xACW\x2\x761\x763\x5\xAAV\x2\x762\x760\x3\x2\x2\x2");
		sb.Append("\x762\x761\x3\x2\x2\x2\x763\x766\x3\x2\x2\x2\x764\x762\x3\x2");
		sb.Append("\x2\x2\x764\x765\x3\x2\x2\x2\x765\x767\x3\x2\x2\x2\x766\x764");
		sb.Append("\x3\x2\x2\x2\x767\x768\a\x1F7\x2\x2\x768\xA9\x3\x2\x2\x2\x769");
		sb.Append("\x76A\a\xA9\x2\x2\x76A\x76B\a(\x2\x2\x76B\x77A\a\x1E5\x2\x2");
		sb.Append("\x76C\x76D\a\xD9\x2\x2\x76D\x77A\a\x1E5\x2\x2\x76E\x77A\a\xF6");
		sb.Append("\x2\x2\x76F\x770\a\xDF\x2\x2\x770\x77A\a\x1E5\x2\x2\x771\x77A");
		sb.Append("\a\xF7\x2\x2\x772\x77A\aV\x2\x2\x773\x77A\a\xF4\x2\x2\x774\x775");
		sb.Append("\a+\x2\x2\x775\x77A\a\x1E5\x2\x2\x776\x77A\a\xF2\x2\x2\x777");
		sb.Append("\x77A\a\x10D\x2\x2\x778\x77A\a\xF9\x2\x2\x779\x769\x3\x2\x2");
		sb.Append("\x2\x779\x76C\x3\x2\x2\x2\x779\x76E\x3\x2\x2\x2\x779\x76F\x3");
		sb.Append("\x2\x2\x2\x779\x771\x3\x2\x2\x2\x779\x772\x3\x2\x2\x2\x779\x773");
		sb.Append("\x3\x2\x2\x2\x779\x774\x3\x2\x2\x2\x779\x776\x3\x2\x2\x2\x779");
		sb.Append("\x777\x3\x2\x2\x2\x779\x778\x3\x2\x2\x2\x77A\xAB\x3\x2\x2\x2");
		sb.Append("\x77B\x77C\a\x16B\x2\x2\x77C\x77D\a\x1AC\x2\x2\x77D\x77E\a\x1E5");
		sb.Append("\x2\x2\x77E\xAD\x3\x2\x2\x2\x77F\x780\a\x15\x2\x2\x780\x781");
		sb.Append("\t\x14\x2\x2\x781\xAF\x3\x2\x2\x2\x782\x783\x5\x2EA\x176\x2");
		sb.Append("\x783\x784\a\x202\x2\x2\x784\x785\x5\x1F4\xFB\x2\x785\xB1\x3");
		sb.Append("\x2\x2\x2\x786\x789\a\xC2\x2\x2\x787\x78A\x5\xB4[\x2\x788\x78A");
		sb.Append("\x5\xB6\\\x2\x789\x787\x3\x2\x2\x2\x789\x788\x3\x2\x2\x2\x78A");
		sb.Append("\xB3\x3\x2\x2\x2\x78B\x78C\a\xBF\x2\x2\x78C\x78D\a\xE6\x2\x2");
		sb.Append("\x78D\x78E\a\x1E7\x2\x2\x78E\xB5\x3\x2\x2\x2\x78F\x792\a*\x2");
		sb.Append("\x2\x790\x791\a\xE6\x2\x2\x791\x793\a\x1E7\x2\x2\x792\x790\x3");
		sb.Append("\x2\x2\x2\x792\x793\x3\x2\x2\x2\x793\x794\x3\x2\x2\x2\x794\x795");
		sb.Append("\a\xC8\x2\x2\x795\x797\x5\x2EA\x176\x2\x796\x798\x5\xB8]\x2");
		sb.Append("\x797\x796\x3\x2\x2\x2\x797\x798\x3\x2\x2\x2\x798\x79B\x3\x2");
		sb.Append("\x2\x2\x799\x79A\a\x1AC\x2\x2\x79A\x79C\aH\x2\x2\x79B\x799\x3");
		sb.Append("\x2\x2\x2\x79B\x79C\x3\x2\x2\x2\x79C\x79E\x3\x2\x2\x2\x79D\x79F");
		sb.Append("\x5\xBA^\x2\x79E\x79D\x3\x2\x2\x2\x79E\x79F\x3\x2\x2\x2\x79F");
		sb.Append("\xB7\x3\x2\x2\x2\x7A0\x7A1\a\a\x2\x2\x7A1\x7A2\a\xA6\x2\x2\x7A2");
		sb.Append("\x7A3\a\x1EB\x2\x2\x7A3\x7A8\x5\x1F4\xFB\x2\x7A4\x7A5\a\x1F1");
		sb.Append("\x2\x2\x7A5\x7A7\x5\x1F4\xFB\x2\x7A6\x7A4\x3\x2\x2\x2\x7A7\x7AA");
		sb.Append("\x3\x2\x2\x2\x7A8\x7A6\x3\x2\x2\x2\x7A8\x7A9\x3\x2\x2\x2\x7A9");
		sb.Append("\x7AB\x3\x2\x2\x2\x7AA\x7A8\x3\x2\x2\x2\x7AB\x7AC\a\x1EC\x2");
		sb.Append("\x2\x7AC\xB9\x3\x2\x2\x2\x7AD\x7AE\a\x116\x2\x2\x7AE\x7BA\a");
		sb.Append("\x1EB\x2\x2\x7AF\x7B4\x5\x1F4\xFB\x2\x7B0\x7B1\a\x1F1\x2\x2");
		sb.Append("\x7B1\x7B3\x5\x1F4\xFB\x2\x7B2\x7B0\x3\x2\x2\x2\x7B3\x7B6\x3");
		sb.Append("\x2\x2\x2\x7B4\x7B2\x3\x2\x2\x2\x7B4\x7B5\x3\x2\x2\x2\x7B5\x7BB");
		sb.Append("\x3\x2\x2\x2\x7B6\x7B4\x3\x2\x2\x2\x7B7\x7B8\a\x1E4\x2\x2\x7B8");
		sb.Append("\x7B9\a\x1E4\x2\x2\x7B9\x7BB\a\x1E4\x2\x2\x7BA\x7AF\x3\x2\x2");
		sb.Append("\x2\x7BA\x7B7\x3\x2\x2\x2\x7BB\x7BC\x3\x2\x2\x2\x7BC\x7BD\a");
		sb.Append("\x1EC\x2\x2\x7BD\xBB\x3\x2\x2\x2\x7BE\x7C2\x5\x29A\x14E\x2\x7BF");
		sb.Append("\x7C1\t\x15\x2\x2\x7C0\x7BF\x3\x2\x2\x2\x7C1\x7C4\x3\x2\x2\x2");
		sb.Append("\x7C2\x7C0\x3\x2\x2\x2\x7C2\x7C3\x3\x2\x2\x2\x7C3\x7C6\x3\x2");
		sb.Append("\x2\x2\x7C4\x7C2\x3\x2\x2\x2\x7C5\x7C7\x5\x2D2\x16A\x2\x7C6");
		sb.Append("\x7C5\x3\x2\x2\x2\x7C6\x7C7\x3\x2\x2\x2\x7C7\x7C9\x3\x2\x2\x2");
		sb.Append("\x7C8\x7CA\x5\xBE`\x2\x7C9\x7C8\x3\x2\x2\x2\x7C9\x7CA\x3\x2");
		sb.Append("\x2\x2\x7CA\xBD\x3\x2\x2\x2\x7CB\x7CC\t\x16\x2\x2\x7CC\x7CD");
		sb.Append("\x5\x1F4\xFB\x2\x7CD\xBF\x3\x2\x2\x2\x7CE\x7D8\x5\xC2\x62\x2");
		sb.Append("\x7CF\x7D8\x5\xC4\x63\x2\x7D0\x7D8\x5\xC6\x64\x2\x7D1\x7D8\x5");
		sb.Append("\xCA\x66\x2\x7D2\x7D8\x5\xCCg\x2\x7D3\x7D8\x5\xCEh\x2\x7D4\x7D8");
		sb.Append("\x5\xD6l\x2\x7D5\x7D8\x5\x30\x19\x2\x7D6\x7D8\x5\xE\b\x2\x7D7");
		sb.Append("\x7CE\x3\x2\x2\x2\x7D7\x7CF\x3\x2\x2\x2\x7D7\x7D0\x3\x2\x2\x2");
		sb.Append("\x7D7\x7D1\x3\x2\x2\x2\x7D7\x7D2\x3\x2\x2\x2\x7D7\x7D3\x3\x2");
		sb.Append("\x2\x2\x7D7\x7D4\x3\x2\x2\x2\x7D7\x7D5\x3\x2\x2\x2\x7D7\x7D6");
		sb.Append("\x3\x2\x2\x2\x7D8\xC1\x3\x2\x2\x2\x7D9\x7DB\x5\x2B4\x15B\x2");
		sb.Append("\x7DA\x7DC\a\x43\x2\x2\x7DB\x7DA\x3\x2\x2\x2\x7DB\x7DC\x3\x2");
		sb.Append("\x2\x2\x7DC\x7DD\x3\x2\x2\x2\x7DD\x7E0\x5\x2D2\x16A\x2\x7DE");
		sb.Append("\x7DF\a\xFB\x2\x2\x7DF\x7E1\a\xFD\x2\x2\x7E0\x7DE\x3\x2\x2\x2");
		sb.Append("\x7E0\x7E1\x3\x2\x2\x2\x7E1\x7E3\x3\x2\x2\x2\x7E2\x7E4\x5\xBE");
		sb.Append("`\x2\x7E3\x7E2\x3\x2\x2\x2\x7E3\x7E4\x3\x2\x2\x2\x7E4\x7E5\x3");
		sb.Append("\x2\x2\x2\x7E5\x7E6\a\x1F7\x2\x2\x7E6\xC3\x3\x2\x2\x2\x7E7\x7E8");
		sb.Append("\a\x175\x2\x2\x7E8\x7E9\x5\x2A8\x155\x2\x7E9\x7EA\a\xBC\x2\x2");
		sb.Append("\x7EA\x7F0\x5\x2D2\x16A\x2\x7EB\x7EC\a\x12A\x2\x2\x7EC\x7ED");
		sb.Append("\x5\x1F4\xFB\x2\x7ED\x7EE\a\x3\x2\x2\x7EE\x7EF\x5\x1F4\xFB\x2");
		sb.Append("\x7EF\x7F1\x3\x2\x2\x2\x7F0\x7EB\x3\x2\x2\x2\x7F0\x7F1\x3\x2");
		sb.Append("\x2\x2\x7F1\x7F4\x3\x2\x2\x2\x7F2\x7F3\a\xFB\x2\x2\x7F3\x7F5");
		sb.Append("\a\xFD\x2\x2\x7F4\x7F2\x3\x2\x2\x2\x7F4\x7F5\x3\x2\x2\x2\x7F5");
		sb.Append("\x7F6\x3\x2\x2\x2\x7F6\x7F7\a\x1F7\x2\x2\x7F7\xC5\x3\x2\x2\x2");
		sb.Append("\x7F8\x7F9\aT\x2\x2\x7F9\x805\x5\x2B8\x15D\x2\x7FA\x7FB\a\x1EB");
		sb.Append("\x2\x2\x7FB\x800\x5\xC8\x65\x2\x7FC\x7FD\a\x1F1\x2\x2\x7FD\x7FF");
		sb.Append("\x5\xC8\x65\x2\x7FE\x7FC\x3\x2\x2\x2\x7FF\x802\x3\x2\x2\x2\x800");
		sb.Append("\x7FE\x3\x2\x2\x2\x800\x801\x3\x2\x2\x2\x801\x803\x3\x2\x2\x2");
		sb.Append("\x802\x800\x3\x2\x2\x2\x803\x804\a\x1EC\x2\x2\x804\x806\x3\x2");
		sb.Append("\x2\x2\x805\x7FA\x3\x2\x2\x2\x805\x806\x3\x2\x2\x2\x806\x809");
		sb.Append("\x3\x2\x2\x2\x807\x808\a\x13A\x2\x2\x808\x80A\x5\x2D2\x16A\x2");
		sb.Append("\x809\x807\x3\x2\x2\x2\x809\x80A\x3\x2\x2\x2\x80A\x80D\x3\x2");
		sb.Append("\x2\x2\x80B\x80C\a\xBC\x2\x2\x80C\x80E\x5\x136\x9C\x2\x80D\x80B");
		sb.Append("\x3\x2\x2\x2\x80D\x80E\x3\x2\x2\x2\x80E\x80F\x3\x2\x2\x2\x80F");
		sb.Append("\x810\a\x1F7\x2\x2\x810\xC7\x3\x2\x2\x2\x811\x816\x5\x29A\x14E");
		sb.Append("\x2\x812\x814\a\xA6\x2\x2\x813\x812\x3\x2\x2\x2\x813\x814\x3");
		sb.Append("\x2\x2\x2\x814\x815\x3\x2\x2\x2\x815\x817\x5\x2D2\x16A\x2\x816");
		sb.Append("\x813\x3\x2\x2\x2\x816\x817\x3\x2\x2\x2\x817\x819\x3\x2\x2\x2");
		sb.Append("\x818\x81A\x5\xBE`\x2\x819\x818\x3\x2\x2\x2\x819\x81A\x3\x2");
		sb.Append("\x2\x2\x81A\xC9\x3\x2\x2\x2\x81B\x81C\x5\x2AC\x157\x2\x81C\x81D");
		sb.Append("\a\x81\x2\x2\x81D\x81E\a\x1F7\x2\x2\x81E\xCB\x3\x2\x2\x2\x81F");
		sb.Append("\x83E\a\x123\x2\x2\x820\x83F\a\x155\x2\x2\x821\x83F\a\x18\x2");
		sb.Append("\x2\x822\x823\a\x82\x2\x2\x823\x824\a\x1EB\x2\x2\x824\x825\x5");
		sb.Append("\x2AC\x157\x2\x825\x826\a\x1F1\x2\x2\x826\x827\x5\x2E6\x174");
		sb.Append("\x2\x827\x828\a\x1EC\x2\x2\x828\x83F\x3\x2\x2\x2\x829\x82A\a");
		sb.Append("\xB0\x2\x2\x82A\x82B\a\x1EB\x2\x2\x82B\x82C\x5\x2EA\x176\x2");
		sb.Append("\x82C\x82D\a\x1F1\x2\x2\x82D\x82E\x5\x1F4\xFB\x2\x82E\x82F\a");
		sb.Append("\x1EC\x2\x2\x82F\x83F\x3\x2\x2\x2\x830\x831\a\x137\x2\x2\x831");
		sb.Append("\x834\a\x1EB\x2\x2\x832\x835\x5\x2EA\x176\x2\x833\x835\a\x64");
		sb.Append("\x2\x2\x834\x832\x3\x2\x2\x2\x834\x833\x3\x2\x2\x2\x835\x838");
		sb.Append("\x3\x2\x2\x2\x836\x837\a\x1F1\x2\x2\x837\x839\x5\x2EA\x176\x2");
		sb.Append("\x838\x836\x3\x2\x2\x2\x839\x83A\x3\x2\x2\x2\x83A\x838\x3\x2");
		sb.Append("\x2\x2\x83A\x83B\x3\x2\x2\x2\x83B\x83C\x3\x2\x2\x2\x83C\x83D");
		sb.Append("\a\x1EC\x2\x2\x83D\x83F\x3\x2\x2\x2\x83E\x820\x3\x2\x2\x2\x83E");
		sb.Append("\x821\x3\x2\x2\x2\x83E\x822\x3\x2\x2\x2\x83E\x829\x3\x2\x2\x2");
		sb.Append("\x83E\x830\x3\x2\x2\x2\x83F\x840\x3\x2\x2\x2\x840\x841\a\x1F7");
		sb.Append("\x2\x2\x841\xCD\x3\x2\x2\x2\x842\x845\x5\xD0i\x2\x843\x845\x5");
		sb.Append("\xD4k\x2\x844\x842\x3\x2\x2\x2\x844\x843\x3\x2\x2\x2\x845\xCF");
		sb.Append("\x3\x2\x2\x2\x846\x847\a\x18D\x2\x2\x847\x848\x5\x2A8\x155\x2");
		sb.Append("\x848\x85B\a\xBC\x2\x2\x849\x84A\a\x12E\x2\x2\x84A\x84B\a\x1EB");
		sb.Append("\x2\x2\x84B\x850\x5\xD2j\x2\x84C\x84D\a\x1F1\x2\x2\x84D\x84F");
		sb.Append("\x5\xD2j\x2\x84E\x84C\x3\x2\x2\x2\x84F\x852\x3\x2\x2\x2\x850");
		sb.Append("\x84E\x3\x2\x2\x2\x850\x851\x3\x2\x2\x2\x851\x853\x3\x2\x2\x2");
		sb.Append("\x852\x850\x3\x2\x2\x2\x853\x854\a\x1EC\x2\x2\x854\x85C\x3\x2");
		sb.Append("\x2\x2\x855\x856\a\x12F\x2\x2\x856\x859\aT\x2\x2\x857\x858\a");
		sb.Append("\x13A\x2\x2\x858\x85A\x5\x2D2\x16A\x2\x859\x857\x3\x2\x2\x2");
		sb.Append("\x859\x85A\x3\x2\x2\x2\x85A\x85C\x3\x2\x2\x2\x85B\x849\x3\x2");
		sb.Append("\x2\x2\x85B\x855\x3\x2\x2\x2\x85C\x85D\x3\x2\x2\x2\x85D\x85E");
		sb.Append("\a\x1F7\x2\x2\x85E\xD1\x3\x2\x2\x2\x85F\x861\x5\x2C0\x161\x2");
		sb.Append("\x860\x862\x5\x2D2\x16A\x2\x861\x860\x3\x2\x2\x2\x861\x862\x3");
		sb.Append("\x2\x2\x2\x862\x865\x3\x2\x2\x2\x863\x864\a\xFB\x2\x2\x864\x866");
		sb.Append("\a\xFD\x2\x2\x865\x863\x3\x2\x2\x2\x865\x866\x3\x2\x2\x2\x866");
		sb.Append("\x868\x3\x2\x2\x2\x867\x869\x5\xBE`\x2\x868\x867\x3\x2\x2\x2");
		sb.Append("\x868\x869\x3\x2\x2\x2\x869\xD3\x3\x2\x2\x2\x86A\x86B\x5\x2BA");
		sb.Append("\x15E\x2\x86B\x86C\x5\x2A8\x155\x2\x86C\x86D\t\x17\x2\x2\x86D");
		sb.Append("\x86E\a\x1F7\x2\x2\x86E\xD5\x3\x2\x2\x2\x86F\x872\x5\xD8m\x2");
		sb.Append("\x870\x872\x5\xDEp\x2\x871\x86F\x3\x2\x2\x2\x871\x870\x3\x2");
		sb.Append("\x2\x2\x872\x873\x3\x2\x2\x2\x873\x874\a\x1F7\x2\x2\x874\xD7");
		sb.Append("\x3\x2\x2\x2\x875\x876\a\x18D\x2\x2\x876\x877\x5\x2A8\x155\x2");
		sb.Append("\x877\x883\a\xBC\x2\x2\x878\x879\a\x178\x2\x2\x879\x87A\a\x103");
		sb.Append("\x2\x2\x87A\x87C\x5\x2D2\x16A\x2\x87B\x87D\x5\xDAn\x2\x87C\x87B");
		sb.Append("\x3\x2\x2\x2\x87C\x87D\x3\x2\x2\x2\x87D\x880\x3\x2\x2\x2\x87E");
		sb.Append("\x87F\a\xFB\x2\x2\x87F\x881\a\xFD\x2\x2\x880\x87E\x3\x2\x2\x2");
		sb.Append("\x880\x881\x3\x2\x2\x2\x881\x884\x3\x2\x2\x2\x882\x884\x5\xDC");
		sb.Append("o\x2\x883\x878\x3\x2\x2\x2\x883\x882\x3\x2\x2\x2\x884\xD9\x3");
		sb.Append("\x2\x2\x2\x885\x888\a\xAC\x2\x2\x886\x888\a\xAB\x2\x2\x887\x885");
		sb.Append("\x3\x2\x2\x2\x887\x886\x3\x2\x2\x2\x888\x889\x3\x2\x2\x2\x889");
		sb.Append("\x88A\a(\x2\x2\x88A\x88B\x5\x2D2\x16A\x2\x88B\xDB\x3\x2\x2\x2");
		sb.Append("\x88C\x890\a\x1A1\x2\x2\x88D\x88E\a\x1A2\x2\x2\x88E\x890\a\xE");
		sb.Append("\x2\x2\x88F\x88C\x3\x2\x2\x2\x88F\x88D\x3\x2\x2\x2\x890\x891");
		sb.Append("\x3\x2\x2\x2\x891\x892\a\x1EB\x2\x2\x892\x893\x5\x1F4\xFB\x2");
		sb.Append("\x893\x894\a\x1EC\x2\x2\x894\x895\a\x103\x2\x2\x895\x898\x5");
		sb.Append("\x2D2\x16A\x2\x896\x897\a\xFB\x2\x2\x897\x899\a\xFD\x2\x2\x898");
		sb.Append("\x896\x3\x2\x2\x2\x898\x899\x3\x2\x2\x2\x899\xDD\x3\x2\x2\x2");
		sb.Append("\x89A\x89B\x5\x290\x149\x2\x89B\x89C\x5\x2D2\x16A\x2\x89C\xDF");
		sb.Append("\x3\x2\x2\x2\x89D\x89E\x5\xE4s\x2\x89E\x89F\t\x18\x2\x2\x89F");
		sb.Append("\x8A2\x3\x2\x2\x2\x8A0\x8A2\x5\xE2r\x2\x8A1\x89D\x3\x2\x2\x2");
		sb.Append("\x8A1\x8A0\x3\x2\x2\x2\x8A2\x8A3\x3\x2\x2\x2\x8A3\x8A1\x3\x2");
		sb.Append("\x2\x2\x8A3\x8A4\x3\x2\x2\x2\x8A4\xE1\x3\x2\x2\x2\x8A5\x8A6");
		sb.Append("\a\x1F9\x2\x2\x8A6\x8A7\a\x1F9\x2\x2\x8A7\x8A8\x5\x2A6\x154");
		sb.Append("\x2\x8A8\x8A9\a\x1FF\x2\x2\x8A9\x8AA\a\x1FF\x2\x2\x8AA\xE3\x3");
		sb.Append("\x2\x2\x2\x8AB\x8AC\aO\x2\x2\x8AC\x8C3\x5\x2\x2\x2\x8AD\x8AE");
		sb.Append("\a\n\x2\x2\x8AE\x8C3\x5\x2\x2\x2\x8AF\x8B0\a\x9C\x2\x2\x8B0");
		sb.Append("\x8C3\x5\x2\x2\x2\x8B1\x8B2\a\x18C\x2\x2\x8B2\x8C3\x5\x2\x2");
		sb.Append("\x2\x8B3\x8C3\x5\x10A\x86\x2\x8B4\x8C3\x5\x112\x8A\x2\x8B5\x8C3");
		sb.Append("\x5\xE6t\x2\x8B6\x8C3\x5\xE8u\x2\x8B7\x8C3\x5\xEAv\x2\x8B8\x8C3");
		sb.Append("\x5\xECw\x2\x8B9\x8C3\x5\xEEx\x2\x8BA\x8C3\x5\xF4{\x2\x8BB\x8C3");
		sb.Append("\x5\xF8}\x2\x8BC\x8C3\x5\x102\x82\x2\x8BD\x8C3\x5\x104\x83\x2");
		sb.Append("\x8BE\x8C3\x5\x106\x84\x2\x8BF\x8C3\x5\x228\x115\x2\x8C0\x8C3");
		sb.Append("\x5\x114\x8B\x2\x8C1\x8C3\x5\x108\x85\x2\x8C2\x8AB\x3\x2\x2");
		sb.Append("\x2\x8C2\x8AD\x3\x2\x2\x2\x8C2\x8AF\x3\x2\x2\x2\x8C2\x8B1\x3");
		sb.Append("\x2\x2\x2\x8C2\x8B3\x3\x2\x2\x2\x8C2\x8B4\x3\x2\x2\x2\x8C2\x8B5");
		sb.Append("\x3\x2\x2\x2\x8C2\x8B6\x3\x2\x2\x2\x8C2\x8B7\x3\x2\x2\x2\x8C2");
		sb.Append("\x8B8\x3\x2\x2\x2\x8C2\x8B9\x3\x2\x2\x2\x8C2\x8BA\x3\x2\x2\x2");
		sb.Append("\x8C2\x8BB\x3\x2\x2\x2\x8C2\x8BC\x3\x2\x2\x2\x8C2\x8BD\x3\x2");
		sb.Append("\x2\x2\x8C2\x8BE\x3\x2\x2\x2\x8C2\x8BF\x3\x2\x2\x2\x8C2\x8C0");
		sb.Append("\x3\x2\x2\x2\x8C2\x8C1\x3\x2\x2\x2\x8C3\xE5\x3\x2\x2\x2\x8C4");
		sb.Append("\x8C7\x5\x2DC\x16F\x2\x8C5\x8C7\x5\x2DA\x16E\x2\x8C6\x8C4\x3");
		sb.Append("\x2\x2\x2\x8C6\x8C5\x3\x2\x2\x2\x8C7\x8C8\x3\x2\x2\x2\x8C8\x8C9");
		sb.Append("\a\x1F4\x2\x2\x8C9\x8CA\x5\x1F4\xFB\x2\x8CA\xE7\x3\x2\x2\x2");
		sb.Append("\x8CB\x8CD\aI\x2\x2\x8CC\x8CE\x5\x2A6\x154\x2\x8CD\x8CC\x3\x2");
		sb.Append("\x2\x2\x8CD\x8CE\x3\x2\x2\x2\x8CE\x8D1\x3\x2\x2\x2\x8CF\x8D0");
		sb.Append("\a\x1A8\x2\x2\x8D0\x8D2\x5\x1F0\xF9\x2\x8D1\x8CF\x3\x2\x2\x2");
		sb.Append("\x8D1\x8D2\x3\x2\x2\x2\x8D2\xE9\x3\x2\x2\x2\x8D3\x8D5\a\x88");
		sb.Append("\x2\x2\x8D4\x8D6\x5\x2A6\x154\x2\x8D5\x8D4\x3\x2\x2\x2\x8D5");
		sb.Append("\x8D6\x3\x2\x2\x2\x8D6\x8D9\x3\x2\x2\x2\x8D7\x8D8\a\x1A8\x2");
		sb.Append("\x2\x8D8\x8DA\x5\x1F0\xF9\x2\x8D9\x8D7\x3\x2\x2\x2\x8D9\x8DA");
		sb.Append("\x3\x2\x2\x2\x8DA\xEB\x3\x2\x2\x2\x8DB\x8DC\a\x9B\x2\x2\x8DC");
		sb.Append("\x8DD\x5\x2A6\x154\x2\x8DD\xED\x3\x2\x2\x2\x8DE\x8DF\a\xA3\x2");
		sb.Append("\x2\x8DF\x8E0\x5\x1F0\xF9\x2\x8E0\x8E1\a\x17A\x2\x2\x8E1\x8E5");
		sb.Append("\x5\xE0q\x2\x8E2\x8E4\x5\xF0y\x2\x8E3\x8E2\x3\x2\x2\x2\x8E4");
		sb.Append("\x8E7\x3\x2\x2\x2\x8E5\x8E3\x3\x2\x2\x2\x8E5\x8E6\x3\x2\x2\x2");
		sb.Append("\x8E6\x8E9\x3\x2\x2\x2\x8E7\x8E5\x3\x2\x2\x2\x8E8\x8EA\x5\xF2");
		sb.Append("z\x2\x8E9\x8E8\x3\x2\x2\x2\x8E9\x8EA\x3\x2\x2\x2\x8EA\x8EB\x3");
		sb.Append("\x2\x2\x2\x8EB\x8EC\a{\x2\x2\x8EC\x8ED\a\xA3\x2\x2\x8ED\xEF");
		sb.Append("\x3\x2\x2\x2\x8EE\x8EF\aw\x2\x2\x8EF\x8F0\x5\x1F0\xF9\x2\x8F0");
		sb.Append("\x8F1\a\x17A\x2\x2\x8F1\x8F2\x5\xE0q\x2\x8F2\xF1\x3\x2\x2\x2");
		sb.Append("\x8F3\x8F4\av\x2\x2\x8F4\x8F5\x5\xE0q\x2\x8F5\xF3\x3\x2\x2\x2");
		sb.Append("\x8F6\x8F8\x5\x2A6\x154\x2\x8F7\x8F6\x3\x2\x2\x2\x8F7\x8F8\x3");
		sb.Append("\x2\x2\x2\x8F8\x8FD\x3\x2\x2\x2\x8F9\x8FA\a\x1AB\x2\x2\x8FA");
		sb.Append("\x8FE\x5\x1F0\xF9\x2\x8FB\x8FC\a\x95\x2\x2\x8FC\x8FE\x5\xF6");
		sb.Append("|\x2\x8FD\x8F9\x3\x2\x2\x2\x8FD\x8FB\x3\x2\x2\x2\x8FD\x8FE\x3");
		sb.Append("\x2\x2\x2\x8FE\x8FF\x3\x2\x2\x2\x8FF\x900\a\xD5\x2\x2\x900\x901");
		sb.Append("\x5\xE0q\x2\x901\x902\a{\x2\x2\x902\x904\a\xD5\x2\x2\x903\x905");
		sb.Append("\x5\x2A6\x154\x2\x904\x903\x3\x2\x2\x2\x904\x905\x3\x2\x2\x2");
		sb.Append("\x905\xF5\x3\x2\x2\x2\x906\x907\x5\x2B6\x15C\x2\x907\x909\a");
		sb.Append("\xA6\x2\x2\x908\x90A\a\x13D\x2\x2\x909\x908\x3\x2\x2\x2\x909");
		sb.Append("\x90A\x3\x2\x2\x2\x90A\x90B\x3\x2\x2\x2\x90B\x90C\x5\xFE\x80");
		sb.Append("\x2\x90C\x90D\a\x3\x2\x2\x90D\x90E\x5\x100\x81\x2\x90E\x91C");
		sb.Append("\x3\x2\x2\x2\x90F\x910\x5\x2BA\x15E\x2\x910\x919\a\xA6\x2\x2");
		sb.Append("\x911\x913\x5\x2B8\x15D\x2\x912\x914\x5\x1EE\xF8\x2\x913\x912");
		sb.Append("\x3\x2\x2\x2\x913\x914\x3\x2\x2\x2\x914\x91A\x3\x2\x2\x2\x915");
		sb.Append("\x916\a\x1EB\x2\x2\x916\x917\x5\x136\x9C\x2\x917\x918\a\x1EC");
		sb.Append("\x2\x2\x918\x91A\x3\x2\x2\x2\x919\x911\x3\x2\x2\x2\x919\x915");
		sb.Append("\x3\x2\x2\x2\x91A\x91C\x3\x2\x2\x2\x91B\x906\x3\x2\x2\x2\x91B");
		sb.Append("\x90F\x3\x2\x2\x2\x91C\xF7\x3\x2\x2\x2\x91D\x91E\a\x96\x2\x2");
		sb.Append("\x91E\x91F\x5\x2B6\x15C\x2\x91F\x920\a\xA6\x2\x2\x920\x921\x5");
		sb.Append("\xFA~\x2\x921\x924\x5\x114\x8B\x2\x922\x923\a\x147\x2\x2\x923");
		sb.Append("\x925\a\x83\x2\x2\x924\x922\x3\x2\x2\x2\x924\x925\x3\x2\x2\x2");
		sb.Append("\x925\xF9\x3\x2\x2\x2\x926\x927\x5\xFE\x80\x2\x927\x928\a\x3");
		sb.Append("\x2\x2\x928\x929\x5\x100\x81\x2\x929\x934\x3\x2\x2\x2\x92A\x92B");
		sb.Append("\a\xAE\x2\x2\x92B\x92C\a\x103\x2\x2\x92C\x92E\x5\x2BC\x15F\x2");
		sb.Append("\x92D\x92F\x5\xFC\x7F\x2\x92E\x92D\x3\x2\x2\x2\x92E\x92F\x3");
		sb.Append("\x2\x2\x2\x92F\x934\x3\x2\x2\x2\x930\x931\a\x19D\x2\x2\x931");
		sb.Append("\x932\a\x103\x2\x2\x932\x934\x5\x2B6\x15C\x2\x933\x926\x3\x2");
		sb.Append("\x2\x2\x933\x92A\x3\x2\x2\x2\x933\x930\x3\x2\x2\x2\x934\xFB");
		sb.Append("\x3\x2\x2\x2\x935\x936\a\x1C\x2\x2\x936\x937\x5\xFE\x80\x2\x937");
		sb.Append("\x938\a\f\x2\x2\x938\x939\x5\x100\x81\x2\x939\xFD\x3\x2\x2\x2");
		sb.Append("\x93A\x93B\x5\x20E\x108\x2\x93B\xFF\x3\x2\x2\x2\x93C\x93D\x5");
		sb.Append("\x20E\x108\x2\x93D\x101\x3\x2\x2\x2\x93E\x93F\a\xFD\x2\x2\x93F");
		sb.Append("\x103\x3\x2\x2\x2\x940\x942\a\x129\x2\x2\x941\x943\x5\x2AC\x157");
		sb.Append("\x2\x942\x941\x3\x2\x2\x2\x942\x943\x3\x2\x2\x2\x943\x105\x3");
		sb.Append("\x2\x2\x2\x944\x946\a\x13A\x2\x2\x945\x947\x5\x1F0\xF9\x2\x946");
		sb.Append("\x945\x3\x2\x2\x2\x946\x947\x3\x2\x2\x2\x947\x107\x3\x2\x2\x2");
		sb.Append("\x948\x94A\a,\x2\x2\x949\x948\x3\x2\x2\x2\x949\x94A\x3\x2\x2");
		sb.Append("\x2\x94A\x94B\x3\x2\x2\x2\x94B\x94D\x5\x294\x14B\x2\x94C\x94E");
		sb.Append("\x5\x2C8\x165\x2\x94D\x94C\x3\x2\x2\x2\x94D\x94E\x3\x2\x2\x2");
		sb.Append("\x94E\x109\x3\x2\x2\x2\x94F\x950\a\x1B\x2\x2\x950\x952\x5\xE0");
		sb.Append("q\x2\x951\x953\x5\x10C\x87\x2\x952\x951\x3\x2\x2\x2\x952\x953");
		sb.Append("\x3\x2\x2\x2\x953\x954\x3\x2\x2\x2\x954\x956\a{\x2\x2\x955\x957");
		sb.Append("\x5\x2A6\x154\x2\x956\x955\x3\x2\x2\x2\x956\x957\x3\x2\x2\x2");
		sb.Append("\x957\x10B\x3\x2\x2\x2\x958\x95A\a\x81\x2\x2\x959\x95B\x5\x10E");
		sb.Append("\x88\x2\x95A\x959\x3\x2\x2\x2\x95B\x95C\x3\x2\x2\x2\x95C\x95A");
		sb.Append("\x3\x2\x2\x2\x95C\x95D\x3\x2\x2\x2\x95D\x10D\x3\x2\x2\x2\x95E");
		sb.Append("\x95F\a\x1A8\x2\x2\x95F\x964\x5\x2AC\x157\x2\x960\x961\a\x10B");
		sb.Append("\x2\x2\x961\x963\x5\x2AC\x157\x2\x962\x960\x3\x2\x2\x2\x963");
		sb.Append("\x966\x3\x2\x2\x2\x964\x962\x3\x2\x2\x2\x964\x965\x3\x2\x2\x2");
		sb.Append("\x965\x967\x3\x2\x2\x2\x966\x964\x3\x2\x2\x2\x967\x968\a\x17A");
		sb.Append("\x2\x2\x968\x969\x5\xE0q\x2\x969\x10F\x3\x2\x2\x2\x96A\x96C");
		sb.Append("\a\x61\x2\x2\x96B\x96A\x3\x2\x2\x2\x96B\x96C\x3\x2\x2\x2\x96C");
		sb.Append("\x96E\x3\x2\x2\x2\x96D\x96F\x5\xC0\x61\x2\x96E\x96D\x3\x2\x2");
		sb.Append("\x2\x96F\x970\x3\x2\x2\x2\x970\x96E\x3\x2\x2\x2\x970\x971\x3");
		sb.Append("\x2\x2\x2\x971\x973\x3\x2\x2\x2\x972\x96B\x3\x2\x2\x2\x972\x973");
		sb.Append("\x3\x2\x2\x2\x973\x974\x3\x2\x2\x2\x974\x975\x5\x10A\x86\x2");
		sb.Append("\x975\x111\x3\x2\x2\x2\x976\x978\a\x61\x2\x2\x977\x976\x3\x2");
		sb.Append("\x2\x2\x977\x978\x3\x2\x2\x2\x978\x97A\x3\x2\x2\x2\x979\x97B");
		sb.Append("\x5\xC0\x61\x2\x97A\x979\x3\x2\x2\x2\x97B\x97C\x3\x2\x2\x2\x97C");
		sb.Append("\x97A\x3\x2\x2\x2\x97C\x97D\x3\x2\x2\x2\x97D\x97E\x3\x2\x2\x2");
		sb.Append("\x97E\x97F\x5\x10A\x86\x2\x97F\x113\x3\x2\x2\x2\x980\x985\x5");
		sb.Append("\x116\x8C\x2\x981\x985\x5\x11A\x8E\x2\x982\x985\x5\x11C\x8F");
		sb.Append("\x2\x983\x985\x5\x126\x94\x2\x984\x980\x3\x2\x2\x2\x984\x981");
		sb.Append("\x3\x2\x2\x2\x984\x982\x3\x2\x2\x2\x984\x983\x3\x2\x2\x2\x985");
		sb.Append("\x115\x3\x2\x2\x2\x986\x987\a\x86\x2\x2\x987\x988\a\xA5\x2\x2");
		sb.Append("\x988\x992\x5\x1F4\xFB\x2\x989\x98B\x5\x284\x143\x2\x98A\x98C");
		sb.Append("\x5\x24C\x127\x2\x98B\x98A\x3\x2\x2\x2\x98B\x98C\x3\x2\x2\x2");
		sb.Append("\x98C\x993\x3\x2\x2\x2\x98D\x98F\x5\x24C\x127\x2\x98E\x990\x5");
		sb.Append("\x118\x8D\x2\x98F\x98E\x3\x2\x2\x2\x98F\x990\x3\x2\x2\x2\x990");
		sb.Append("\x993\x3\x2\x2\x2\x991\x993\x5\x118\x8D\x2\x992\x989\x3\x2\x2");
		sb.Append("\x2\x992\x98D\x3\x2\x2\x2\x992\x991\x3\x2\x2\x2\x992\x993\x3");
		sb.Append("\x2\x2\x2\x993\x117\x3\x2\x2\x2\x994\x995\t\x19\x2\x2\x995\x996");
		sb.Append("\x5\x284\x143\x2\x996\x119\x3\x2\x2\x2\x997\x99F\x5\x1C4\xE3");
		sb.Append("\x2\x998\x99F\x5\x1D0\xE9\x2\x999\x99F\x5\x136\x9C\x2\x99A\x99F");
		sb.Append("\x5\x1AA\xD6\x2\x99B\x99F\x5\x1B0\xD9\x2\x99C\x99F\x5\x1B2\xDA");
		sb.Append("\x2\x99D\x99F\x5\x134\x9B\x2\x99E\x997\x3\x2\x2\x2\x99E\x998");
		sb.Append("\x3\x2\x2\x2\x99E\x999\x3\x2\x2\x2\x99E\x99A\x3\x2\x2\x2\x99E");
		sb.Append("\x99B\x3\x2\x2\x2\x99E\x99C\x3\x2\x2\x2\x99E\x99D\x3\x2\x2\x2");
		sb.Append("\x99F\x11B\x3\x2\x2\x2\x9A0\x9A5\x5\x11E\x90\x2\x9A1\x9A5\x5");
		sb.Append("\x120\x91\x2\x9A2\x9A5\x5\x122\x92\x2\x9A3\x9A5\x5\x124\x93");
		sb.Append("\x2\x9A4\x9A0\x3\x2\x2\x2\x9A4\x9A1\x3\x2\x2\x2\x9A4\x9A2\x3");
		sb.Append("\x2\x2\x2\x9A4\x9A3\x3\x2\x2\x2\x9A5\x11D\x3\x2\x2\x2\x9A6\x9A7");
		sb.Append("\a\x37\x2\x2\x9A7\x9A8\x5\x2B8\x15D\x2\x9A8\x11F\x3\x2\x2\x2");
		sb.Append("\x9A9\x9AA\a\x109\x2\x2\x9AA\x9AC\x5\x2B8\x15D\x2\x9AB\x9AD");
		sb.Append("\x5\x1EE\xF8\x2\x9AC\x9AB\x3\x2\x2\x2\x9AC\x9AD\x3\x2\x2\x2");
		sb.Append("\x9AD\x121\x3\x2\x2\x2\x9AE\x9AF\a\x8E\x2\x2\x9AF\x9C4\x5\x2B8");
		sb.Append("\x15D\x2\x9B0\x9B1\a\xBA\x2\x2\x9B1\x9B6\x5\x2B4\x15B\x2\x9B2");
		sb.Append("\x9B3\a\x1F1\x2\x2\x9B3\x9B5\x5\x2B4\x15B\x2\x9B4\x9B2\x3\x2");
		sb.Append("\x2\x2\x9B5\x9B8\x3\x2\x2\x2\x9B6\x9B4\x3\x2\x2\x2\x9B6\x9B7");
		sb.Append("\x3\x2\x2\x2\x9B7\x9C5\x3\x2\x2\x2\x9B8\x9B6\x3\x2\x2\x2\x9B9");
		sb.Append("\x9BA\a\'\x2\x2\x9BA\x9BB\a\x39\x2\x2\x9BB\x9BC\a\xBA\x2\x2");
		sb.Append("\x9BC\x9C1\x5\x2B4\x15B\x2\x9BD\x9BE\a\x1F1\x2\x2\x9BE\x9C0");
		sb.Append("\x5\x2B4\x15B\x2\x9BF\x9BD\x3\x2\x2\x2\x9C0\x9C3\x3\x2\x2\x2");
		sb.Append("\x9C1\x9BF\x3\x2\x2\x2\x9C1\x9C2\x3\x2\x2\x2\x9C2\x9C5\x3\x2");
		sb.Append("\x2\x2\x9C3\x9C1\x3\x2\x2\x2\x9C4\x9B0\x3\x2\x2\x2\x9C4\x9B9");
		sb.Append("\x3\x2\x2\x2\x9C5\x123\x3\x2\x2\x2\x9C6\x9C7\a\x109\x2\x2\x9C7");
		sb.Append("\x9C8\x5\x2B4\x15B\x2\x9C8\x9CB\a\x95\x2\x2\x9C9\x9CC\x5\x136");
		sb.Append("\x9C\x2\x9CA\x9CC\x5\x1F4\xFB\x2\x9CB\x9C9\x3\x2\x2\x2\x9CB");
		sb.Append("\x9CA\x3\x2\x2\x2\x9CC\x9CE\x3\x2\x2\x2\x9CD\x9CF\x5\x24C\x127");
		sb.Append("\x2\x9CE\x9CD\x3\x2\x2\x2\x9CE\x9CF\x3\x2\x2\x2\x9CF\x125\x3");
		sb.Append("\x2\x2\x2\x9D0\x9D6\x5\x128\x95\x2\x9D1\x9D6\x5\x12A\x96\x2");
		sb.Append("\x9D2\x9D6\x5\x12C\x97\x2\x9D3\x9D6\x5\x130\x99\x2\x9D4\x9D6");
		sb.Append("\x5\x132\x9A\x2\x9D5\x9D0\x3\x2\x2\x2\x9D5\x9D1\x3\x2\x2\x2");
		sb.Append("\x9D5\x9D2\x3\x2\x2\x2\x9D5\x9D3\x3\x2\x2\x2\x9D5\x9D4\x3\x2");
		sb.Append("\x2\x2\x9D6\x127\x3\x2\x2\x2\x9D7\x9D8\a\x158\x2\x2\x9D8\x9E6");
		sb.Append("\a\x186\x2\x2\x9D9\x9DA\a\x12C\x2\x2\x9DA\x9E7\t\x1A\x2\x2\x9DB");
		sb.Append("\x9DC\a\xBD\x2\x2\x9DC\x9E0\a\xC7\x2\x2\x9DD\x9E1\a\x154\x2");
		sb.Append("\x2\x9DE\x9DF\a\x12C\x2\x2\x9DF\x9E1\a=\x2\x2\x9E0\x9DD\x3\x2");
		sb.Append("\x2\x2\x9E0\x9DE\x3\x2\x2\x2\x9E1\x9E7\x3\x2\x2\x2\x9E2\x9E3");
		sb.Append("\a\x199\x2\x2\x9E3\x9E4\a\x140\x2\x2\x9E4\x9E5\a\x14F\x2\x2");
		sb.Append("\x9E5\x9E7\x5\x28E\x148\x2\x9E6\x9D9\x3\x2\x2\x2\x9E6\x9DB\x3");
		sb.Append("\x2\x2\x2\x9E6\x9E2\x3\x2\x2\x2\x9E6\x9E7\x3\x2\x2\x2\x9E7\x9EA");
		sb.Append("\x3\x2\x2\x2\x9E8\x9E9\a\xE6\x2\x2\x9E9\x9EB\x5\x2E8\x175\x2");
		sb.Append("\x9EA\x9E8\x3\x2\x2\x2\x9EA\x9EB\x3\x2\x2\x2\x9EB\x129\x3\x2");
		sb.Append("\x2\x2\x9EC\x9ED\a\x158\x2\x2\x9ED\x9F7\t\x1B\x2\x2\x9EE\x9F8");
		sb.Append("\a\t\x2\x2\x9EF\x9F4\x5\x2A4\x153\x2\x9F0\x9F1\a\x1F1\x2\x2");
		sb.Append("\x9F1\x9F3\x5\x2A4\x153\x2\x9F2\x9F0\x3\x2\x2\x2\x9F3\x9F6\x3");
		sb.Append("\x2\x2\x2\x9F4\x9F2\x3\x2\x2\x2\x9F4\x9F5\x3\x2\x2\x2\x9F5\x9F8");
		sb.Append("\x3\x2\x2\x2\x9F6\x9F4\x3\x2\x2\x2\x9F7\x9EE\x3\x2\x2\x2\x9F7");
		sb.Append("\x9EF\x3\x2\x2\x2\x9F8\x9F9\x3\x2\x2\x2\x9F9\x9FA\t\x1C\x2\x2");
		sb.Append("\x9FA\x12B\x3\x2\x2\x2\x9FB\x9FD\a<\x2\x2\x9FC\x9FE\a\x1AE\x2");
		sb.Append("\x2\x9FD\x9FC\x3\x2\x2\x2\x9FD\x9FE\x3\x2\x2\x2\x9FE\xA0C\x3");
		sb.Append("\x2\x2\x2\x9FF\xA00\a;\x2\x2\xA00\xA0D\x5\x1F4\xFB\x2\xA01\xA0A");
		sb.Append("\a\x97\x2\x2\xA02\xA03\aK\x2\x2\xA03\xA0B\x5\x1F4\xFB\x2\xA04");
		sb.Append("\xA0B\aL\x2\x2\xA05\xA08\x5\x1F4\xFB\x2\xA06\xA07\a\x1F1\x2");
		sb.Append("\x2\xA07\xA09\x5\x1F4\xFB\x2\xA08\xA06\x3\x2\x2\x2\xA08\xA09");
		sb.Append("\x3\x2\x2\x2\xA09\xA0B\x3\x2\x2\x2\xA0A\xA02\x3\x2\x2\x2\xA0A");
		sb.Append("\xA04\x3\x2\x2\x2\xA0A\xA05\x3\x2\x2\x2\xA0B\xA0D\x3\x2\x2\x2");
		sb.Append("\xA0C\x9FF\x3\x2\x2\x2\xA0C\xA01\x3\x2\x2\x2\xA0C\xA0D\x3\x2");
		sb.Append("\x2\x2\xA0D\xA0F\x3\x2\x2\x2\xA0E\xA10\x5\x12E\x98\x2\xA0F\xA0E");
		sb.Append("\x3\x2\x2\x2\xA0F\xA10\x3\x2\x2\x2\xA10\x12D\x3\x2\x2\x2\xA11");
		sb.Append("\xA13\a\x1AF\x2\x2\xA12\xA14\t\x1D\x2\x2\xA13\xA12\x3\x2\x2");
		sb.Append("\x2\xA13\xA14\x3\x2\x2\x2\xA14\xA16\x3\x2\x2\x2\xA15\xA17\t");
		sb.Append("\x1E\x2\x2\xA16\xA15\x3\x2\x2\x2\xA16\xA17\x3\x2\x2\x2\xA17");
		sb.Append("\x12F\x3\x2\x2\x2\xA18\xA1A\a\x140\x2\x2\xA19\xA1B\a\x1AE\x2");
		sb.Append("\x2\xA1A\xA19\x3\x2\x2\x2\xA1A\xA1B\x3\x2\x2\x2\xA1B\xA23\x3");
		sb.Append("\x2\x2\x2\xA1C\xA1E\a\x184\x2\x2\xA1D\xA1F\a\x148\x2\x2\xA1E");
		sb.Append("\xA1D\x3\x2\x2\x2\xA1E\xA1F\x3\x2\x2\x2\xA1F\xA20\x3\x2\x2\x2");
		sb.Append("\xA20\xA24\x5\x28C\x147\x2\xA21\xA22\a\x97\x2\x2\xA22\xA24\x5");
		sb.Append("\x2E8\x175\x2\xA23\xA1C\x3\x2\x2\x2\xA23\xA21\x3\x2\x2\x2\xA23");
		sb.Append("\xA24\x3\x2\x2\x2\xA24\x131\x3\x2\x2\x2\xA25\xA26\a\x148\x2");
		sb.Append("\x2\xA26\xA27\x5\x28C\x147\x2\xA27\x133\x3\x2\x2\x2\xA28\xA29");
		sb.Append("\a\x89\x2\x2\xA29\xA2E\a\x11F\x2\x2\xA2A\xA2B\a\x158\x2\x2\xA2B");
		sb.Append("\xA2C\a\x16E\x2\x2\xA2C\xA2D\a\x202\x2\x2\xA2D\xA2F\x5\x2E8");
		sb.Append("\x175\x2\xA2E\xA2A\x3\x2\x2\x2\xA2E\xA2F\x3\x2\x2\x2\xA2F\xA32");
		sb.Append("\x3\x2\x2\x2\xA30\xA31\a\xBA\x2\x2\xA31\xA33\x5\x2C2\x162\x2");
		sb.Append("\xA32\xA30\x3\x2\x2\x2\xA32\xA33\x3\x2\x2\x2\xA33\xA34\x3\x2");
		sb.Append("\x2\x2\xA34\xA3A\a\x95\x2\x2\xA35\xA3B\x5\x136\x9C\x2\xA36\xA3B");
		sb.Append("\x5\x1AA\xD6\x2\xA37\xA3B\x5\x1B0\xD9\x2\xA38\xA3B\x5\x1B2\xDA");
		sb.Append("\x2\xA39\xA3B\x5\x1C4\xE3\x2\xA3A\xA35\x3\x2\x2\x2\xA3A\xA36");
		sb.Append("\x3\x2\x2\x2\xA3A\xA37\x3\x2\x2\x2\xA3A\xA38\x3\x2\x2\x2\xA3A");
		sb.Append("\xA39\x3\x2\x2\x2\xA3B\x135\x3\x2\x2\x2\xA3C\xA3E\x5\x138\x9D");
		sb.Append("\x2\xA3D\xA3C\x3\x2\x2\x2\xA3D\xA3E\x3\x2\x2\x2\xA3E\xA3F\x3");
		sb.Append("\x2\x2\x2\xA3F\xA44\x5\x140\xA1\x2\xA40\xA43\x5\x1A4\xD3\x2");
		sb.Append("\xA41\xA43\x5\x1A0\xD1\x2\xA42\xA40\x3\x2\x2\x2\xA42\xA41\x3");
		sb.Append("\x2\x2\x2\xA43\xA46\x3\x2\x2\x2\xA44\xA42\x3\x2\x2\x2\xA44\xA45");
		sb.Append("\x3\x2\x2\x2\xA45\x137\x3\x2\x2\x2\xA46\xA44\x3\x2\x2\x2\xA47");
		sb.Append("\xA48\a\x1AC\x2\x2\xA48\xA4D\x5\x13A\x9E\x2\xA49\xA4A\a\x1F1");
		sb.Append("\x2\x2\xA4A\xA4C\x5\x13A\x9E\x2\xA4B\xA49\x3\x2\x2\x2\xA4C\xA4F");
		sb.Append("\x3\x2\x2\x2\xA4D\xA4B\x3\x2\x2\x2\xA4D\xA4E\x3\x2\x2\x2\xA4E");
		sb.Append("\x139\x3\x2\x2\x2\xA4F\xA4D\x3\x2\x2\x2\xA50\xA5C\x5\x2A2\x152");
		sb.Append("\x2\xA51\xA52\a\x1EB\x2\x2\xA52\xA57\x5\x2C0\x161\x2\xA53\xA54");
		sb.Append("\a\x1F1\x2\x2\xA54\xA56\x5\x2C0\x161\x2\xA55\xA53\x3\x2\x2\x2");
		sb.Append("\xA56\xA59\x3\x2\x2\x2\xA57\xA55\x3\x2\x2\x2\xA57\xA58\x3\x2");
		sb.Append("\x2\x2\xA58\xA5A\x3\x2\x2\x2\xA59\xA57\x3\x2\x2\x2\xA5A\xA5B");
		sb.Append("\a\x1EC\x2\x2\xA5B\xA5D\x3\x2\x2\x2\xA5C\xA51\x3\x2\x2\x2\xA5C");
		sb.Append("\xA5D\x3\x2\x2\x2\xA5D\xA5E\x3\x2\x2\x2\xA5E\xA5F\a\xF\x2\x2");
		sb.Append("\xA5F\xA60\a\x1EB\x2\x2\xA60\xA62\x5\x140\xA1\x2\xA61\xA63\x5");
		sb.Append("\x1A0\xD1\x2\xA62\xA61\x3\x2\x2\x2\xA62\xA63\x3\x2\x2\x2\xA63");
		sb.Append("\xA64\x3\x2\x2\x2\xA64\xA66\a\x1EC\x2\x2\xA65\xA67\x5\x13C\x9F");
		sb.Append("\x2\xA66\xA65\x3\x2\x2\x2\xA66\xA67\x3\x2\x2\x2\xA67\xA69\x3");
		sb.Append("\x2\x2\x2\xA68\xA6A\x5\x13E\xA0\x2\xA69\xA68\x3\x2\x2\x2\xA69");
		sb.Append("\xA6A\x3\x2\x2\x2\xA6A\x13B\x3\x2\x2\x2\xA6B\xA6C\a\x14C\x2");
		sb.Append("\x2\xA6C\xA6D\t\x1F\x2\x2\xA6D\xA6E\a\x90\x2\x2\xA6E\xA6F\a");
		sb.Append("(\x2\x2\xA6F\xA71\x5\x2C0\x161\x2\xA70\xA72\a\x10\x2\x2\xA71");
		sb.Append("\xA70\x3\x2\x2\x2\xA71\xA72\x3\x2\x2\x2\xA72\xA74\x3\x2\x2\x2");
		sb.Append("\xA73\xA75\aj\x2\x2\xA74\xA73\x3\x2\x2\x2\xA74\xA75\x3\x2\x2");
		sb.Append("\x2\xA75\xA78\x3\x2\x2\x2\xA76\xA77\a\xFE\x2\x2\xA77\xA79\a");
		sb.Append("\x90\x2\x2\xA78\xA76\x3\x2\x2\x2\xA78\xA79\x3\x2\x2\x2\xA79");
		sb.Append("\xA7C\x3\x2\x2\x2\xA7A\xA7B\a\xFE\x2\x2\xA7B\xA7D\a\xC3\x2\x2");
		sb.Append("\xA7C\xA7A\x3\x2\x2\x2\xA7C\xA7D\x3\x2\x2\x2\xA7D\xA90\x3\x2");
		sb.Append("\x2\x2\xA7E\xA7F\a\x1F1\x2\x2\xA7F\xA81\x5\x2C0\x161\x2\xA80");
		sb.Append("\xA82\a\x10\x2\x2\xA81\xA80\x3\x2\x2\x2\xA81\xA82\x3\x2\x2\x2");
		sb.Append("\xA82\xA84\x3\x2\x2\x2\xA83\xA85\aj\x2\x2\xA84\xA83\x3\x2\x2");
		sb.Append("\x2\xA84\xA85\x3\x2\x2\x2\xA85\xA88\x3\x2\x2\x2\xA86\xA87\a");
		sb.Append("\xFE\x2\x2\xA87\xA89\a\x90\x2\x2\xA88\xA86\x3\x2\x2\x2\xA88");
		sb.Append("\xA89\x3\x2\x2\x2\xA89\xA8C\x3\x2\x2\x2\xA8A\xA8B\a\xFE\x2\x2");
		sb.Append("\xA8B\xA8D\a\xC3\x2\x2\xA8C\xA8A\x3\x2\x2\x2\xA8C\xA8D\x3\x2");
		sb.Append("\x2\x2\xA8D\xA8F\x3\x2\x2\x2\xA8E\xA7E\x3\x2\x2\x2\xA8F\xA92");
		sb.Append("\x3\x2\x2\x2\xA90\xA8E\x3\x2\x2\x2\xA90\xA91\x3\x2\x2\x2\xA91");
		sb.Append("\xA93\x3\x2\x2\x2\xA92\xA90\x3\x2\x2\x2\xA93\xA94\a\x158\x2");
		sb.Append("\x2\xA94\xA95\x5\x2C0\x161\x2\xA95\x13D\x3\x2\x2\x2\xA96\xA97");
		sb.Append("\aV\x2\x2\xA97\xA9C\x5\x2C0\x161\x2\xA98\xA99\a\x1F1\x2\x2\xA99");
		sb.Append("\xA9B\x5\x2C0\x161\x2\xA9A\xA98\x3\x2\x2\x2\xA9B\xA9E\x3\x2");
		sb.Append("\x2\x2\xA9C\xA9A\x3\x2\x2\x2\xA9C\xA9D\x3\x2\x2\x2\xA9D\xA9F");
		sb.Append("\x3\x2\x2\x2\xA9E\xA9C\x3\x2\x2\x2\xA9F\xAA0\a\x158\x2\x2\xAA0");
		sb.Append("\xAA1\x5\x2C0\x161\x2\xAA1\xAA2\a\x184\x2\x2\xAA2\xAA3\x5\x1F4");
		sb.Append("\xFB\x2\xAA3\xAA4\a\x64\x2\x2\xAA4\xAA5\x5\x1F4\xFB\x2\xAA5");
		sb.Append("\x13F\x3\x2\x2\x2\xAA6\xAAA\x5\x144\xA3\x2\xAA7\xAA9\x5\x142");
		sb.Append("\xA2\x2\xAA8\xAA7\x3\x2\x2\x2\xAA9\xAAC\x3\x2\x2\x2\xAAA\xAA8");
		sb.Append("\x3\x2\x2\x2\xAAA\xAAB\x3\x2\x2\x2\xAAB\x141\x3\x2\x2\x2\xAAC");
		sb.Append("\xAAA\x3\x2\x2\x2\xAAD\xAAF\a\x190\x2\x2\xAAE\xAB0\a\t\x2\x2");
		sb.Append("\xAAF\xAAE\x3\x2\x2\x2\xAAF\xAB0\x3\x2\x2\x2\xAB0\xAB4\x3\x2");
		sb.Append("\x2\x2\xAB1\xAB4\a\xB8\x2\x2\xAB2\xAB4\a\xDD\x2\x2\xAB3\xAAD");
		sb.Append("\x3\x2\x2\x2\xAB3\xAB1\x3\x2\x2\x2\xAB3\xAB2\x3\x2\x2\x2\xAB4");
		sb.Append("\xAB5\x3\x2\x2\x2\xAB5\xAB6\x5\x144\xA3\x2\xAB6\x143\x3\x2\x2");
		sb.Append("\x2\xAB7\xABD\x5\x146\xA4\x2\xAB8\xAB9\a\x1EB\x2\x2\xAB9\xABA");
		sb.Append("\x5\x140\xA1\x2\xABA\xABB\a\x1EC\x2\x2\xABB\xABD\x3\x2\x2\x2");
		sb.Append("\xABC\xAB7\x3\x2\x2\x2\xABC\xAB8\x3\x2\x2\x2\xABD\x145\x3\x2");
		sb.Append("\x2\x2\xABE\xAC0\a\x150\x2\x2\xABF\xAC1\t \x2\x2\xAC0\xABF\x3");
		sb.Append("\x2\x2\x2\xAC0\xAC1\x3\x2\x2\x2\xAC1\xACB\x3\x2\x2\x2\xAC2\xACC");
		sb.Append("\a\x1EE\x2\x2\xAC3\xAC8\x5\x148\xA5\x2\xAC4\xAC5\a\x1F1\x2\x2");
		sb.Append("\xAC5\xAC7\x5\x148\xA5\x2\xAC6\xAC4\x3\x2\x2\x2\xAC7\xACA\x3");
		sb.Append("\x2\x2\x2\xAC8\xAC6\x3\x2\x2\x2\xAC8\xAC9\x3\x2\x2\x2\xAC9\xACC");
		sb.Append("\x3\x2\x2\x2\xACA\xAC8\x3\x2\x2\x2\xACB\xAC2\x3\x2\x2\x2\xACB");
		sb.Append("\xAC3\x3\x2\x2\x2\xACC\xACE\x3\x2\x2\x2\xACD\xACF\x5\x284\x143");
		sb.Append("\x2\xACE\xACD\x3\x2\x2\x2\xACE\xACF\x3\x2\x2\x2\xACF\xAD0\x3");
		sb.Append("\x2\x2\x2\xAD0\xAD2\x5\x14A\xA6\x2\xAD1\xAD3\x5\x280\x141\x2");
		sb.Append("\xAD2\xAD1\x3\x2\x2\x2\xAD2\xAD3\x3\x2\x2\x2\xAD3\xAD5\x3\x2");
		sb.Append("\x2\x2\xAD4\xAD6\x5\x172\xBA\x2\xAD5\xAD4\x3\x2\x2\x2\xAD5\xAD6");
		sb.Append("\x3\x2\x2\x2\xAD6\xAD8\x3\x2\x2\x2\xAD7\xAD9\x5\x176\xBC\x2");
		sb.Append("\xAD8\xAD7\x3\x2\x2\x2\xAD8\xAD9\x3\x2\x2\x2\xAD9\xADB\x3\x2");
		sb.Append("\x2\x2\xADA\xADC\x5\x182\xC2\x2\xADB\xADA\x3\x2\x2\x2\xADB\xADC");
		sb.Append("\x3\x2\x2\x2\xADC\x147\x3\x2\x2\x2\xADD\xADF\x5\x14C\xA7\x2");
		sb.Append("\xADE\xAE0\x5\x27A\x13E\x2\xADF\xADE\x3\x2\x2\x2\xADF\xAE0\x3");
		sb.Append("\x2\x2\x2\xAE0\x149\x3\x2\x2\x2\xAE1\xAE2\a\x98\x2\x2\xAE2\xAE3");
		sb.Append("\x5\x14E\xA8\x2\xAE3\x14B\x3\x2\x2\x2\xAE4\xAE5\x5\x2C2\x162");
		sb.Append("\x2\xAE5\xAE6\a\x1E4\x2\x2\xAE6\xAE7\a\x1EE\x2\x2\xAE7\xAEA");
		sb.Append("\x3\x2\x2\x2\xAE8\xAEA\x5\x1F4\xFB\x2\xAE9\xAE4\x3\x2\x2\x2");
		sb.Append("\xAE9\xAE8\x3\x2\x2\x2\xAEA\x14D\x3\x2\x2\x2\xAEB\xAF0\x5\x150");
		sb.Append("\xA9\x2\xAEC\xAED\a\x1F1\x2\x2\xAED\xAEF\x5\x150\xA9\x2\xAEE");
		sb.Append("\xAEC\x3\x2\x2\x2\xAEF\xAF2\x3\x2\x2\x2\xAF0\xAEE\x3\x2\x2\x2");
		sb.Append("\xAF0\xAF1\x3\x2\x2\x2\xAF1\x14F\x3\x2\x2\x2\xAF2\xAF0\x3\x2");
		sb.Append("\x2\x2\xAF3\xAF7\x5\x152\xAA\x2\xAF4\xAF6\x5\x154\xAB\x2\xAF5");
		sb.Append("\xAF4\x3\x2\x2\x2\xAF6\xAF9\x3\x2\x2\x2\xAF7\xAF5\x3\x2\x2\x2");
		sb.Append("\xAF7\xAF8\x3\x2\x2\x2\xAF8\xAFC\x3\x2\x2\x2\xAF9\xAF7\x3\x2");
		sb.Append("\x2\x2\xAFA\xAFD\x5\x160\xB1\x2\xAFB\xAFD\x5\x16C\xB7\x2\xAFC");
		sb.Append("\xAFA\x3\x2\x2\x2\xAFC\xAFB\x3\x2\x2\x2\xAFC\xAFD\x3\x2\x2\x2");
		sb.Append("\xAFD\x151\x3\x2\x2\x2\xAFE\xB01\x5\x1E2\xF2\x2\xAFF\xB02\x5");
		sb.Append("\x160\xB1\x2\xB00\xB02\x5\x16C\xB7\x2\xB01\xAFF\x3\x2\x2\x2");
		sb.Append("\xB01\xB00\x3\x2\x2\x2\xB01\xB02\x3\x2\x2\x2\xB02\xB1B\x3\x2");
		sb.Append("\x2\x2\xB03\xB04\a\x1EB\x2\x2\xB04\xB08\x5\x150\xA9\x2\xB05");
		sb.Append("\xB07\x5\x142\xA2\x2\xB06\xB05\x3\x2\x2\x2\xB07\xB0A\x3\x2\x2");
		sb.Append("\x2\xB08\xB06\x3\x2\x2\x2\xB08\xB09\x3\x2\x2\x2\xB09\xB0B\x3");
		sb.Append("\x2\x2\x2\xB0A\xB08\x3\x2\x2\x2\xB0B\xB0E\a\x1EC\x2\x2\xB0C");
		sb.Append("\xB0F\x5\x160\xB1\x2\xB0D\xB0F\x5\x16C\xB7\x2\xB0E\xB0C\x3\x2");
		sb.Append("\x2\x2\xB0E\xB0D\x3\x2\x2\x2\xB0E\xB0F\x3\x2\x2\x2\xB0F\xB1B");
		sb.Append("\x3\x2\x2\x2\xB10\xB11\a\x108\x2\x2\xB11\xB12\a\x1EB\x2\x2\xB12");
		sb.Append("\xB13\x5\x1E2\xF2\x2\xB13\xB14\a\x1EC\x2\x2\xB14\xB1B\x3\x2");
		sb.Append("\x2\x2\xB15\xB18\x5\x1E2\xF2\x2\xB16\xB19\x5\x160\xB1\x2\xB17");
		sb.Append("\xB19\x5\x16C\xB7\x2\xB18\xB16\x3\x2\x2\x2\xB18\xB17\x3\x2\x2");
		sb.Append("\x2\xB18\xB19\x3\x2\x2\x2\xB19\xB1B\x3\x2\x2\x2\xB1A\xAFE\x3");
		sb.Append("\x2\x2\x2\xB1A\xB03\x3\x2\x2\x2\xB1A\xB10\x3\x2\x2\x2\xB1A\xB15");
		sb.Append("\x3\x2\x2\x2\xB1B\xB1F\x3\x2\x2\x2\xB1C\xB1E\x5\x15E\xB0\x2");
		sb.Append("\xB1D\xB1C\x3\x2\x2\x2\xB1E\xB21\x3\x2\x2\x2\xB1F\xB1D\x3\x2");
		sb.Append("\x2\x2\xB1F\xB20\x3\x2\x2\x2\xB20\xB23\x3\x2\x2\x2\xB21\xB1F");
		sb.Append("\x3\x2\x2\x2\xB22\xB24\x5\x27C\x13F\x2\xB23\xB22\x3\x2\x2\x2");
		sb.Append("\xB23\xB24\x3\x2\x2\x2\xB24\x153\x3\x2\x2\x2\xB25\xB27\x5\x15C");
		sb.Append("\xAF\x2\xB26\xB25\x3\x2\x2\x2\xB26\xB27\x3\x2\x2\x2\xB27\xB29");
		sb.Append("\x3\x2\x2\x2\xB28\xB2A\t!\x2\x2\xB29\xB28\x3\x2\x2\x2\xB29\xB2A");
		sb.Append("\x3\x2\x2\x2\xB2A\xB2D\x3\x2\x2\x2\xB2B\xB2E\a\xB1\x2\x2\xB2C");
		sb.Append("\xB2E\x5\x15A\xAE\x2\xB2D\xB2B\x3\x2\x2\x2\xB2D\xB2C\x3\x2\x2");
		sb.Append("\x2\xB2D\xB2E\x3\x2\x2\x2\xB2E\xB2F\x3\x2\x2\x2\xB2F\xB30\a");
		sb.Append("\xC0\x2\x2\xB30\xB32\x5\x152\xAA\x2\xB31\xB33\x5\x15C\xAF\x2");
		sb.Append("\xB32\xB31\x3\x2\x2\x2\xB32\xB33\x3\x2\x2\x2\xB33\xB38\x3\x2");
		sb.Append("\x2\x2\xB34\xB37\x5\x156\xAC\x2\xB35\xB37\x5\x158\xAD\x2\xB36");
		sb.Append("\xB34\x3\x2\x2\x2\xB36\xB35\x3\x2\x2\x2\xB37\xB3A\x3\x2\x2\x2");
		sb.Append("\xB38\xB36\x3\x2\x2\x2\xB38\xB39\x3\x2\x2\x2\xB39\x155\x3\x2");
		sb.Append("\x2\x2\xB3A\xB38\x3\x2\x2\x2\xB3B\xB3C\a\x107\x2\x2\xB3C\xB3D");
		sb.Append("\x5\x1F0\xF9\x2\xB3D\x157\x3\x2\x2\x2\xB3E\xB3F\a\x19A\x2\x2");
		sb.Append("\xB3F\xB40\a\x1EB\x2\x2\xB40\xB45\x5\x2C0\x161\x2\xB41\xB42");
		sb.Append("\a\x1F1\x2\x2\xB42\xB44\x5\x2C0\x161\x2\xB43\xB41\x3\x2\x2\x2");
		sb.Append("\xB44\xB47\x3\x2\x2\x2\xB45\xB43\x3\x2\x2\x2\xB45\xB46\x3\x2");
		sb.Append("\x2\x2\xB46\xB48\x3\x2\x2\x2\xB47\xB45\x3\x2\x2\x2\xB48\xB49");
		sb.Append("\a\x1EC\x2\x2\xB49\x159\x3\x2\x2\x2\xB4A\xB4C\t\"\x2\x2\xB4B");
		sb.Append("\xB4D\a\x111\x2\x2\xB4C\xB4B\x3\x2\x2\x2\xB4C\xB4D\x3\x2\x2");
		sb.Append("\x2\xB4D\x15B\x3\x2\x2\x2\xB4E\xB4F\a\x118\x2\x2\xB4F\xB5D\a");
		sb.Append("(\x2\x2\xB50\xB51\a\x1EB\x2\x2\xB51\xB52\x5\x140\xA1\x2\xB52");
		sb.Append("\xB53\a\x1EC\x2\x2\xB53\xB5E\x3\x2\x2\x2\xB54\xB5E\x5\x1EE\xF8");
		sb.Append("\x2\xB55\xB5A\x5\x1F4\xFB\x2\xB56\xB57\a\x1F1\x2\x2\xB57\xB59");
		sb.Append("\x5\x1F4\xFB\x2\xB58\xB56\x3\x2\x2\x2\xB59\xB5C\x3\x2\x2\x2");
		sb.Append("\xB5A\xB58\x3\x2\x2\x2\xB5A\xB5B\x3\x2\x2\x2\xB5B\xB5E\x3\x2");
		sb.Append("\x2\x2\xB5C\xB5A\x3\x2\x2\x2\xB5D\xB50\x3\x2\x2\x2\xB5D\xB54");
		sb.Append("\x3\x2\x2\x2\xB5D\xB55\x3\x2\x2\x2\xB5E\x15D\x3\x2\x2\x2\xB5F");
		sb.Append("\xB60\a\x1A4\x2\x2\xB60\xB61\a\x1C\x2\x2\xB61\xB62\t#\x2\x2");
		sb.Append("\xB62\xB68\x5\x1F4\xFB\x2\xB63\xB64\a\xF\x2\x2\xB64\xB65\a\x103");
		sb.Append("\x2\x2\xB65\xB66\t$\x2\x2\xB66\xB68\x5\x1F4\xFB\x2\xB67\xB5F");
		sb.Append("\x3\x2\x2\x2\xB67\xB63\x3\x2\x2\x2\xB68\x15F\x3\x2\x2\x2\xB69");
		sb.Append("\xB6B\a\x11E\x2\x2\xB6A\xB6C\a\x1B0\x2\x2\xB6B\xB6A\x3\x2\x2");
		sb.Append("\x2\xB6B\xB6C\x3\x2\x2\x2\xB6C\xB6D\x3\x2\x2\x2\xB6D\xB6E\a");
		sb.Append("\x1EB\x2\x2\xB6E\xB73\x5\x162\xB2\x2\xB6F\xB70\a\x1F1\x2\x2");
		sb.Append("\xB70\xB72\x5\x162\xB2\x2\xB71\xB6F\x3\x2\x2\x2\xB72\xB75\x3");
		sb.Append("\x2\x2\x2\xB73\xB71\x3\x2\x2\x2\xB73\xB74\x3\x2\x2\x2\xB74\xB76");
		sb.Append("\x3\x2\x2\x2\xB75\xB73\x3\x2\x2\x2\xB76\xB77\x5\x164\xB3\x2");
		sb.Append("\xB77\xB78\x5\x166\xB4\x2\xB78\xB79\a\x1EC\x2\x2\xB79\x161\x3");
		sb.Append("\x2\x2\x2\xB7A\xB7B\x5\x2A0\x151\x2\xB7B\xB7C\a\x1EB\x2\x2\xB7C");
		sb.Append("\xB7D\x5\x1F4\xFB\x2\xB7D\xB7F\a\x1EC\x2\x2\xB7E\xB80\x5\x27A");
		sb.Append("\x13E\x2\xB7F\xB7E\x3\x2\x2\x2\xB7F\xB80\x3\x2\x2\x2\xB80\x163");
		sb.Append("\x3\x2\x2\x2\xB81\xB8E\a\x95\x2\x2\xB82\xB8F\x5\x2C0\x161\x2");
		sb.Append("\xB83\xB84\a\x1EB\x2\x2\xB84\xB89\x5\x2C0\x161\x2\xB85\xB86");
		sb.Append("\a\x1F1\x2\x2\xB86\xB88\x5\x2C0\x161\x2\xB87\xB85\x3\x2\x2\x2");
		sb.Append("\xB88\xB8B\x3\x2\x2\x2\xB89\xB87\x3\x2\x2\x2\xB89\xB8A\x3\x2");
		sb.Append("\x2\x2\xB8A\xB8C\x3\x2\x2\x2\xB8B\xB89\x3\x2\x2\x2\xB8C\xB8D");
		sb.Append("\a\x1EC\x2\x2\xB8D\xB8F\x3\x2\x2\x2\xB8E\xB82\x3\x2\x2\x2\xB8E");
		sb.Append("\xB83\x3\x2\x2\x2\xB8F\x165\x3\x2\x2\x2\xB90\xB91\a\xA6\x2\x2");
		sb.Append("\xB91\xBA3\a\x1EB\x2\x2\xB92\xBA4\x5\x140\xA1\x2\xB93\xB98\a");
		sb.Append("\r\x2\x2\xB94\xB95\a\x1F1\x2\x2\xB95\xB97\a\r\x2\x2\xB96\xB94");
		sb.Append("\x3\x2\x2\x2\xB97\xB9A\x3\x2\x2\x2\xB98\xB96\x3\x2\x2\x2\xB98");
		sb.Append("\xB99\x3\x2\x2\x2\xB99\xBA4\x3\x2\x2\x2\xB9A\xB98\x3\x2\x2\x2");
		sb.Append("\xB9B\xBA0\x5\x168\xB5\x2\xB9C\xB9D\a\x1F1\x2\x2\xB9D\xB9F\x5");
		sb.Append("\x168\xB5\x2\xB9E\xB9C\x3\x2\x2\x2\xB9F\xBA2\x3\x2\x2\x2\xBA0");
		sb.Append("\xB9E\x3\x2\x2\x2\xBA0\xBA1\x3\x2\x2\x2\xBA1\xBA4\x3\x2\x2\x2");
		sb.Append("\xBA2\xBA0\x3\x2\x2\x2\xBA3\xB92\x3\x2\x2\x2\xBA3\xB93\x3\x2");
		sb.Append("\x2\x2\xBA3\xB9B\x3\x2\x2\x2\xBA4\xBA5\x3\x2\x2\x2\xBA5\xBA6");
		sb.Append("\a\x1EC\x2\x2\xBA6\x167\x3\x2\x2\x2\xBA7\xBA9\x5\x16A\xB6\x2");
		sb.Append("\xBA8\xBAA\x5\x27A\x13E\x2\xBA9\xBA8\x3\x2\x2\x2\xBA9\xBAA\x3");
		sb.Append("\x2\x2\x2\xBAA\x169\x3\x2\x2\x2\xBAB\xBAE\x5\x1F4\xFB\x2\xBAC");
		sb.Append("\xBAE\x5\x1EE\xF8\x2\xBAD\xBAB\x3\x2\x2\x2\xBAD\xBAC\x3\x2\x2");
		sb.Append("\x2\xBAE\x16B\x3\x2\x2\x2\xBAF\xBB2\a\x193\x2\x2\xBB0\xBB1\t");
		sb.Append("%\x2\x2\xBB1\xBB3\a\xFE\x2\x2\xBB2\xBB0\x3\x2\x2\x2\xBB2\xBB3");
		sb.Append("\x3\x2\x2\x2\xBB3\xBB4\x3\x2\x2\x2\xBB4\xBC1\a\x1EB\x2\x2\xBB5");
		sb.Append("\xBC2\x5\x2C0\x161\x2\xBB6\xBB7\a\x1EB\x2\x2\xBB7\xBBC\x5\x2C0");
		sb.Append("\x161\x2\xBB8\xBB9\a\x1F1\x2\x2\xBB9\xBBB\x5\x2C0\x161\x2\xBBA");
		sb.Append("\xBB8\x3\x2\x2\x2\xBBB\xBBE\x3\x2\x2\x2\xBBC\xBBA\x3\x2\x2\x2");
		sb.Append("\xBBC\xBBD\x3\x2\x2\x2\xBBD\xBBF\x3\x2\x2\x2\xBBE\xBBC\x3\x2");
		sb.Append("\x2\x2\xBBF\xBC0\a\x1EC\x2\x2\xBC0\xBC2\x3\x2\x2\x2\xBC1\xBB5");
		sb.Append("\x3\x2\x2\x2\xBC1\xBB6\x3\x2\x2\x2\xBC2\xBC3\x3\x2\x2\x2\xBC3");
		sb.Append("\xBC4\x5\x164\xB3\x2\xBC4\xBC5\x5\x16E\xB8\x2\xBC5\xBC6\a\x1EC");
		sb.Append("\x2\x2\xBC6\x16D\x3\x2\x2\x2\xBC7\xBC8\a\xA6\x2\x2\xBC8\xBC9");
		sb.Append("\a\x1EB\x2\x2\xBC9\xBCE\x5\x170\xB9\x2\xBCA\xBCB\a\x1F1\x2\x2");
		sb.Append("\xBCB\xBCD\x5\x170\xB9\x2\xBCC\xBCA\x3\x2\x2\x2\xBCD\xBD0\x3");
		sb.Append("\x2\x2\x2\xBCE\xBCC\x3\x2\x2\x2\xBCE\xBCF\x3\x2\x2\x2\xBCF\xBD1");
		sb.Append("\x3\x2\x2\x2\xBD0\xBCE\x3\x2\x2\x2\xBD1\xBD2\a\x1EC\x2\x2\xBD2");
		sb.Append("\x16F\x3\x2\x2\x2\xBD3\xBE0\x5\x2C0\x161\x2\xBD4\xBD5\a\x1EB");
		sb.Append("\x2\x2\xBD5\xBDA\x5\x2C0\x161\x2\xBD6\xBD7\a\x1F1\x2\x2\xBD7");
		sb.Append("\xBD9\x5\x2C0\x161\x2\xBD8\xBD6\x3\x2\x2\x2\xBD9\xBDC\x3\x2");
		sb.Append("\x2\x2\xBDA\xBD8\x3\x2\x2\x2\xBDA\xBDB\x3\x2\x2\x2\xBDB\xBDD");
		sb.Append("\x3\x2\x2\x2\xBDC\xBDA\x3\x2\x2\x2\xBDD\xBDE\a\x1EC\x2\x2\xBDE");
		sb.Append("\xBE0\x3\x2\x2\x2\xBDF\xBD3\x3\x2\x2\x2\xBDF\xBD4\x3\x2\x2\x2");
		sb.Append("\xBE0\xBF0\x3\x2\x2\x2\xBE1\xBEE\a\xF\x2\x2\xBE2\xBEF\x5\x2E2");
		sb.Append("\x172\x2\xBE3\xBE4\a\x1EB\x2\x2\xBE4\xBE9\x5\x2E2\x172\x2\xBE5");
		sb.Append("\xBE6\a\x1F1\x2\x2\xBE6\xBE8\x5\x2E2\x172\x2\xBE7\xBE5\x3\x2");
		sb.Append("\x2\x2\xBE8\xBEB\x3\x2\x2\x2\xBE9\xBE7\x3\x2\x2\x2\xBE9\xBEA");
		sb.Append("\x3\x2\x2\x2\xBEA\xBEC\x3\x2\x2\x2\xBEB\xBE9\x3\x2\x2\x2\xBEC");
		sb.Append("\xBED\a\x1EC\x2\x2\xBED\xBEF\x3\x2\x2\x2\xBEE\xBE2\x3\x2\x2");
		sb.Append("\x2\xBEE\xBE3\x3\x2\x2\x2\xBEF\xBF1\x3\x2\x2\x2\xBF0\xBE1\x3");
		sb.Append("\x2\x2\x2\xBF0\xBF1\x3\x2\x2\x2\xBF1\x171\x3\x2\x2\x2\xBF2\xBF3");
		sb.Append("\a\x41\x2\x2\xBF3\xBF5\a(\x2\x2\xBF4\xBF6\a\xF4\x2\x2\xBF5\xBF4");
		sb.Append("\x3\x2\x2\x2\xBF5\xBF6\x3\x2\x2\x2\xBF6\xBF7\x3\x2\x2\x2\xBF7");
		sb.Append("\xBF9\x5\x1F0\xF9\x2\xBF8\xBFA\x5\x174\xBB\x2\xBF9\xBF8\x3\x2");
		sb.Append("\x2\x2\xBF9\xBFA\x3\x2\x2\x2\xBFA\xC04\x3\x2\x2\x2\xBFB\xBFC");
		sb.Append("\x5\x174\xBB\x2\xBFC\xBFD\a\x41\x2\x2\xBFD\xBFF\a(\x2\x2\xBFE");
		sb.Append("\xC00\a\xF4\x2\x2\xBFF\xBFE\x3\x2\x2\x2\xBFF\xC00\x3\x2\x2\x2");
		sb.Append("\xC00\xC01\x3\x2\x2\x2\xC01\xC02\x5\x1F0\xF9\x2\xC02\xC04\x3");
		sb.Append("\x2\x2\x2\xC03\xBF2\x3\x2\x2\x2\xC03\xBFB\x3\x2\x2\x2\xC04\x173");
		sb.Append("\x3\x2\x2\x2\xC05\xC06\a\x16B\x2\x2\xC06\xC07\a\x1AC\x2\x2\xC07");
		sb.Append("\xC08\x5\x1F0\xF9\x2\xC08\x175\x3\x2\x2\x2\xC09\xC0A\a\x9D\x2");
		sb.Append("\x2\xC0A\xC0B\a(\x2\x2\xC0B\xC10\x5\x178\xBD\x2\xC0C\xC0D\a");
		sb.Append("\x1F1\x2\x2\xC0D\xC0F\x5\x178\xBD\x2\xC0E\xC0C\x3\x2\x2\x2\xC0F");
		sb.Append("\xC12\x3\x2\x2\x2\xC10\xC0E\x3\x2\x2\x2\xC10\xC11\x3\x2\x2\x2");
		sb.Append("\xC11\xC14\x3\x2\x2\x2\xC12\xC10\x3\x2\x2\x2\xC13\xC15\x5\x180");
		sb.Append("\xC1\x2\xC14\xC13\x3\x2\x2\x2\xC14\xC15\x3\x2\x2\x2\xC15\xC24");
		sb.Append("\x3\x2\x2\x2\xC16\xC21\x5\x180\xC1\x2\xC17\xC18\a\x9D\x2\x2");
		sb.Append("\xC18\xC19\a(\x2\x2\xC19\xC1E\x5\x178\xBD\x2\xC1A\xC1B\a\x1F1");
		sb.Append("\x2\x2\xC1B\xC1D\x5\x178\xBD\x2\xC1C\xC1A\x3\x2\x2\x2\xC1D\xC20");
		sb.Append("\x3\x2\x2\x2\xC1E\xC1C\x3\x2\x2\x2\xC1E\xC1F\x3\x2\x2\x2\xC1F");
		sb.Append("\xC22\x3\x2\x2\x2\xC20\xC1E\x3\x2\x2\x2\xC21\xC17\x3\x2\x2\x2");
		sb.Append("\xC21\xC22\x3\x2\x2\x2\xC22\xC24\x3\x2\x2\x2\xC23\xC09\x3\x2");
		sb.Append("\x2\x2\xC23\xC16\x3\x2\x2\x2\xC24\x177\x3\x2\x2\x2\xC25\xC29");
		sb.Append("\x5\x17C\xBF\x2\xC26\xC29\x5\x17A\xBE\x2\xC27\xC29\x5\x1F4\xFB");
		sb.Append("\x2\xC28\xC25\x3\x2\x2\x2\xC28\xC26\x3\x2\x2\x2\xC28\xC27\x3");
		sb.Append("\x2\x2\x2\xC29\x179\x3\x2\x2\x2\xC2A\xC2B\t&\x2\x2\xC2B\xC2C");
		sb.Append("\a\x1EB\x2\x2\xC2C\xC31\x5\x17E\xC0\x2\xC2D\xC2E\a\x1F1\x2\x2");
		sb.Append("\xC2E\xC30\x5\x17E\xC0\x2\xC2F\xC2D\x3\x2\x2\x2\xC30\xC33\x3");
		sb.Append("\x2\x2\x2\xC31\xC2F\x3\x2\x2\x2\xC31\xC32\x3\x2\x2\x2\xC32\xC34");
		sb.Append("\x3\x2\x2\x2\xC33\xC31\x3\x2\x2\x2\xC34\xC35\a\x1EC\x2\x2\xC35");
		sb.Append("\x17B\x3\x2\x2\x2\xC36\xC37\a\x9E\x2\x2\xC37\xC38\a\x159\x2");
		sb.Append("\x2\xC38\xC39\a\x1EB\x2\x2\xC39\xC3E\x5\x17E\xC0\x2\xC3A\xC3B");
		sb.Append("\a\x1F1\x2\x2\xC3B\xC3D\x5\x17E\xC0\x2\xC3C\xC3A\x3\x2\x2\x2");
		sb.Append("\xC3D\xC40\x3\x2\x2\x2\xC3E\xC3C\x3\x2\x2\x2\xC3E\xC3F\x3\x2");
		sb.Append("\x2\x2\xC3F\xC41\x3\x2\x2\x2\xC40\xC3E\x3\x2\x2\x2\xC41\xC42");
		sb.Append("\a\x1EC\x2\x2\xC42\x17D\x3\x2\x2\x2\xC43\xC47\x5\x17A\xBE\x2");
		sb.Append("\xC44\xC47\x5\x1EE\xF8\x2\xC45\xC47\x5\x1F4\xFB\x2\xC46\xC43");
		sb.Append("\x3\x2\x2\x2\xC46\xC44\x3\x2\x2\x2\xC46\xC45\x3\x2\x2\x2\xC47");
		sb.Append("\x17F\x3\x2\x2\x2\xC48\xC49\a\xA0\x2\x2\xC49\xC4A\x5\x1F0\xF9");
		sb.Append("\x2\xC4A\x181\x3\x2\x2\x2\xC4B\xC4F\a\xE2\x2\x2\xC4C\xC4E\x5");
		sb.Append("\x184\xC3\x2\xC4D\xC4C\x3\x2\x2\x2\xC4E\xC51\x3\x2\x2\x2\xC4F");
		sb.Append("\xC4D\x3\x2\x2\x2\xC4F\xC50\x3\x2\x2\x2\xC50\xC53\x3\x2\x2\x2");
		sb.Append("\xC51\xC4F\x3\x2\x2\x2\xC52\xC54\x5\x186\xC4\x2\xC53\xC52\x3");
		sb.Append("\x2\x2\x2\xC53\xC54\x3\x2\x2\x2\xC54\xC58\x3\x2\x2\x2\xC55\xC57");
		sb.Append("\x5\x188\xC5\x2\xC56\xC55\x3\x2\x2\x2\xC57\xC5A\x3\x2\x2\x2");
		sb.Append("\xC58\xC56\x3\x2\x2\x2\xC58\xC59\x3\x2\x2\x2\xC59\xC5B\x3\x2");
		sb.Append("\x2\x2\xC5A\xC58\x3\x2\x2\x2\xC5B\xC5C\x5\x18A\xC6\x2\xC5C\x183");
		sb.Append("\x3\x2\x2\x2\xC5D\xC5E\t\'\x2\x2\xC5E\xC66\a\xEA\x2\x2\xC5F");
		sb.Append("\xC63\a\x191\x2\x2\xC60\xC64\al\x2\x2\xC61\xC62\a\x161\x2\x2");
		sb.Append("\xC62\xC64\a\x130\x2\x2\xC63\xC60\x3\x2\x2\x2\xC63\xC61\x3\x2");
		sb.Append("\x2\x2\xC64\xC66\x3\x2\x2\x2\xC65\xC5D\x3\x2\x2\x2\xC65\xC5F");
		sb.Append("\x3\x2\x2\x2\xC66\x185\x3\x2\x2\x2\xC67\xC68\a\x13A\x2\x2\xC68");
		sb.Append("\xC69\t(\x2\x2\xC69\xC6A\a\x144\x2\x2\xC6A\x187\x3\x2\x2\x2");
		sb.Append("\xC6B\xC6C\a\x130\x2\x2\xC6C\xC6D\x5\x29C\x14F\x2\xC6D\xC6E");
		sb.Append("\a\x107\x2\x2\xC6E\xC6F\a\x1EB\x2\x2\xC6F\xC70\x5\x140\xA1\x2");
		sb.Append("\xC70\xC71\a\x1EC\x2\x2\xC71\xC75\x5\x18C\xC7\x2\xC72\xC74\x5");
		sb.Append("\x184\xC3\x2\xC73\xC72\x3\x2\x2\x2\xC74\xC77\x3\x2\x2\x2\xC75");
		sb.Append("\xC73\x3\x2\x2\x2\xC75\xC76\x3\x2\x2\x2\xC76\x189\x3\x2\x2\x2");
		sb.Append("\xC77\xC75\x3\x2\x2\x2\xC78\xC79\a\xD6\x2\x2\xC79\xC7B\x5\x29E");
		sb.Append("\x150\x2\xC7A\xC78\x3\x2\x2\x2\xC7A\xC7B\x3\x2\x2\x2\xC7B\xC7C");
		sb.Append("\x3\x2\x2\x2\xC7C\xC80\x5\x18C\xC7\x2\xC7D\xC7F\x5\x184\xC3");
		sb.Append("\x2\xC7E\xC7D\x3\x2\x2\x2\xC7F\xC82\x3\x2\x2\x2\xC80\xC7E\x3");
		sb.Append("\x2\x2\x2\xC80\xC81\x3\x2\x2\x2\xC81\xC83\x3\x2\x2\x2\xC82\xC80");
		sb.Append("\x3\x2\x2\x2\xC83\xC84\x5\x194\xCB\x2\xC84\x18B\x3\x2\x2\x2");
		sb.Append("\xC85\xC87\x5\x18E\xC8\x2\xC86\xC85\x3\x2\x2\x2\xC86\xC87\x3");
		sb.Append("\x2\x2\x2\xC87\xC88\x3\x2\x2\x2\xC88\xC89\al\x2\x2\xC89\xC8A");
		sb.Append("\a(\x2\x2\xC8A\xC8B\x5\x190\xC9\x2\xC8B\xC8C\a\xDA\x2\x2\xC8C");
		sb.Append("\xC8D\x5\x190\xC9\x2\xC8D\x18D\x3\x2\x2\x2\xC8E\xC8F\a\x118");
		sb.Append("\x2\x2\xC8F\xC90\a(\x2\x2\xC90\xC91\x5\x190\xC9\x2\xC91\x18F");
		sb.Append("\x3\x2\x2\x2\xC92\xC93\a\x1EB\x2\x2\xC93\xC98\x5\x192\xCA\x2");
		sb.Append("\xC94\xC95\a\x1F1\x2\x2\xC95\xC97\x5\x192\xCA\x2\xC96\xC94\x3");
		sb.Append("\x2\x2\x2\xC97\xC9A\x3\x2\x2\x2\xC98\xC96\x3\x2\x2\x2\xC98\xC99");
		sb.Append("\x3\x2\x2\x2\xC99\xC9B\x3\x2\x2\x2\xC9A\xC98\x3\x2\x2\x2\xC9B");
		sb.Append("\xC9C\a\x1EC\x2\x2\xC9C\x191\x3\x2\x2\x2\xC9D\xC9F\x5\x1F4\xFB");
		sb.Append("\x2\xC9E\xCA0\x5\x27C\x13F\x2\xC9F\xC9E\x3\x2\x2\x2\xC9F\xCA0");
		sb.Append("\x3\x2\x2\x2\xCA0\x193\x3\x2\x2\x2\xCA1\xCA3\x5\x196\xCC\x2");
		sb.Append("\xCA2\xCA1\x3\x2\x2\x2\xCA2\xCA3\x3\x2\x2\x2\xCA3\xCA4\x3\x2");
		sb.Append("\x2\x2\xCA4\xCA5\a\x1EB\x2\x2\xCA5\xCAA\x5\x198\xCD\x2\xCA6");
		sb.Append("\xCA7\a\x1F1\x2\x2\xCA7\xCA9\x5\x198\xCD\x2\xCA8\xCA6\x3\x2");
		sb.Append("\x2\x2\xCA9\xCAC\x3\x2\x2\x2\xCAA\xCA8\x3\x2\x2\x2\xCAA\xCAB");
		sb.Append("\x3\x2\x2\x2\xCAB\xCAD\x3\x2\x2\x2\xCAC\xCAA\x3\x2\x2\x2\xCAD");
		sb.Append("\xCAE\a\x1EC\x2\x2\xCAE\x195\x3\x2\x2\x2\xCAF\xCB5\a\x145\x2");
		sb.Append("\x2\xCB0\xCB6\a\x195\x2\x2\xCB1\xCB3\a\x197\x2\x2\xCB2\xCB4");
		sb.Append("\a\t\x2\x2\xCB3\xCB2\x3\x2\x2\x2\xCB3\xCB4\x3\x2\x2\x2\xCB4");
		sb.Append("\xCB6\x3\x2\x2\x2\xCB5\xCB0\x3\x2\x2\x2\xCB5\xCB1\x3\x2\x2\x2");
		sb.Append("\xCB5\xCB6\x3\x2\x2\x2\xCB6\xCB9\x3\x2\x2\x2\xCB7\xCB8\t)\x2");
		sb.Append("\x2\xCB8\xCBA\a\x10D\x2\x2\xCB9\xCB7\x3\x2\x2\x2\xCB9\xCBA\x3");
		sb.Append("\x2\x2\x2\xCBA\xCBC\x3\x2\x2\x2\xCBB\xCBD\x5\x19C\xCF\x2\xCBC");
		sb.Append("\xCBB\x3\x2\x2\x2\xCBC\xCBD\x3\x2\x2\x2\xCBD\x197\x3\x2\x2\x2");
		sb.Append("\xCBE\xCC4\a\x195\x2\x2\xCBF\xCC1\a\x197\x2\x2\xCC0\xCC2\a\t");
		sb.Append("\x2\x2\xCC1\xCC0\x3\x2\x2\x2\xCC1\xCC2\x3\x2\x2\x2\xCC2\xCC4");
		sb.Append("\x3\x2\x2\x2\xCC3\xCBE\x3\x2\x2\x2\xCC3\xCBF\x3\x2\x2\x2\xCC3");
		sb.Append("\xCC4\x3\x2\x2\x2\xCC4\xCC5\x3\x2\x2\x2\xCC5\xCC7\x5\x19A\xCE");
		sb.Append("\x2\xCC6\xCC8\x5\x1A0\xD1\x2\xCC7\xCC6\x3\x2\x2\x2\xCC7\xCC8");
		sb.Append("\x3\x2\x2\x2\xCC8\xCC9\x3\x2\x2\x2\xCC9\xCCA\a\x202\x2\x2\xCCA");
		sb.Append("\xCCB\x5\x1F4\xFB\x2\xCCB\x199\x3\x2\x2\x2\xCCC\xCCD\x5\x21A");
		sb.Append("\x10E\x2\xCCD\x19B\x3\x2\x2\x2\xCCE\xCCF\a\xBE\x2\x2\xCCF\xCD0");
		sb.Append("\a\x1EB\x2\x2\xCD0\xCD1\x5\x1F4\xFB\x2\xCD1\xCD3\a\x1EC\x2\x2");
		sb.Append("\xCD2\xCD4\x5\x19E\xD0\x2\xCD3\xCD2\x3\x2\x2\x2\xCD3\xCD4\x3");
		sb.Append("\x2\x2\x2\xCD4\x19D\x3\x2\x2\x2\xCD5\xCD6\a\x194\x2\x2\xCD6");
		sb.Append("\xCD7\a\x1EB\x2\x2\xCD7\xCD8\x5\x1F0\xF9\x2\xCD8\xCD9\a\x1EC");
		sb.Append("\x2\x2\xCD9\x19F\x3\x2\x2\x2\xCDA\xCDC\a\x10D\x2\x2\xCDB\xCDD");
		sb.Append("\a\x15E\x2\x2\xCDC\xCDB\x3\x2\x2\x2\xCDC\xCDD\x3\x2\x2\x2\xCDD");
		sb.Append("\xCDE\x3\x2\x2\x2\xCDE\xCDF\a(\x2\x2\xCDF\xCE4\x5\x1A2\xD2\x2");
		sb.Append("\xCE0\xCE1\a\x1F1\x2\x2\xCE1\xCE3\x5\x1A2\xD2\x2\xCE2\xCE0\x3");
		sb.Append("\x2\x2\x2\xCE3\xCE6\x3\x2\x2\x2\xCE4\xCE2\x3\x2\x2\x2\xCE4\xCE5");
		sb.Append("\x3\x2\x2\x2\xCE5\x1A1\x3\x2\x2\x2\xCE6\xCE4\x3\x2\x2\x2\xCE7");
		sb.Append("\xCE9\x5\x1F4\xFB\x2\xCE8\xCEA\t*\x2\x2\xCE9\xCE8\x3\x2\x2\x2");
		sb.Append("\xCE9\xCEA\x3\x2\x2\x2\xCEA\xCED\x3\x2\x2\x2\xCEB\xCEC\a\xFE");
		sb.Append("\x2\x2\xCEC\xCEE\t+\x2\x2\xCED\xCEB\x3\x2\x2\x2\xCED\xCEE\x3");
		sb.Append("\x2\x2\x2\xCEE\x1A3\x3\x2\x2\x2\xCEF\xCF0\a\x95\x2\x2\xCF0\xCF2");
		sb.Append("\a\x195\x2\x2\xCF1\xCF3\x5\x1A6\xD4\x2\xCF2\xCF1\x3\x2\x2\x2");
		sb.Append("\xCF2\xCF3\x3\x2\x2\x2\xCF3\xCF5\x3\x2\x2\x2\xCF4\xCF6\x5\x1A8");
		sb.Append("\xD5\x2\xCF5\xCF4\x3\x2\x2\x2\xCF5\xCF6\x3\x2\x2\x2\xCF6\x1A5");
		sb.Append("\x3\x2\x2\x2\xCF7\xCF8\a\x103\x2\x2\xCF8\xCFD\x5\x2C0\x161\x2");
		sb.Append("\xCF9\xCFA\a\x1F1\x2\x2\xCFA\xCFC\x5\x2C0\x161\x2\xCFB\xCF9");
		sb.Append("\x3\x2\x2\x2\xCFC\xCFF\x3\x2\x2\x2\xCFD\xCFB\x3\x2\x2\x2\xCFD");
		sb.Append("\xCFE\x3\x2\x2\x2\xCFE\x1A7\x3\x2\x2\x2\xCFF\xCFD\x3\x2\x2\x2");
		sb.Append("\xD00\xD01\a\x163\x2\x2\xD01\xD06\a\xD0\x2\x2\xD02\xD06\a\xFC");
		sb.Append("\x2\x2\xD03\xD04\a\x1A5\x2\x2\xD04\xD06\x5\x1F4\xFB\x2\xD05");
		sb.Append("\xD00\x3\x2\x2\x2\xD05\xD02\x3\x2\x2\x2\xD05\xD03\x3\x2\x2\x2");
		sb.Append("\xD06\x1A9\x3\x2\x2\x2\xD07\xD08\a\x195\x2\x2\xD08\xD09\x5\x1D8");
		sb.Append("\xED\x2\xD09\xD0B\x5\x1AC\xD7\x2\xD0A\xD0C\x5\x280\x141\x2\xD0B");
		sb.Append("\xD0A\x3\x2\x2\x2\xD0B\xD0C\x3\x2\x2\x2\xD0C\xD0E\x3\x2\x2\x2");
		sb.Append("\xD0D\xD0F\x5\x1DA\xEE\x2\xD0E\xD0D\x3\x2\x2\x2\xD0E\xD0F\x3");
		sb.Append("\x2\x2\x2\xD0F\xD11\x3\x2\x2\x2\xD10\xD12\x5\x1DC\xEF\x2\xD11");
		sb.Append("\xD10\x3\x2\x2\x2\xD11\xD12\x3\x2\x2\x2\xD12\x1AB\x3\x2\x2\x2");
		sb.Append("\xD13\xD23\a\x158\x2\x2\xD14\xD19\x5\x1AE\xD8\x2\xD15\xD16\a");
		sb.Append("\x1F1\x2\x2\xD16\xD18\x5\x1AE\xD8\x2\xD17\xD15\x3\x2\x2\x2\xD18");
		sb.Append("\xD1B\x3\x2\x2\x2\xD19\xD17\x3\x2\x2\x2\xD19\xD1A\x3\x2\x2\x2");
		sb.Append("\xD1A\xD24\x3\x2\x2\x2\xD1B\xD19\x3\x2\x2\x2\xD1C\xD1D\a\x19C");
		sb.Append("\x2\x2\xD1D\xD1E\a\x1EB\x2\x2\xD1E\xD1F\x5\x2EA\x176\x2\xD1F");
		sb.Append("\xD20\a\x1EC\x2\x2\xD20\xD21\a\x202\x2\x2\xD21\xD22\x5\x1F4");
		sb.Append("\xFB\x2\xD22\xD24\x3\x2\x2\x2\xD23\xD14\x3\x2\x2\x2\xD23\xD1C");
		sb.Append("\x3\x2\x2\x2\xD24\x1AD\x3\x2\x2\x2\xD25\xD26\x5\x2C0\x161\x2");
		sb.Append("\xD26\xD27\a\x202\x2\x2\xD27\xD28\x5\x1F4\xFB\x2\xD28\xD37\x3");
		sb.Append("\x2\x2\x2\xD29\xD2A\a\x1EB\x2\x2\xD2A\xD2F\x5\x2C0\x161\x2\xD2B");
		sb.Append("\xD2C\a\x1F1\x2\x2\xD2C\xD2E\x5\x2C0\x161\x2\xD2D\xD2B\x3\x2");
		sb.Append("\x2\x2\xD2E\xD31\x3\x2\x2\x2\xD2F\xD2D\x3\x2\x2\x2\xD2F\xD30");
		sb.Append("\x3\x2\x2\x2\xD30\xD32\x3\x2\x2\x2\xD31\xD2F\x3\x2\x2\x2\xD32");
		sb.Append("\xD33\a\x1EC\x2\x2\xD33\xD34\a\x202\x2\x2\xD34\xD35\x5\x140");
		sb.Append("\xA1\x2\xD35\xD37\x3\x2\x2\x2\xD36\xD25\x3\x2\x2\x2\xD36\xD29");
		sb.Append("\x3\x2\x2\x2\xD37\x1AF\x3\x2\x2\x2\xD38\xD3A\ah\x2\x2\xD39\xD3B");
		sb.Append("\a\x98\x2\x2\xD3A\xD39\x3\x2\x2\x2\xD3A\xD3B\x3\x2\x2\x2\xD3B");
		sb.Append("\xD3C\x3\x2\x2\x2\xD3C\xD3E\x5\x1D8\xED\x2\xD3D\xD3F\x5\x280");
		sb.Append("\x141\x2\xD3E\xD3D\x3\x2\x2\x2\xD3E\xD3F\x3\x2\x2\x2\xD3F\xD41");
		sb.Append("\x3\x2\x2\x2\xD40\xD42\x5\x1DA\xEE\x2\xD41\xD40\x3\x2\x2\x2");
		sb.Append("\xD41\xD42\x3\x2\x2\x2\xD42\xD44\x3\x2\x2\x2\xD43\xD45\x5\x1DC");
		sb.Append("\xEF\x2\xD44\xD43\x3\x2\x2\x2\xD44\xD45\x3\x2\x2\x2\xD45\x1B1");
		sb.Append("\x3\x2\x2\x2\xD46\xD49\a\xB3\x2\x2\xD47\xD4A\x5\x1B4\xDB\x2");
		sb.Append("\xD48\xD4A\x5\x1B6\xDC\x2\xD49\xD47\x3\x2\x2\x2\xD49\xD48\x3");
		sb.Append("\x2\x2\x2\xD4A\x1B3\x3\x2\x2\x2\xD4B\xD51\x5\x1C0\xE1\x2\xD4C");
		sb.Append("\xD4E\x5\x1C2\xE2\x2\xD4D\xD4F\x5\x1DA\xEE\x2\xD4E\xD4D\x3\x2");
		sb.Append("\x2\x2\xD4E\xD4F\x3\x2\x2\x2\xD4F\xD52\x3\x2\x2\x2\xD50\xD52");
		sb.Append("\x5\x136\x9C\x2\xD51\xD4C\x3\x2\x2\x2\xD51\xD50\x3\x2\x2\x2");
		sb.Append("\xD52\xD54\x3\x2\x2\x2\xD53\xD55\x5\x1DC\xEF\x2\xD54\xD53\x3");
		sb.Append("\x2\x2\x2\xD54\xD55\x3\x2\x2\x2\xD55\x1B5\x3\x2\x2\x2\xD56\xD58");
		sb.Append("\a\t\x2\x2\xD57\xD59\x5\x1B8\xDD\x2\xD58\xD57\x3\x2\x2\x2\xD59");
		sb.Append("\xD5A\x3\x2\x2\x2\xD5A\xD58\x3\x2\x2\x2\xD5A\xD5B\x3\x2\x2\x2");
		sb.Append("\xD5B\xD5E\x3\x2\x2\x2\xD5C\xD5E\x5\x1BA\xDE\x2\xD5D\xD56\x3");
		sb.Append("\x2\x2\x2\xD5D\xD5C\x3\x2\x2\x2\xD5E\xD5F\x3\x2\x2\x2\xD5F\xD60");
		sb.Append("\x5\x136\x9C\x2\xD60\x1B7\x3\x2\x2\x2\xD61\xD63\x5\x1C0\xE1");
		sb.Append("\x2\xD62\xD64\x5\x1C2\xE2\x2\xD63\xD62\x3\x2\x2\x2\xD63\xD64");
		sb.Append("\x3\x2\x2\x2\xD64\xD66\x3\x2\x2\x2\xD65\xD67\x5\x1DC\xEF\x2");
		sb.Append("\xD66\xD65\x3\x2\x2\x2\xD66\xD67\x3\x2\x2\x2\xD67\x1B9\x3\x2");
		sb.Append("\x2\x2\xD68\xD6A\t,\x2\x2\xD69\xD68\x3\x2\x2\x2\xD69\xD6A\x3");
		sb.Append("\x2\x2\x2\xD6A\xD6C\x3\x2\x2\x2\xD6B\xD6D\x5\x1BC\xDF\x2\xD6C");
		sb.Append("\xD6B\x3\x2\x2\x2\xD6D\xD6E\x3\x2\x2\x2\xD6E\xD6C\x3\x2\x2\x2");
		sb.Append("\xD6E\xD6F\x3\x2\x2\x2\xD6F\xD71\x3\x2\x2\x2\xD70\xD72\x5\x1BE");
		sb.Append("\xE0\x2\xD71\xD70\x3\x2\x2\x2\xD71\xD72\x3\x2\x2\x2\xD72\x1BB");
		sb.Append("\x3\x2\x2\x2\xD73\xD74\a\x1A8\x2\x2\xD74\xD75\x5\x1F0\xF9\x2");
		sb.Append("\xD75\xD77\a\x17A\x2\x2\xD76\xD78\x5\x1B8\xDD\x2\xD77\xD76\x3");
		sb.Append("\x2\x2\x2\xD78\xD79\x3\x2\x2\x2\xD79\xD77\x3\x2\x2\x2\xD79\xD7A");
		sb.Append("\x3\x2\x2\x2\xD7A\x1BD\x3\x2\x2\x2\xD7B\xD7D\av\x2\x2\xD7C\xD7E");
		sb.Append("\x5\x1B8\xDD\x2\xD7D\xD7C\x3\x2\x2\x2\xD7E\xD7F\x3\x2\x2\x2");
		sb.Append("\xD7F\xD7D\x3\x2\x2\x2\xD7F\xD80\x3\x2\x2\x2\xD80\x1BF\x3\x2");
		sb.Append("\x2\x2\xD81\xD82\a\xBA\x2\x2\xD82\xD8E\x5\x1D8\xED\x2\xD83\xD84");
		sb.Append("\a\x1EB\x2\x2\xD84\xD89\x5\x2C0\x161\x2\xD85\xD86\a\x1F1\x2");
		sb.Append("\x2\xD86\xD88\x5\x2C0\x161\x2\xD87\xD85\x3\x2\x2\x2\xD88\xD8B");
		sb.Append("\x3\x2\x2\x2\xD89\xD87\x3\x2\x2\x2\xD89\xD8A\x3\x2\x2\x2\xD8A");
		sb.Append("\xD8C\x3\x2\x2\x2\xD8B\xD89\x3\x2\x2\x2\xD8C\xD8D\a\x1EC\x2");
		sb.Append("\x2\xD8D\xD8F\x3\x2\x2\x2\xD8E\xD83\x3\x2\x2\x2\xD8E\xD8F\x3");
		sb.Append("\x2\x2\x2\xD8F\x1C1\x3\x2\x2\x2\xD90\xD91\a\x19D\x2\x2\xD91");
		sb.Append("\xD92\x5\x1EE\xF8\x2\xD92\x1C3\x3\x2\x2\x2\xD93\xD94\a\xDC\x2");
		sb.Append("\x2\xD94\xD95\a\xBA\x2\x2\xD95\xD97\x5\x2C2\x162\x2\xD96\xD98");
		sb.Append("\x5\x27C\x13F\x2\xD97\xD96\x3\x2\x2\x2\xD97\xD98\x3\x2\x2\x2");
		sb.Append("\xD98\xD99\x3\x2\x2\x2\xD99\xD9A\a\x19A\x2\x2\xD9A\xD9B\x5\x1CE");
		sb.Append("\xE8\x2\xD9B\xD9C\a\x107\x2\x2\xD9C\xD9D\a\x1EB\x2\x2\xD9D\xD9E");
		sb.Append("\x5\x1F0\xF9\x2\xD9E\xDA7\a\x1EC\x2\x2\xD9F\xDA1\x5\x1C6\xE4");
		sb.Append("\x2\xDA0\xDA2\x5\x1CC\xE7\x2\xDA1\xDA0\x3\x2\x2\x2\xDA1\xDA2");
		sb.Append("\x3\x2\x2\x2\xDA2\xDA8\x3\x2\x2\x2\xDA3\xDA5\x5\x1CC\xE7\x2");
		sb.Append("\xDA4\xDA6\x5\x1C6\xE4\x2\xDA5\xDA4\x3\x2\x2\x2\xDA5\xDA6\x3");
		sb.Append("\x2\x2\x2\xDA6\xDA8\x3\x2\x2\x2\xDA7\xD9F\x3\x2\x2\x2\xDA7\xDA3");
		sb.Append("\x3\x2\x2\x2\xDA7\xDA8\x3\x2\x2\x2\xDA8\xDAA\x3\x2\x2\x2\xDA9");
		sb.Append("\xDAB\x5\x1DC\xEF\x2\xDAA\xDA9\x3\x2\x2\x2\xDAA\xDAB\x3\x2\x2");
		sb.Append("\x2\xDAB\x1C5\x3\x2\x2\x2\xDAC\xDAD\a\x1A8\x2\x2\xDAD\xDAE\a");
		sb.Append("\xD8\x2\x2\xDAE\xDAF\a\x17A\x2\x2\xDAF\xDB0\a\x195\x2\x2\xDB0");
		sb.Append("\xDB1\a\x158\x2\x2\xDB1\xDB6\x5\x1C8\xE5\x2\xDB2\xDB3\a\x1F1");
		sb.Append("\x2\x2\xDB3\xDB5\x5\x1C8\xE5\x2\xDB4\xDB2\x3\x2\x2\x2\xDB5\xDB8");
		sb.Append("\x3\x2\x2\x2\xDB6\xDB4\x3\x2\x2\x2\xDB6\xDB7\x3\x2\x2\x2\xDB7");
		sb.Append("\xDBA\x3\x2\x2\x2\xDB8\xDB6\x3\x2\x2\x2\xDB9\xDBB\x5\x280\x141");
		sb.Append("\x2\xDBA\xDB9\x3\x2\x2\x2\xDBA\xDBB\x3\x2\x2\x2\xDBB\xDBD\x3");
		sb.Append("\x2\x2\x2\xDBC\xDBE\x5\x1CA\xE6\x2\xDBD\xDBC\x3\x2\x2\x2\xDBD");
		sb.Append("\xDBE\x3\x2\x2\x2\xDBE\x1C7\x3\x2\x2\x2\xDBF\xDC0\x5\x2C0\x161");
		sb.Append("\x2\xDC0\xDC1\a\x202\x2\x2\xDC1\xDC2\x5\x1F4\xFB\x2\xDC2\x1C9");
		sb.Append("\x3\x2\x2\x2\xDC3\xDC4\ah\x2\x2\xDC4\xDC5\x5\x280\x141\x2\xDC5");
		sb.Append("\x1CB\x3\x2\x2\x2\xDC6\xDC7\a\x1A8\x2\x2\xDC7\xDC8\a\xFB\x2");
		sb.Append("\x2\xDC8\xDC9\a\xD8\x2\x2\xDC9\xDCA\a\x17A\x2\x2\xDCA\xDD6\a");
		sb.Append("\xB3\x2\x2\xDCB\xDCC\a\x1EB\x2\x2\xDCC\xDD1\x5\x2C0\x161\x2");
		sb.Append("\xDCD\xDCE\a\x1F1\x2\x2\xDCE\xDD0\x5\x2C0\x161\x2\xDCF\xDCD");
		sb.Append("\x3\x2\x2\x2\xDD0\xDD3\x3\x2\x2\x2\xDD1\xDCF\x3\x2\x2\x2\xDD1");
		sb.Append("\xDD2\x3\x2\x2\x2\xDD2\xDD4\x3\x2\x2\x2\xDD3\xDD1\x3\x2\x2\x2");
		sb.Append("\xDD4\xDD5\a\x1EC\x2\x2\xDD5\xDD7\x3\x2\x2\x2\xDD6\xDCB\x3\x2");
		sb.Append("\x2\x2\xDD6\xDD7\x3\x2\x2\x2\xDD7\xDD8\x3\x2\x2\x2\xDD8\xDD9");
		sb.Append("\a\x19D\x2\x2\xDD9\xDDB\x5\x1EE\xF8\x2\xDDA\xDDC\x5\x280\x141");
		sb.Append("\x2\xDDB\xDDA\x3\x2\x2\x2\xDDB\xDDC\x3\x2\x2\x2\xDDC\x1CD\x3");
		sb.Append("\x2\x2\x2\xDDD\xDE3\x5\x2C2\x162\x2\xDDE\xDDF\a\x1EB\x2\x2\xDDF");
		sb.Append("\xDE0\x5\x136\x9C\x2\xDE0\xDE1\a\x1EC\x2\x2\xDE1\xDE3\x3\x2");
		sb.Append("\x2\x2\xDE2\xDDD\x3\x2\x2\x2\xDE2\xDDE\x3\x2\x2\x2\xDE3\xDE5");
		sb.Append("\x3\x2\x2\x2\xDE4\xDE6\x5\x27C\x13F\x2\xDE5\xDE4\x3\x2\x2\x2");
		sb.Append("\xDE5\xDE6\x3\x2\x2\x2\xDE6\x1CF\x3\x2\x2\x2\xDE7\xDE8\a\xCF");
		sb.Append("\x2\x2\xDE8\xDE9\a\x178\x2\x2\xDE9\xDEE\x5\x1D4\xEB\x2\xDEA");
		sb.Append("\xDEB\a\x1F1\x2\x2\xDEB\xDED\x5\x1D4\xEB\x2\xDEC\xDEA\x3\x2");
		sb.Append("\x2\x2\xDED\xDF0\x3\x2\x2\x2\xDEE\xDEC\x3\x2\x2\x2\xDEE\xDEF");
		sb.Append("\x3\x2\x2\x2\xDEF\xDF1\x3\x2\x2\x2\xDF0\xDEE\x3\x2\x2\x2\xDF1");
		sb.Append("\xDF2\a\xA6\x2\x2\xDF2\xDF3\x5\x1D6\xEC\x2\xDF3\xDF5\a\xE1\x2");
		sb.Append("\x2\xDF4\xDF6\x5\x1D2\xEA\x2\xDF5\xDF4\x3\x2\x2\x2\xDF5\xDF6");
		sb.Append("\x3\x2\x2\x2\xDF6\x1D1\x3\x2\x2\x2\xDF7\xDF8\a\x1A5\x2\x2\xDF8");
		sb.Append("\xDFB\x5\x1F4\xFB\x2\xDF9\xDFB\a\xFC\x2\x2\xDFA\xDF7\x3\x2\x2");
		sb.Append("\x2\xDFA\xDF9\x3\x2\x2\x2\xDFB\x1D3\x3\x2\x2\x2\xDFC\xDFE\x5");
		sb.Append("\x2C2\x162\x2\xDFD\xDFF\x5\x278\x13D\x2\xDFE\xDFD\x3\x2\x2\x2");
		sb.Append("\xDFE\xDFF\x3\x2\x2\x2\xDFF\x1D5\x3\x2\x2\x2\xE00\xE01\a\x142");
		sb.Append("\x2\x2\xE01\xE0D\a\x15B\x2\x2\xE02\xE03\a\x142\x2\x2\xE03\xE0D");
		sb.Append("\a\x85\x2\x2\xE04\xE06\a\x15B\x2\x2\xE05\xE07\a\x195\x2\x2\xE06");
		sb.Append("\xE05\x3\x2\x2\x2\xE06\xE07\x3\x2\x2\x2\xE07\xE0D\x3\x2\x2\x2");
		sb.Append("\xE08\xE09\a\x15B\x2\x2\xE09\xE0A\a\x142\x2\x2\xE0A\xE0D\a\x85");
		sb.Append("\x2\x2\xE0B\xE0D\a\x85\x2\x2\xE0C\xE00\x3\x2\x2\x2\xE0C\xE02");
		sb.Append("\x3\x2\x2\x2\xE0C\xE04\x3\x2\x2\x2\xE0C\xE08\x3\x2\x2\x2\xE0C");
		sb.Append("\xE0B\x3\x2\x2\x2\xE0D\x1D7\x3\x2\x2\x2\xE0E\xE15\x5\x1E2\xF2");
		sb.Append("\x2\xE0F\xE10\a\x108\x2\x2\xE10\xE11\a\x1EB\x2\x2\xE11\xE12");
		sb.Append("\x5\x1E2\xF2\x2\xE12\xE13\a\x1EC\x2\x2\xE13\xE15\x3\x2\x2\x2");
		sb.Append("\xE14\xE0E\x3\x2\x2\x2\xE14\xE0F\x3\x2\x2\x2\xE15\xE17\x3\x2");
		sb.Append("\x2\x2\xE16\xE18\x5\x27C\x13F\x2\xE17\xE16\x3\x2\x2\x2\xE17");
		sb.Append("\xE18\x3\x2\x2\x2\xE18\x1D9\x3\x2\x2\x2\xE19\xE1A\t\x19\x2\x2");
		sb.Append("\xE1A\xE1F\x5\x1F4\xFB\x2\xE1B\xE1C\a\x1F1\x2\x2\xE1C\xE1E\x5");
		sb.Append("\x1F4\xFB\x2\xE1D\xE1B\x3\x2\x2\x2\xE1E\xE21\x3\x2\x2\x2\xE1F");
		sb.Append("\xE1D\x3\x2\x2\x2\xE1F\xE20\x3\x2\x2\x2\xE20\xE22\x3\x2\x2\x2");
		sb.Append("\xE21\xE1F\x3\x2\x2\x2\xE22\xE23\x5\x284\x143\x2\xE23\x1DB\x3");
		sb.Append("\x2\x2\x2\xE24\xE25\a\xD1\x2\x2\xE25\xE27\a~\x2\x2\xE26\xE28");
		sb.Append("\x5\x1DE\xF0\x2\xE27\xE26\x3\x2\x2\x2\xE27\xE28\x3\x2\x2\x2");
		sb.Append("\xE28\xE2A\x3\x2\x2\x2\xE29\xE2B\x5\x1F6\xFC\x2\xE2A\xE29\x3");
		sb.Append("\x2\x2\x2\xE2A\xE2B\x3\x2\x2\x2\xE2B\xE2D\x3\x2\x2\x2\xE2C\xE2E");
		sb.Append("\x5\x1E0\xF1\x2\xE2D\xE2C\x3\x2\x2\x2\xE2D\xE2E\x3\x2\x2\x2");
		sb.Append("\xE2E\x1DD\x3\x2\x2\x2\xE2F\xE30\a\xBA\x2\x2\xE30\xE31\x5\x2C2");
		sb.Append("\x162\x2\xE31\x1DF\x3\x2\x2\x2\xE32\xE33\a\x132\x2\x2\xE33\xE36");
		sb.Append("\a\xCD\x2\x2\xE34\xE37\a\x192\x2\x2\xE35\xE37\x5\x1F6\xFC\x2");
		sb.Append("\xE36\xE34\x3\x2\x2\x2\xE36\xE35\x3\x2\x2\x2\xE37\x1E1\x3\x2");
		sb.Append("\x2\x2\xE38\xE45\x5\x1E4\xF3\x2\xE39\xE3A\a\x1EB\x2\x2\xE3A");
		sb.Append("\xE3C\x5\x136\x9C\x2\xE3B\xE3D\x5\x1E6\xF4\x2\xE3C\xE3B\x3\x2");
		sb.Append("\x2\x2\xE3C\xE3D\x3\x2\x2\x2\xE3D\xE3E\x3\x2\x2\x2\xE3E\xE3F");
		sb.Append("\a\x1EC\x2\x2\xE3F\xE45\x3\x2\x2\x2\xE40\xE42\x5\x2C2\x162\x2");
		sb.Append("\xE41\xE43\x5\x1E8\xF5\x2\xE42\xE41\x3\x2\x2\x2\xE42\xE43\x3");
		sb.Append("\x2\x2\x2\xE43\xE45\x3\x2\x2\x2\xE44\xE38\x3\x2\x2\x2\xE44\xE39");
		sb.Append("\x3\x2\x2\x2\xE44\xE40\x3\x2\x2\x2\xE45\x1E3\x3\x2\x2\x2\xE46");
		sb.Append("\xE53\t-\x2\x2\xE47\xE48\a\x1EB\x2\x2\xE48\xE49\x5\x140\xA1");
		sb.Append("\x2\xE49\xE4A\a\x1EC\x2\x2\xE4A\xE54\x3\x2\x2\x2\xE4B\xE4C\a");
		sb.Append("\x1EB\x2\x2\xE4C\xE4D\x5\x1F4\xFB\x2\xE4D\xE51\a\x1EC\x2\x2");
		sb.Append("\xE4E\xE4F\a\x1EB\x2\x2\xE4F\xE50\a\x1EF\x2\x2\xE50\xE52\a\x1EC");
		sb.Append("\x2\x2\xE51\xE4E\x3\x2\x2\x2\xE51\xE52\x3\x2\x2\x2\xE52\xE54");
		sb.Append("\x3\x2\x2\x2\xE53\xE47\x3\x2\x2\x2\xE53\xE4B\x3\x2\x2\x2\xE54");
		sb.Append("\x1E5\x3\x2\x2\x2\xE55\xE5E\a\x1AC\x2\x2\xE56\xE57\a\x12C\x2");
		sb.Append("\x2\xE57\xE5F\a\x108\x2\x2\xE58\xE59\a\x34\x2\x2\xE59\xE5C\a");
		sb.Append("\x10A\x2\x2\xE5A\xE5B\a\x44\x2\x2\xE5B\xE5D\x5\x2A4\x153\x2");
		sb.Append("\xE5C\xE5A\x3\x2\x2\x2\xE5C\xE5D\x3\x2\x2\x2\xE5D\xE5F\x3\x2");
		sb.Append("\x2\x2\xE5E\xE56\x3\x2\x2\x2\xE5E\xE58\x3\x2\x2\x2\xE5F\x1E7");
		sb.Append("\x3\x2\x2\x2\xE60\xE62\a\x146\x2\x2\xE61\xE63\a\"\x2\x2\xE62");
		sb.Append("\xE61\x3\x2\x2\x2\xE62\xE63\x3\x2\x2\x2\xE63\xE64\x3\x2\x2\x2");
		sb.Append("\xE64\xE65\a\x1EB\x2\x2\xE65\xE68\x5\x1F4\xFB\x2\xE66\xE67\a");
		sb.Append("\x1F1\x2\x2\xE67\xE69\x5\x1F4\xFB\x2\xE68\xE66\x3\x2\x2\x2\xE68");
		sb.Append("\xE69\x3\x2\x2\x2\xE69\xE6A\x3\x2\x2\x2\xE6A\xE6C\a\x1EC\x2");
		sb.Append("\x2\xE6B\xE6D\x5\x1EA\xF6\x2\xE6C\xE6B\x3\x2\x2\x2\xE6C\xE6D");
		sb.Append("\x3\x2\x2\x2\xE6D\x1E9\x3\x2\x2\x2\xE6E\xE6F\a\x14E\x2\x2\xE6F");
		sb.Append("\xE70\a\x1EB\x2\x2\xE70\xE71\x5\x1F4\xFB\x2\xE71\xE72\a\x1EC");
		sb.Append("\x2\x2\xE72\x1EB\x3\x2\x2\x2\xE73\xE74\aT\x2\x2\xE74\xE75\a");
		sb.Append("\x1EB\x2\x2\xE75\xE76\x5\x140\xA1\x2\xE76\xE77\a\x1EC\x2\x2");
		sb.Append("\xE77\x1ED\x3\x2\x2\x2\xE78\xE7A\a\x1EB\x2\x2\xE79\xE7B\x5\x1F4");
		sb.Append("\xFB\x2\xE7A\xE79\x3\x2\x2\x2\xE7A\xE7B\x3\x2\x2\x2\xE7B\xE80");
		sb.Append("\x3\x2\x2\x2\xE7C\xE7D\a\x1F1\x2\x2\xE7D\xE7F\x5\x1F4\xFB\x2");
		sb.Append("\xE7E\xE7C\x3\x2\x2\x2\xE7F\xE82\x3\x2\x2\x2\xE80\xE7E\x3\x2");
		sb.Append("\x2\x2\xE80\xE81\x3\x2\x2\x2\xE81\xE83\x3\x2\x2\x2\xE82\xE80");
		sb.Append("\x3\x2\x2\x2\xE83\xE84\a\x1EC\x2\x2\xE84\x1EF\x3\x2\x2\x2\xE85");
		sb.Append("\xE86\x5\x1F4\xFB\x2\xE86\x1F1\x3\x2\x2\x2\xE87\xE88\x5\x1F4");
		sb.Append("\xFB\x2\xE88\x1F3\x3\x2\x2\x2\xE89\xE93\x5\x1EC\xF7\x2\xE8A");
		sb.Append("\xE8F\x5\x1F8\xFD\x2\xE8B\xE8C\a\x10B\x2\x2\xE8C\xE8E\x5\x1F8");
		sb.Append("\xFD\x2\xE8D\xE8B\x3\x2\x2\x2\xE8E\xE91\x3\x2\x2\x2\xE8F\xE8D");
		sb.Append("\x3\x2\x2\x2\xE8F\xE90\x3\x2\x2\x2\xE90\xE93\x3\x2\x2\x2\xE91");
		sb.Append("\xE8F\x3\x2\x2\x2\xE92\xE89\x3\x2\x2\x2\xE92\xE8A\x3\x2\x2\x2");
		sb.Append("\xE93\x1F5\x3\x2\x2\x2\xE94\xE95\x5\x1F4\xFB\x2\xE95\x1F7\x3");
		sb.Append("\x2\x2\x2\xE96\xE9B\x5\x1FA\xFE\x2\xE97\xE98\a\f\x2\x2\xE98");
		sb.Append("\xE9A\x5\x1FA\xFE\x2\xE99\xE97\x3\x2\x2\x2\xE9A\xE9D\x3\x2\x2");
		sb.Append("\x2\xE9B\xE99\x3\x2\x2\x2\xE9B\xE9C\x3\x2\x2\x2\xE9C\x1F9\x3");
		sb.Append("\x2\x2\x2\xE9D\xE9B\x3\x2\x2\x2\xE9E\xE9F\a\xFB\x2\x2\xE9F\xEA2");
		sb.Append("\x5\x1FA\xFE\x2\xEA0\xEA2\x5\x1FC\xFF\x2\xEA1\xE9E\x3\x2\x2");
		sb.Append("\x2\xEA1\xEA0\x3\x2\x2\x2\xEA2\x1FB\x3\x2\x2\x2\xEA3\xEC5\x5");
		sb.Append("\x1FE\x100\x2\xEA4\xEA6\a\xBC\x2\x2\xEA5\xEA7\a\xFB\x2\x2\xEA6");
		sb.Append("\xEA5\x3\x2\x2\x2\xEA6\xEA7\x3\x2\x2\x2\xEA7\xEC1\x3\x2\x2\x2");
		sb.Append("\xEA8\xEC2\a\xFD\x2\x2\xEA9\xEC2\a\xE7\x2\x2\xEAA\xEC2\a\x126");
		sb.Append("\x2\x2\xEAB\xEC2\a\xAF\x2\x2\xEAC\xEAD\a\x4\x2\x2\xEAD\xEC2");
		sb.Append("\a\x158\x2\x2\xEAE\xEC2\ax\x2\x2\xEAF\xEB1\a\x103\x2\x2\xEB0");
		sb.Append("\xEB2\a\x18D\x2\x2\xEB1\xEB0\x3\x2\x2\x2\xEB1\xEB2\x3\x2\x2");
		sb.Append("\x2\xEB2\xEB3\x3\x2\x2\x2\xEB3\xEB5\a\x1EB\x2\x2\xEB4\xEB6\a");
		sb.Append("\x108\x2\x2\xEB5\xEB4\x3\x2\x2\x2\xEB5\xEB6\x3\x2\x2\x2\xEB6");
		sb.Append("\xEB7\x3\x2\x2\x2\xEB7\xEBC\x5\x2D2\x16A\x2\xEB8\xEB9\a\x1F1");
		sb.Append("\x2\x2\xEB9\xEBB\x5\x2D2\x16A\x2\xEBA\xEB8\x3\x2\x2\x2\xEBB");
		sb.Append("\xEBE\x3\x2\x2\x2\xEBC\xEBA\x3\x2\x2\x2\xEBC\xEBD\x3\x2\x2\x2");
		sb.Append("\xEBD\xEBF\x3\x2\x2\x2\xEBE\xEBC\x3\x2\x2\x2\xEBF\xEC0\a\x1EC");
		sb.Append("\x2\x2\xEC0\xEC2\x3\x2\x2\x2\xEC1\xEA8\x3\x2\x2\x2\xEC1\xEA9");
		sb.Append("\x3\x2\x2\x2\xEC1\xEAA\x3\x2\x2\x2\xEC1\xEAB\x3\x2\x2\x2\xEC1");
		sb.Append("\xEAC\x3\x2\x2\x2\xEC1\xEAE\x3\x2\x2\x2\xEC1\xEAF\x3\x2\x2\x2");
		sb.Append("\xEC2\xEC4\x3\x2\x2\x2\xEC3\xEA4\x3\x2\x2\x2\xEC4\xEC7\x3\x2");
		sb.Append("\x2\x2\xEC5\xEC3\x3\x2\x2\x2\xEC5\xEC6\x3\x2\x2\x2\xEC6\x1FD");
		sb.Append("\x3\x2\x2\x2\xEC7\xEC5\x3\x2\x2\x2\xEC8\xECF\x5\x202\x102\x2");
		sb.Append("\xEC9\xECB\x5\x200\x101\x2\xECA\xECC\a\x103\x2\x2\xECB\xECA");
		sb.Append("\x3\x2\x2\x2\xECB\xECC\x3\x2\x2\x2\xECC\xECD\x3\x2\x2\x2\xECD");
		sb.Append("\xECE\x5\x20E\x108\x2\xECE\xED0\x3\x2\x2\x2\xECF\xEC9\x3\x2");
		sb.Append("\x2\x2\xECF\xED0\x3\x2\x2\x2\xED0\x1FF\x3\x2\x2\x2\xED1\xED2");
		sb.Append("\t.\x2\x2\xED2\x201\x3\x2\x2\x2\xED3\xEDF\x5\x204\x103\x2\xED4");
		sb.Append("\xEDB\a\x202\x2\x2\xED5\xEDB\x5\x2EE\x178\x2\xED6\xEDB\a\x1F9");
		sb.Append("\x2\x2\xED7\xEDB\a\x1FF\x2\x2\xED8\xEDB\x5\x2F2\x17A\x2\xED9");
		sb.Append("\xEDB\x5\x2F0\x179\x2\xEDA\xED4\x3\x2\x2\x2\xEDA\xED5\x3\x2");
		sb.Append("\x2\x2\xEDA\xED6\x3\x2\x2\x2\xEDA\xED7\x3\x2\x2\x2\xEDA\xED8");
		sb.Append("\x3\x2\x2\x2\xEDA\xED9\x3\x2\x2\x2\xEDB\xEDC\x3\x2\x2\x2\xEDC");
		sb.Append("\xEDE\x5\x204\x103\x2\xEDD\xEDA\x3\x2\x2\x2\xEDE\xEE1\x3\x2");
		sb.Append("\x2\x2\xEDF\xEDD\x3\x2\x2\x2\xEDF\xEE0\x3\x2\x2\x2\xEE0\x203");
		sb.Append("\x3\x2\x2\x2\xEE1\xEDF\x3\x2\x2\x2\xEE2\xEF1\x5\x20E\x108\x2");
		sb.Append("\xEE3\xEE5\a\xFB\x2\x2\xEE4\xEE3\x3\x2\x2\x2\xEE4\xEE5\x3\x2");
		sb.Append("\x2\x2\xEE5\xEEF\x3\x2\x2\x2\xEE6\xEE7\a\xA6\x2\x2\xEE7\xEF0");
		sb.Append("\x5\x20A\x106\x2\xEE8\xEE9\a\x1C\x2\x2\xEE9\xEF0\x5\x20C\x107");
		sb.Append("\x2\xEEA\xEEB\x5\x206\x104\x2\xEEB\xEED\x5\x20E\x108\x2\xEEC");
		sb.Append("\xEEE\x5\x208\x105\x2\xEED\xEEC\x3\x2\x2\x2\xEED\xEEE\x3\x2");
		sb.Append("\x2\x2\xEEE\xEF0\x3\x2\x2\x2\xEEF\xEE6\x3\x2\x2\x2\xEEF\xEE8");
		sb.Append("\x3\x2\x2\x2\xEEF\xEEA\x3\x2\x2\x2\xEF0\xEF2\x3\x2\x2\x2\xEF1");
		sb.Append("\xEE4\x3\x2\x2\x2\xEF1\xEF2\x3\x2\x2\x2\xEF2\x205\x3\x2\x2\x2");
		sb.Append("\xEF3\xEF4\t/\x2\x2\xEF4\x207\x3\x2\x2\x2\xEF5\xEF6\a\x7F\x2");
		sb.Append("\x2\xEF6\xEF7\x5\x20E\x108\x2\xEF7\x209\x3\x2\x2\x2\xEF8\xEF9");
		sb.Append("\a\x1EB\x2\x2\xEF9\xEFA\x5\x140\xA1\x2\xEFA\xEFB\a\x1EC\x2\x2");
		sb.Append("\xEFB\xF0B\x3\x2\x2\x2\xEFC\xEFD\a\x1EB\x2\x2\xEFD\xF02\x5\x210");
		sb.Append("\x109\x2\xEFE\xEFF\a\x1F1\x2\x2\xEFF\xF01\x5\x210\x109\x2\xF00");
		sb.Append("\xEFE\x3\x2\x2\x2\xF01\xF04\x3\x2\x2\x2\xF02\xF00\x3\x2\x2\x2");
		sb.Append("\xF02\xF03\x3\x2\x2\x2\xF03\xF05\x3\x2\x2\x2\xF04\xF02\x3\x2");
		sb.Append("\x2\x2\xF05\xF06\a\x1EC\x2\x2\xF06\xF0B\x3\x2\x2\x2\xF07\xF0B");
		sb.Append("\x5\x2E2\x172\x2\xF08\xF0B\x5\x2DA\x16E\x2\xF09\xF0B\x5\x2DC");
		sb.Append("\x16F\x2\xF0A\xEF8\x3\x2\x2\x2\xF0A\xEFC\x3\x2\x2\x2\xF0A\xF07");
		sb.Append("\x3\x2\x2\x2\xF0A\xF08\x3\x2\x2\x2\xF0A\xF09\x3\x2\x2\x2\xF0B");
		sb.Append("\x20B\x3\x2\x2\x2\xF0C\xF0D\x5\x20E\x108\x2\xF0D\xF0E\a\f\x2");
		sb.Append("\x2\xF0E\xF0F\x5\x20E\x108\x2\xF0F\x20D\x3\x2\x2\x2\xF10\xF16");
		sb.Append("\x5\x212\x10A\x2\xF11\xF12\x5\x2F4\x17B\x2\xF12\xF13\x5\x212");
		sb.Append("\x10A\x2\xF13\xF15\x3\x2\x2\x2\xF14\xF11\x3\x2\x2\x2\xF15\xF18");
		sb.Append("\x3\x2\x2\x2\xF16\xF14\x3\x2\x2\x2\xF16\xF17\x3\x2\x2\x2\xF17");
		sb.Append("\x20F\x3\x2\x2\x2\xF18\xF16\x3\x2\x2\x2\xF19\xF1A\x5\x20E\x108");
		sb.Append("\x2\xF1A\x211\x3\x2\x2\x2\xF1B\xF20\x5\x214\x10B\x2\xF1C\xF1D");
		sb.Append("\t\x30\x2\x2\xF1D\xF1F\x5\x214\x10B\x2\xF1E\xF1C\x3\x2\x2\x2");
		sb.Append("\xF1F\xF22\x3\x2\x2\x2\xF20\xF1E\x3\x2\x2\x2\xF20\xF21\x3\x2");
		sb.Append("\x2\x2\xF21\x213\x3\x2\x2\x2\xF22\xF20\x3\x2\x2\x2\xF23\xF28");
		sb.Append("\x5\x216\x10C\x2\xF24\xF25\t\x31\x2\x2\xF25\xF27\x5\x216\x10C");
		sb.Append("\x2\xF26\xF24\x3\x2\x2\x2\xF27\xF2A\x3\x2\x2\x2\xF28\xF26\x3");
		sb.Append("\x2\x2\x2\xF28\xF29\x3\x2\x2\x2\xF29\x215\x3\x2\x2\x2\xF2A\xF28");
		sb.Append("\x3\x2\x2\x2\xF2B\xF34\x5\x21A\x10E\x2\xF2C\xF31\a\x12\x2\x2");
		sb.Append("\xF2D\xF32\a\xCE\x2\x2\xF2E\xF2F\a\x17B\x2\x2\xF2F\xF30\a\x1C2");
		sb.Append("\x2\x2\xF30\xF32\x5\x210\x109\x2\xF31\xF2D\x3\x2\x2\x2\xF31");
		sb.Append("\xF2E\x3\x2\x2\x2\xF32\xF35\x3\x2\x2\x2\xF33\xF35\x5\x218\x10D");
		sb.Append("\x2\xF34\xF2C\x3\x2\x2\x2\xF34\xF33\x3\x2\x2\x2\xF34\xF35\x3");
		sb.Append("\x2\x2\x2\xF35\x217\x3\x2\x2\x2\xF36\xF3B\aZ\x2\x2\xF37\xF38");
		sb.Append("\a\x1EB\x2\x2\xF38\xF39\x5\x210\x109\x2\xF39\xF3A\a\x1EC\x2");
		sb.Append("\x2\xF3A\xF3C\x3\x2\x2\x2\xF3B\xF37\x3\x2\x2\x2\xF3B\xF3C\x3");
		sb.Append("\x2\x2\x2\xF3C\xF3D\x3\x2\x2\x2\xF3D\xF3E\a\x184\x2\x2\xF3E");
		sb.Append("\xF43\a\x14D\x2\x2\xF3F\xF40\a\x1EB\x2\x2\xF40\xF41\x5\x210");
		sb.Append("\x109\x2\xF41\xF42\a\x1EC\x2\x2\xF42\xF44\x3\x2\x2\x2\xF43\xF3F");
		sb.Append("\x3\x2\x2\x2\xF43\xF44\x3\x2\x2\x2\xF44\xF4F\x3\x2\x2\x2\xF45");
		sb.Append("\xF4A\a\x1BF\x2\x2\xF46\xF47\a\x1EB\x2\x2\xF47\xF48\x5\x210");
		sb.Append("\x109\x2\xF48\xF49\a\x1EC\x2\x2\xF49\xF4B\x3\x2\x2\x2\xF4A\xF46");
		sb.Append("\x3\x2\x2\x2\xF4A\xF4B\x3\x2\x2\x2\xF4B\xF4C\x3\x2\x2\x2\xF4C");
		sb.Append("\xF4D\a\x184\x2\x2\xF4D\xF4F\a\xE4\x2\x2\xF4E\xF36\x3\x2\x2");
		sb.Append("\x2\xF4E\xF45\x3\x2\x2\x2\xF4F\x219\x3\x2\x2\x2\xF50\xF55\x5");
		sb.Append("\x226\x114\x2\xF51\xF52\a\x203\x2\x2\xF52\xF53\x5\x21C\x10F");
		sb.Append("\x2\xF53\xF54\a\x204\x2\x2\xF54\xF56\x3\x2\x2\x2\xF55\xF51\x3");
		sb.Append("\x2\x2\x2\xF55\xF56\x3\x2\x2\x2\xF56\x21B\x3\x2\x2\x2\xF57\xF5A");
		sb.Append("\a\r\x2\x2\xF58\xF5A\x5\x1F2\xFA\x2\xF59\xF57\x3\x2\x2\x2\xF59");
		sb.Append("\xF58\x3\x2\x2\x2\xF5A\xF62\x3\x2\x2\x2\xF5B\xF5E\a\x1F1\x2");
		sb.Append("\x2\xF5C\xF5F\a\r\x2\x2\xF5D\xF5F\x5\x1F2\xFA\x2\xF5E\xF5C\x3");
		sb.Append("\x2\x2\x2\xF5E\xF5D\x3\x2\x2\x2\xF5F\xF61\x3\x2\x2\x2\xF60\xF5B");
		sb.Append("\x3\x2\x2\x2\xF61\xF64\x3\x2\x2\x2\xF62\xF60\x3\x2\x2\x2\xF62");
		sb.Append("\xF63\x3\x2\x2\x2\xF63\xF6F\x3\x2\x2\x2\xF64\xF62\x3\x2\x2\x2");
		sb.Append("\xF65\xF6A\x5\x21E\x110\x2\xF66\xF67\a\x1F1\x2\x2\xF67\xF69");
		sb.Append("\x5\x21E\x110\x2\xF68\xF66\x3\x2\x2\x2\xF69\xF6C\x3\x2\x2\x2");
		sb.Append("\xF6A\xF68\x3\x2\x2\x2\xF6A\xF6B\x3\x2\x2\x2\xF6B\xF6F\x3\x2");
		sb.Append("\x2\x2\xF6C\xF6A\x3\x2\x2\x2\xF6D\xF6F\x5\x224\x113\x2\xF6E");
		sb.Append("\xF59\x3\x2\x2\x2\xF6E\xF65\x3\x2\x2\x2\xF6E\xF6D\x3\x2\x2\x2");
		sb.Append("\xF6F\x21D\x3\x2\x2\x2\xF70\xF71\a\x95\x2\x2\xF71\xF7E\x5\x2C0");
		sb.Append("\x161\x2\xF72\xF73\a\xA6\x2\x2\xF73\xF7F\x5\x1EE\xF8\x2\xF74");
		sb.Append("\xF76\x5\x220\x111\x2\xF75\xF74\x3\x2\x2\x2\xF75\xF76\x3\x2");
		sb.Append("\x2\x2\xF76\xF77\x3\x2\x2\x2\xF77\xF78\a\x98\x2\x2\xF78\xF79");
		sb.Append("\x5\x1F4\xFB\x2\xF79\xF7A\a\x184\x2\x2\xF7A\xF7B\x5\x1F4\xFB");
		sb.Append("\x2\xF7B\xF7C\x5\x222\x112\x2\xF7C\xF7D\x5\x1F4\xFB\x2\xF7D");
		sb.Append("\xF7F\x3\x2\x2\x2\xF7E\xF72\x3\x2\x2\x2\xF7E\xF75\x3\x2\x2\x2");
		sb.Append("\xF7F\x21F\x3\x2\x2\x2\xF80\xF81\a\xC9\x2\x2\xF81\xF82\x5\x1F4");
		sb.Append("\xFB\x2\xF82\x221\x3\x2\x2\x2\xF83\xF84\t\x32\x2\x2\xF84\x223");
		sb.Append("\x3\x2\x2\x2\xF85\xF86\a\x95\x2\x2\xF86\xF87\a\x1EB\x2\x2\xF87");
		sb.Append("\xF8C\x5\x2C0\x161\x2\xF88\xF89\a\x1F1\x2\x2\xF89\xF8B\x5\x2C0");
		sb.Append("\x161\x2\xF8A\xF88\x3\x2\x2\x2\xF8B\xF8E\x3\x2\x2\x2\xF8C\xF8A");
		sb.Append("\x3\x2\x2\x2\xF8C\xF8D\x3\x2\x2\x2\xF8D\xF8F\x3\x2\x2\x2\xF8E");
		sb.Append("\xF8C\x3\x2\x2\x2\xF8F\xF90\a\x1EC\x2\x2\xF90\xF91\a\xA6\x2");
		sb.Append("\x2\xF91\xF9E\a\x1EB\x2\x2\xF92\xF9F\x5\x140\xA1\x2\xF93\xF94");
		sb.Append("\a\x1EB\x2\x2\xF94\xF99\x5\x1EE\xF8\x2\xF95\xF96\a\x1F1\x2\x2");
		sb.Append("\xF96\xF98\x5\x1EE\xF8\x2\xF97\xF95\x3\x2\x2\x2\xF98\xF9B\x3");
		sb.Append("\x2\x2\x2\xF99\xF97\x3\x2\x2\x2\xF99\xF9A\x3\x2\x2\x2\xF9A\xF9C");
		sb.Append("\x3\x2\x2\x2\xF9B\xF99\x3\x2\x2\x2\xF9C\xF9D\a\x1EC\x2\x2\xF9D");
		sb.Append("\xF9F\x3\x2\x2\x2\xF9E\xF92\x3\x2\x2\x2\xF9E\xF93\x3\x2\x2\x2");
		sb.Append("\xF9F\xFA0\x3\x2\x2\x2\xFA0\xFA1\a\x1EC\x2\x2\xFA1\x225\x3\x2");
		sb.Append("\x2\x2\xFA2\xFA3\a\x1F0\x2\x2\xFA3\xFB5\x5\x226\x114\x2\xFA4");
		sb.Append("\xFA5\a\x1EF\x2\x2\xFA5\xFB5\x5\x226\x114\x2\xFA6\xFA7\a\x127");
		sb.Append("\x2\x2\xFA7\xFB5\x5\x226\x114\x2\xFA8\xFA9\a\x42\x2\x2\xFA9");
		sb.Append("\xFB5\x5\x226\x114\x2\xFAA\xFAB\a\xEF\x2\x2\xFAB\xFB5\x5\x226");
		sb.Append("\x114\x2\xFAC\xFAD\ao\x2\x2\xFAD\xFB5\x5\x226\x114\x2\xFAE\xFAF");
		sb.Append("\a\t\x2\x2\xFAF\xFB5\x5\x226\x114\x2\xFB0\xFB5\x5\x228\x115");
		sb.Append("\x2\xFB1\xFB5\x5\x23A\x11E\x2\xFB2\xFB5\x5\x23C\x11F\x2\xFB3");
		sb.Append("\xFB5\x5\x234\x11B\x2\xFB4\xFA2\x3\x2\x2\x2\xFB4\xFA4\x3\x2");
		sb.Append("\x2\x2\xFB4\xFA6\x3\x2\x2\x2\xFB4\xFA8\x3\x2\x2\x2\xFB4\xFAA");
		sb.Append("\x3\x2\x2\x2\xFB4\xFAC\x3\x2\x2\x2\xFB4\xFAE\x3\x2\x2\x2\xFB4");
		sb.Append("\xFB0\x3\x2\x2\x2\xFB4\xFB1\x3\x2\x2\x2\xFB4\xFB2\x3\x2\x2\x2");
		sb.Append("\xFB4\xFB3\x3\x2\x2\x2\xFB5\x227\x3\x2\x2\x2\xFB6\xFB9\x5\x22E");
		sb.Append("\x118\x2\xFB7\xFB9\x5\x22A\x116\x2\xFB8\xFB6\x3\x2\x2\x2\xFB8");
		sb.Append("\xFB7\x3\x2\x2\x2\xFB9\x229\x3\x2\x2\x2\xFBA\xFBC\x5\x2A6\x154");
		sb.Append("\x2\xFBB\xFBA\x3\x2\x2\x2\xFBB\xFBC\x3\x2\x2\x2\xFBC\xFBD\x3");
		sb.Append("\x2\x2\x2\xFBD\xFBE\a/\x2\x2\xFBE\xFC0\x5\x234\x11B\x2\xFBF");
		sb.Append("\xFC1\x5\x22C\x117\x2\xFC0\xFBF\x3\x2\x2\x2\xFC1\xFC2\x3\x2");
		sb.Append("\x2\x2\xFC2\xFC0\x3\x2\x2\x2\xFC2\xFC3\x3\x2\x2\x2\xFC3\xFC5");
		sb.Append("\x3\x2\x2\x2\xFC4\xFC6\x5\x232\x11A\x2\xFC5\xFC4\x3\x2\x2\x2");
		sb.Append("\xFC5\xFC6\x3\x2\x2\x2\xFC6\xFC7\x3\x2\x2\x2\xFC7\xFC9\a{\x2");
		sb.Append("\x2\xFC8\xFCA\a/\x2\x2\xFC9\xFC8\x3\x2\x2\x2\xFC9\xFCA\x3\x2");
		sb.Append("\x2\x2\xFCA\xFCC\x3\x2\x2\x2\xFCB\xFCD\x5\x2A6\x154\x2\xFCC");
		sb.Append("\xFCB\x3\x2\x2\x2\xFCC\xFCD\x3\x2\x2\x2\xFCD\x22B\x3\x2\x2\x2");
		sb.Append("\xFCE\xFCF\a\x1A8\x2\x2\xFCF\xFD0\x5\x1F6\xFC\x2\xFD0\xFD3\a");
		sb.Append("\x17A\x2\x2\xFD1\xFD4\x5\xE0q\x2\xFD2\xFD4\x5\x1F6\xFC\x2\xFD3");
		sb.Append("\xFD1\x3\x2\x2\x2\xFD3\xFD2\x3\x2\x2\x2\xFD4\x22D\x3\x2\x2\x2");
		sb.Append("\xFD5\xFD7\x5\x2A6\x154\x2\xFD6\xFD5\x3\x2\x2\x2\xFD6\xFD7\x3");
		sb.Append("\x2\x2\x2\xFD7\xFD8\x3\x2\x2\x2\xFD8\xFDA\a/\x2\x2\xFD9\xFDB");
		sb.Append("\x5\x230\x119\x2\xFDA\xFD9\x3\x2\x2\x2\xFDB\xFDC\x3\x2\x2\x2");
		sb.Append("\xFDC\xFDA\x3\x2\x2\x2\xFDC\xFDD\x3\x2\x2\x2\xFDD\xFDF\x3\x2");
		sb.Append("\x2\x2\xFDE\xFE0\x5\x232\x11A\x2\xFDF\xFDE\x3\x2\x2\x2\xFDF");
		sb.Append("\xFE0\x3\x2\x2\x2\xFE0\xFE1\x3\x2\x2\x2\xFE1\xFE3\a{\x2\x2\xFE2");
		sb.Append("\xFE4\a/\x2\x2\xFE3\xFE2\x3\x2\x2\x2\xFE3\xFE4\x3\x2\x2\x2\xFE4");
		sb.Append("\xFE6\x3\x2\x2\x2\xFE5\xFE7\x5\x2A6\x154\x2\xFE6\xFE5\x3\x2");
		sb.Append("\x2\x2\xFE6\xFE7\x3\x2\x2\x2\xFE7\x22F\x3\x2\x2\x2\xFE8\xFE9");
		sb.Append("\a\x1A8\x2\x2\xFE9\xFEA\x5\x1F2\xFA\x2\xFEA\xFED\a\x17A\x2\x2");
		sb.Append("\xFEB\xFEE\x5\xE0q\x2\xFEC\xFEE\x5\x1F6\xFC\x2\xFED\xFEB\x3");
		sb.Append("\x2\x2\x2\xFED\xFEC\x3\x2\x2\x2\xFEE\x231\x3\x2\x2\x2\xFEF\xFF2");
		sb.Append("\av\x2\x2\xFF0\xFF3\x5\xE0q\x2\xFF1\xFF3\x5\x1F6\xFC\x2\xFF2");
		sb.Append("\xFF0\x3\x2\x2\x2\xFF2\xFF1\x3\x2\x2\x2\xFF3\x233\x3\x2\x2\x2");
		sb.Append("\xFF4\xFF5\x5\x2E0\x171\x2\xFF5\xFF6\x5\x2F6\x17C\x2\xFF6\x1009");
		sb.Append("\x3\x2\x2\x2\xFF7\x1009\x5\x2DA\x16E\x2\xFF8\x1009\x5\x2E2\x172");
		sb.Append("\x2\xFF9\x1009\x5\x2DC\x16F\x2\xFFA\x1006\a\x1EB\x2\x2\xFFB");
		sb.Append("\xFFC\x5\x140\xA1\x2\xFFC\x1000\a\x1EC\x2\x2\xFFD\xFFF\x5\x142");
		sb.Append("\xA2\x2\xFFE\xFFD\x3\x2\x2\x2\xFFF\x1002\x3\x2\x2\x2\x1000\xFFE");
		sb.Append("\x3\x2\x2\x2\x1000\x1001\x3\x2\x2\x2\x1001\x1007\x3\x2\x2\x2");
		sb.Append("\x1002\x1000\x3\x2\x2\x2\x1003\x1004\x5\x236\x11C\x2\x1004\x1005");
		sb.Append("\a\x1EC\x2\x2\x1005\x1007\x3\x2\x2\x2\x1006\xFFB\x3\x2\x2\x2");
		sb.Append("\x1006\x1003\x3\x2\x2\x2\x1007\x1009\x3\x2\x2\x2\x1008\xFF4");
		sb.Append("\x3\x2\x2\x2\x1008\xFF7\x3\x2\x2\x2\x1008\xFF8\x3\x2\x2\x2\x1008");
		sb.Append("\xFF9\x3\x2\x2\x2\x1008\xFFA\x3\x2\x2\x2\x1009\x235\x3\x2\x2");
		sb.Append("\x2\x100A\x100C\x5\x1F4\xFB\x2\x100B\x100D\x5\x238\x11D\x2\x100C");
		sb.Append("\x100B\x3\x2\x2\x2\x100C\x100D\x3\x2\x2\x2\x100D\x237\x3\x2");
		sb.Append("\x2\x2\x100E\x100F\a\x1F1\x2\x2\x100F\x1014\x5\x1F4\xFB\x2\x1010");
		sb.Append("\x1011\a\x1F1\x2\x2\x1011\x1013\x5\x1F4\xFB\x2\x1012\x1010\x3");
		sb.Append("\x2\x2\x2\x1013\x1016\x3\x2\x2\x2\x1014\x1012\x3\x2\x2\x2\x1014");
		sb.Append("\x1015\x3\x2\x2\x2\x1015\x239\x3\x2\x2\x2\x1016\x1014\x3\x2");
		sb.Append("\x2\x2\x1017\x1020\t\x33\x2\x2\x1018\x1019\a\x1EB\x2\x2\x1019");
		sb.Append("\x101A\x5\x140\xA1\x2\x101A\x101B\a\x1EC\x2\x2\x101B\x1021\x3");
		sb.Append("\x2\x2\x2\x101C\x101D\a\x1EB\x2\x2\x101D\x101E\x5\x1F6\xFC\x2");
		sb.Append("\x101E\x101F\a\x1EC\x2\x2\x101F\x1021\x3\x2\x2\x2\x1020\x1018");
		sb.Append("\x3\x2\x2\x2\x1020\x101C\x3\x2\x2\x2\x1021\x23B\x3\x2\x2\x2");
		sb.Append("\x1022\x1023\x5\x23E\x120\x2\x1023\x1025\x5\x2CA\x166\x2\x1024");
		sb.Append("\x1026\x5\x244\x123\x2\x1025\x1024\x3\x2\x2\x2\x1025\x1026\x3");
		sb.Append("\x2\x2\x2\x1026\x115D\x3\x2\x2\x2\x1027\x1028\x5\x2F8\x17D\x2");
		sb.Append("\x1028\x102A\x5\x2CC\x167\x2\x1029\x102B\x5\x24C\x127\x2\x102A");
		sb.Append("\x1029\x3\x2\x2\x2\x102A\x102B\x3\x2\x2\x2\x102B\x115D\x3\x2");
		sb.Append("\x2\x2\x102C\x102D\aN\x2\x2\x102D\x1033\a\x1EB\x2\x2\x102E\x1034");
		sb.Append("\a\x1EE\x2\x2\x102F\x1031\t \x2\x2\x1030\x102F\x3\x2\x2\x2\x1030");
		sb.Append("\x1031\x3\x2\x2\x2\x1031\x1032\x3\x2\x2\x2\x1032\x1034\x5\x210");
		sb.Append("\x109\x2\x1033\x102E\x3\x2\x2\x2\x1033\x1030\x3\x2\x2\x2\x1034");
		sb.Append("\x1035\x3\x2\x2\x2\x1035\x1037\a\x1EC\x2\x2\x1036\x1038\x5\x244");
		sb.Append("\x123\x2\x1037\x1036\x3\x2\x2\x2\x1037\x1038\x3\x2\x2\x2\x1038");
		sb.Append("\x115D\x3\x2\x2\x2\x1039\x103A\t\x34\x2\x2\x103A\x1041\a\x1EB");
		sb.Append("\x2\x2\x103B\x103C\a\xE5\x2\x2\x103C\x103D\a\x1EB\x2\x2\x103D");
		sb.Append("\x103E\x5\x140\xA1\x2\x103E\x103F\a\x1EC\x2\x2\x103F\x1042\x3");
		sb.Append("\x2\x2\x2\x1040\x1042\x5\x210\x109\x2\x1041\x103B\x3\x2\x2\x2");
		sb.Append("\x1041\x1040\x3\x2\x2\x2\x1042\x1043\x3\x2\x2\x2\x1043\x1044");
		sb.Append("\a\xF\x2\x2\x1044\x1045\x5\x2D2\x16A\x2\x1045\x1046\a\x1EC\x2");
		sb.Append("\x2\x1046\x115D\x3\x2\x2\x2\x1047\x1048\a\x35\x2\x2\x1048\x1049");
		sb.Append("\a\x1EB\x2\x2\x1049\x104A\x5\x210\x109\x2\x104A\x104B\a\x19A");
		sb.Append("\x2\x2\x104B\x104C\a\xEC\x2\x2\x104C\x104D\a\x1EC\x2\x2\x104D");
		sb.Append("\x115D\x3\x2\x2\x2\x104E\x104F\a\x39\x2\x2\x104F\x1051\a\x1EB");
		sb.Append("\x2\x2\x1050\x1052\t\x35\x2\x2\x1051\x1050\x3\x2\x2\x2\x1051");
		sb.Append("\x1052\x3\x2\x2\x2\x1052\x1053\x3\x2\x2\x2\x1053\x1055\x5\x210");
		sb.Append("\x109\x2\x1054\x1056\x5\x250\x129\x2\x1055\x1054\x3\x2\x2\x2");
		sb.Append("\x1055\x1056\x3\x2\x2\x2\x1056\x1057\x3\x2\x2\x2\x1057\x1058");
		sb.Append("\a\x1EC\x2\x2\x1058\x115D\x3\x2\x2\x2\x1059\x105A\x5\x240\x121");
		sb.Append("\x2\x105A\x105C\x5\x2C8\x165\x2\x105B\x105D\x5\x252\x12A\x2");
		sb.Append("\x105C\x105B\x3\x2\x2\x2\x105D\x105E\x3\x2\x2\x2\x105E\x105C");
		sb.Append("\x3\x2\x2\x2\x105E\x105F\x3\x2\x2\x2\x105F\x115D\x3\x2\x2\x2");
		sb.Append("\x1060\x1061\a\x62\x2\x2\x1061\x1062\a\x1EB\x2\x2\x1062\x1064");
		sb.Append("\x5\x210\x109\x2\x1063\x1065\t\x36\x2\x2\x1064\x1063\x3\x2\x2");
		sb.Append("\x2\x1064\x1065\x3\x2\x2\x2\x1065\x1066\x3\x2\x2\x2\x1066\x1067");
		sb.Append("\a\x1EC\x2\x2\x1067\x115D\x3\x2\x2\x2\x1068\x1069\a\x8B\x2\x2");
		sb.Append("\x1069\x106A\a\x1EB\x2\x2\x106A\x106B\x5\x2F8\x17D\x2\x106B");
		sb.Append("\x106C\a\x98\x2\x2\x106C\x106D\x5\x210\x109\x2\x106D\x106E\a");
		sb.Append("\x1EC\x2\x2\x106E\x115D\x3\x2\x2\x2\x106F\x1070\t\x37\x2\x2");
		sb.Append("\x1070\x1072\x5\x2CA\x166\x2\x1071\x1073\x5\x2CE\x168\x2\x1072");
		sb.Append("\x1071\x3\x2\x2\x2\x1072\x1073\x3\x2\x2\x2\x1073\x1074\x3\x2");
		sb.Append("\x2\x2\x1074\x1075\x5\x244\x123\x2\x1075\x115D\x3\x2\x2\x2\x1076");
		sb.Append("\x1077\x5\x242\x122\x2\x1077\x1078\a\x1EB\x2\x2\x1078\x107D");
		sb.Append("\x5\x1F6\xFC\x2\x1079\x107A\a\x1F1\x2\x2\x107A\x107C\x5\x1F6");
		sb.Append("\xFC\x2\x107B\x1079\x3\x2\x2\x2\x107C\x107F\x3\x2\x2\x2\x107D");
		sb.Append("\x107B\x3\x2\x2\x2\x107D\x107E\x3\x2\x2\x2\x107E\x1081\x3\x2");
		sb.Append("\x2\x2\x107F\x107D\x3\x2\x2\x2\x1080\x1082\x5\x254\x12B\x2\x1081");
		sb.Append("\x1080\x3\x2\x2\x2\x1081\x1082\x3\x2\x2\x2\x1082\x1084\x3\x2");
		sb.Append("\x2\x2\x1083\x1085\x5\x24C\x127\x2\x1084\x1083\x3\x2\x2\x2\x1084");
		sb.Append("\x1085\x3\x2\x2\x2\x1085\x1086\x3\x2\x2\x2\x1086\x1087\a\x1EC");
		sb.Append("\x2\x2\x1087\x115D\x3\x2\x2\x2\x1088\x1089\a\x187\x2\x2\x1089");
		sb.Append("\x108A\a\x1EB\x2\x2\x108A\x108D\x5\x1F6\xFC\x2\x108B\x108C\a");
		sb.Append("\x19A\x2\x2\x108C\x108E\t\x38\x2\x2\x108D\x108B\x3\x2\x2\x2");
		sb.Append("\x108D\x108E\x3\x2\x2\x2\x108E\x1093\x3\x2\x2\x2\x108F\x1090");
		sb.Append("\a\x1F1\x2\x2\x1090\x1092\x5\x1F6\xFC\x2\x1091\x108F\x3\x2\x2");
		sb.Append("\x2\x1092\x1095\x3\x2\x2\x2\x1093\x1091\x3\x2\x2\x2\x1093\x1094");
		sb.Append("\x3\x2\x2\x2\x1094\x1096\x3\x2\x2\x2\x1095\x1093\x3\x2\x2\x2");
		sb.Append("\x1096\x1097\a\x1EC\x2\x2\x1097\x115D\x3\x2\x2\x2\x1098\x1099");
		sb.Append("\a\x188\x2\x2\x1099\x109A\a\x1EB\x2\x2\x109A\x109B\x5\x1F6\xFC");
		sb.Append("\x2\x109B\x109D\a\xF\x2\x2\x109C\x109E\a\x12F\x2\x2\x109D\x109C");
		sb.Append("\x3\x2\x2\x2\x109D\x109E\x3\x2\x2\x2\x109E\x109F\x3\x2\x2\x2");
		sb.Append("\x109F\x10A0\x5\x2D2\x16A\x2\x10A0\x10A1\a\x1EC\x2\x2\x10A1");
		sb.Append("\x115D\x3\x2\x2\x2\x10A2\x10A3\a\x18A\x2\x2\x10A3\x10AB\a\x1EB");
		sb.Append("\x2\x2\x10A4\x10A6\t\x39\x2\x2\x10A5\x10A4\x3\x2\x2\x2\x10A5");
		sb.Append("\x10A6\x3\x2\x2\x2\x10A6\x10A8\x3\x2\x2\x2\x10A7\x10A9\x5\x2E8");
		sb.Append("\x175\x2\x10A8\x10A7\x3\x2\x2\x2\x10A8\x10A9\x3\x2\x2\x2\x10A9");
		sb.Append("\x10AA\x3\x2\x2\x2\x10AA\x10AC\a\x98\x2\x2\x10AB\x10A5\x3\x2");
		sb.Append("\x2\x2\x10AB\x10AC\x3\x2\x2\x2\x10AC\x10AD\x3\x2\x2\x2\x10AD");
		sb.Append("\x10AE\x5\x210\x109\x2\x10AE\x10AF\a\x1EC\x2\x2\x10AF\x115D");
		sb.Append("\x3\x2\x2\x2\x10B0\x10B1\a\x1B1\x2\x2\x10B1\x10B2\a\x1EB\x2");
		sb.Append("\x2\x10B2\x10B4\x5\x1F6\xFC\x2\x10B3\x10B5\x5\x1A0\xD1\x2\x10B4");
		sb.Append("\x10B3\x3\x2\x2\x2\x10B4\x10B5\x3\x2\x2\x2\x10B5\x10B6\x3\x2");
		sb.Append("\x2\x2\x10B6\x10B9\a\x1EC\x2\x2\x10B7\x10B8\a\x1E4\x2\x2\x10B8");
		sb.Append("\x10BA\x5\x2DE\x170\x2\x10B9\x10B7\x3\x2\x2\x2\x10B9\x10BA\x3");
		sb.Append("\x2\x2\x2\x10BA\x115D\x3\x2\x2\x2\x10BB\x10BC\t:\x2\x2\x10BC");
		sb.Append("\x10BD\a\x1EB\x2\x2\x10BD\x10C2\x5\x260\x131\x2\x10BE\x10BF");
		sb.Append("\a\x1F1\x2\x2\x10BF\x10C1\x5\x260\x131\x2\x10C0\x10BE\x3\x2");
		sb.Append("\x2\x2\x10C1\x10C4\x3\x2\x2\x2\x10C2\x10C0\x3\x2\x2\x2\x10C2");
		sb.Append("\x10C3\x3\x2\x2\x2\x10C3\x10C5\x3\x2\x2\x2\x10C4\x10C2\x3\x2");
		sb.Append("\x2\x2\x10C5\x10C8\a\x1EC\x2\x2\x10C6\x10C7\a\x1E4\x2\x2\x10C7");
		sb.Append("\x10C9\x5\x2DE\x170\x2\x10C8\x10C6\x3\x2\x2\x2\x10C8\x10C9\x3");
		sb.Append("\x2\x2\x2\x10C9\x115D\x3\x2\x2\x2\x10CA\x10CB\a\x1B5\x2\x2\x10CB");
		sb.Append("\x10CD\a\x1EB\x2\x2\x10CC\x10CE\t;\x2\x2\x10CD\x10CC\x3\x2\x2");
		sb.Append("\x2\x10CD\x10CE\x3\x2\x2\x2\x10CE\x10D0\x3\x2\x2\x2\x10CF\x10D1");
		sb.Append("\t<\x2\x2\x10D0\x10CF\x3\x2\x2\x2\x10D0\x10D1\x3\x2\x2\x2\x10D1");
		sb.Append("\x10D2\x3\x2\x2\x2\x10D2\x10D5\x5\x1F6\xFC\x2\x10D3\x10D4\a");
		sb.Append("\x1F1\x2\x2\x10D4\x10D6\x5\x258\x12D\x2\x10D5\x10D3\x3\x2\x2");
		sb.Append("\x2\x10D5\x10D6\x3\x2\x2\x2\x10D6\x10DE\x3\x2\x2\x2\x10D7\x10D8");
		sb.Append("\a\x1F1\x2\x2\x10D8\x10DA\x5\x1F6\xFC\x2\x10D9\x10DB\x5\x27A");
		sb.Append("\x13E\x2\x10DA\x10D9\x3\x2\x2\x2\x10DA\x10DB\x3\x2\x2\x2\x10DB");
		sb.Append("\x10DD\x3\x2\x2\x2\x10DC\x10D7\x3\x2\x2\x2\x10DD\x10E0\x3\x2");
		sb.Append("\x2\x2\x10DE\x10DC\x3\x2\x2\x2\x10DE\x10DF\x3\x2\x2\x2\x10DF");
		sb.Append("\x10E1\x3\x2\x2\x2\x10E0\x10DE\x3\x2\x2\x2\x10E1\x10E4\a\x1EC");
		sb.Append("\x2\x2\x10E2\x10E3\a\x1E4\x2\x2\x10E3\x10E5\x5\x2DE\x170\x2");
		sb.Append("\x10E4\x10E2\x3\x2\x2\x2\x10E4\x10E5\x3\x2\x2\x2\x10E5\x115D");
		sb.Append("\x3\x2\x2\x2\x10E6\x10E7\a\x1B6\x2\x2\x10E7\x10E8\a\x1EB\x2");
		sb.Append("\x2\x10E8\x10EA\x5\x1F6\xFC\x2\x10E9\x10EB\x5\x256\x12C\x2\x10EA");
		sb.Append("\x10E9\x3\x2\x2\x2\x10EA\x10EB\x3\x2\x2\x2\x10EB\x10EC\x3\x2");
		sb.Append("\x2\x2\x10EC\x10ED\a\x1EC\x2\x2\x10ED\x115D\x3\x2\x2\x2\x10EE");
		sb.Append("\x10EF\a\x1B9\x2\x2\x10EF\x10F0\a\x1EB\x2\x2\x10F0\x10F1\t=");
		sb.Append("\x2\x2\x10F1\x10F3\x5\x210\x109\x2\x10F2\x10F4\a\x1A7\x2\x2");
		sb.Append("\x10F3\x10F2\x3\x2\x2\x2\x10F3\x10F4\x3\x2\x2\x2\x10F4\x10F5");
		sb.Append("\x3\x2\x2\x2\x10F5\x10F8\a\x1EC\x2\x2\x10F6\x10F7\a\x1E4\x2");
		sb.Append("\x2\x10F7\x10F9\x5\x2DE\x170\x2\x10F8\x10F6\x3\x2\x2\x2\x10F8");
		sb.Append("\x10F9\x3\x2\x2\x2\x10F9\x115D\x3\x2\x2\x2\x10FA\x10FB\a\x1BA");
		sb.Append("\x2\x2\x10FB\x1100\a\x1EB\x2\x2\x10FC\x10FD\a\xE6\x2\x2\x10FD");
		sb.Append("\x1101\x5\x2EA\x176\x2\x10FE\x10FF\a\x80\x2\x2\x10FF\x1101\x5");
		sb.Append("\x210\x109\x2\x1100\x10FC\x3\x2\x2\x2\x1100\x10FE\x3\x2\x2\x2");
		sb.Append("\x1101\x1104\x3\x2\x2\x2\x1102\x1103\a\x1F1\x2\x2\x1103\x1105");
		sb.Append("\x5\x210\x109\x2\x1104\x1102\x3\x2\x2\x2\x1104\x1105\x3\x2\x2");
		sb.Append("\x2\x1105\x1106\x3\x2\x2\x2\x1106\x1109\a\x1EC\x2\x2\x1107\x1108");
		sb.Append("\a\x1E4\x2\x2\x1108\x110A\x5\x2DE\x170\x2\x1109\x1107\x3\x2");
		sb.Append("\x2\x2\x1109\x110A\x3\x2\x2\x2\x110A\x115D\x3\x2\x2\x2\x110B");
		sb.Append("\x110C\a\x1BB\x2\x2\x110C\x110D\a\x1EB\x2\x2\x110D\x110F\x5");
		sb.Append("\x210\x109\x2\x110E\x1110\x5\x256\x12C\x2\x110F\x110E\x3\x2");
		sb.Append("\x2\x2\x110F\x1110\x3\x2\x2\x2\x1110\x1111\x3\x2\x2\x2\x1111");
		sb.Append("\x1112\a\x13B\x2\x2\x1112\x1116\aG\x2\x2\x1113\x1114\a\xFD\x2");
		sb.Append("\x2\x1114\x1115\a\x107\x2\x2\x1115\x1117\ax\x2\x2\x1116\x1113");
		sb.Append("\x3\x2\x2\x2\x1116\x1117\x3\x2\x2\x2\x1117\x1118\x3\x2\x2\x2");
		sb.Append("\x1118\x111B\a\x1EC\x2\x2\x1119\x111A\a\x1E4\x2\x2\x111A\x111C");
		sb.Append("\x5\x2DE\x170\x2\x111B\x1119\x3\x2\x2\x2\x111B\x111C\x3\x2\x2");
		sb.Append("\x2\x111C\x115D\x3\x2\x2\x2\x111D\x111E\a\x1BC\x2\x2\x111E\x111F");
		sb.Append("\a\x1EB\x2\x2\x111F\x1122\x5\x210\x109\x2\x1120\x1121\a\x1F1");
		sb.Append("\x2\x2\x1121\x1123\x5\x262\x132\x2\x1122\x1120\x3\x2\x2\x2\x1122");
		sb.Append("\x1123\x3\x2\x2\x2\x1123\x1126\x3\x2\x2\x2\x1124\x1125\a\x1F1");
		sb.Append("\x2\x2\x1125\x1127\x5\x264\x133\x2\x1126\x1124\x3\x2\x2\x2\x1126");
		sb.Append("\x1127\x3\x2\x2\x2\x1127\x1128\x3\x2\x2\x2\x1128\x112B\a\x1EC");
		sb.Append("\x2\x2\x1129\x112A\a\x1E4\x2\x2\x112A\x112C\x5\x2DE\x170\x2");
		sb.Append("\x112B\x1129\x3\x2\x2\x2\x112B\x112C\x3\x2\x2\x2\x112C\x115D");
		sb.Append("\x3\x2\x2\x2\x112D\x112E\a\x1BD\x2\x2\x112E\x112F\a\x1EB\x2");
		sb.Append("\x2\x112F\x1130\t=\x2\x2\x1130\x1133\x5\x210\x109\x2\x1131\x1132");
		sb.Append("\a\xF\x2\x2\x1132\x1134\x5\x2D2\x16A\x2\x1133\x1131\x3\x2\x2");
		sb.Append("\x2\x1133\x1134\x3\x2\x2\x2\x1134\x1136\x3\x2\x2\x2\x1135\x1137");
		sb.Append("\x5\x266\x134\x2\x1136\x1135\x3\x2\x2\x2\x1136\x1137\x3\x2\x2");
		sb.Append("\x2\x1137\x1139\x3\x2\x2\x2\x1138\x113A\x5\x268\x135\x2\x1139");
		sb.Append("\x1138\x3\x2\x2\x2\x1139\x113A\x3\x2\x2\x2\x113A\x113C\x3\x2");
		sb.Append("\x2\x2\x113B\x113D\x5\x26A\x136\x2\x113C\x113B\x3\x2\x2\x2\x113C");
		sb.Append("\x113D\x3\x2\x2\x2\x113D\x1140\x3\x2\x2\x2\x113E\x113F\t>\x2");
		sb.Append("\x2\x113F\x1141\a\x65\x2\x2\x1140\x113E\x3\x2\x2\x2\x1140\x1141");
		sb.Append("\x3\x2\x2\x2\x1141\x1142\x3\x2\x2\x2\x1142\x1145\a\x1EC\x2\x2");
		sb.Append("\x1143\x1144\a\x1E4\x2\x2\x1144\x1146\x5\x2DE\x170\x2\x1145");
		sb.Append("\x1143\x3\x2\x2\x2\x1145\x1146\x3\x2\x2\x2\x1146\x115D\x3\x2");
		sb.Append("\x2\x2\x1147\x1148\a\x1BE\x2\x2\x1148\x114A\a\x1EB\x2\x2\x1149");
		sb.Append("\x114B\x5\x25A\x12E\x2\x114A\x1149\x3\x2\x2\x2\x114A\x114B\x3");
		sb.Append("\x2\x2\x2\x114B\x114C\x3\x2\x2\x2\x114C\x114E\x5\x210\x109\x2");
		sb.Append("\x114D\x114F\x5\x256\x12C\x2\x114E\x114D\x3\x2\x2\x2\x114E\x114F");
		sb.Append("\x3\x2\x2\x2\x114F\x1155\x3\x2\x2\x2\x1150\x1151\a:\x2\x2\x1151");
		sb.Append("\x1152\x5\x25C\x12F\x2\x1152\x1153\a\x1F1\x2\x2\x1153\x1154");
		sb.Append("\x5\x25C\x12F\x2\x1154\x1156\x3\x2\x2\x2\x1155\x1150\x3\x2\x2");
		sb.Append("\x2\x1155\x1156\x3\x2\x2\x2\x1156\x1157\x3\x2\x2\x2\x1157\x115A");
		sb.Append("\a\x1EC\x2\x2\x1158\x1159\a\x1E4\x2\x2\x1159\x115B\x5\x2DE\x170");
		sb.Append("\x2\x115A\x1158\x3\x2\x2\x2\x115A\x115B\x3\x2\x2\x2\x115B\x115D");
		sb.Append("\x3\x2\x2\x2\x115C\x1022\x3\x2\x2\x2\x115C\x1027\x3\x2\x2\x2");
		sb.Append("\x115C\x102C\x3\x2\x2\x2\x115C\x1039\x3\x2\x2\x2\x115C\x1047");
		sb.Append("\x3\x2\x2\x2\x115C\x104E\x3\x2\x2\x2\x115C\x1059\x3\x2\x2\x2");
		sb.Append("\x115C\x1060\x3\x2\x2\x2\x115C\x1068\x3\x2\x2\x2\x115C\x106F");
		sb.Append("\x3\x2\x2\x2\x115C\x1076\x3\x2\x2\x2\x115C\x1088\x3\x2\x2\x2");
		sb.Append("\x115C\x1098\x3\x2\x2\x2\x115C\x10A2\x3\x2\x2\x2\x115C\x10B0");
		sb.Append("\x3\x2\x2\x2\x115C\x10BB\x3\x2\x2\x2\x115C\x10CA\x3\x2\x2\x2");
		sb.Append("\x115C\x10E6\x3\x2\x2\x2\x115C\x10EE\x3\x2\x2\x2\x115C\x10FA");
		sb.Append("\x3\x2\x2\x2\x115C\x110B\x3\x2\x2\x2\x115C\x111D\x3\x2\x2\x2");
		sb.Append("\x115C\x112D\x3\x2\x2\x2\x115C\x1147\x3\x2\x2\x2\x115D\x23D");
		sb.Append("\x3\x2\x2\x2\x115E\x115F\t?\x2\x2\x115F\x23F\x3\x2\x2\x2\x1160");
		sb.Append("\x1161\t@\x2\x2\x1161\x241\x3\x2\x2\x2\x1162\x1163\t\x41\x2");
		sb.Append("\x2\x1163\x243\x3\x2\x2\x2\x1164\x1165\a\x112\x2\x2\x1165\x1167");
		sb.Append("\a\x1EB\x2\x2\x1166\x1168\x5\x15C\xAF\x2\x1167\x1166\x3\x2\x2");
		sb.Append("\x2\x1167\x1168\x3\x2\x2\x2\x1168\x116D\x3\x2\x2\x2\x1169\x116B");
		sb.Append("\x5\x1A0\xD1\x2\x116A\x116C\x5\x246\x124\x2\x116B\x116A\x3\x2");
		sb.Append("\x2\x2\x116B\x116C\x3\x2\x2\x2\x116C\x116E\x3\x2\x2\x2\x116D");
		sb.Append("\x1169\x3\x2\x2\x2\x116D\x116E\x3\x2\x2\x2\x116E\x116F\x3\x2");
		sb.Append("\x2\x2\x116F\x1170\a\x1EC\x2\x2\x1170\x245\x3\x2\x2\x2\x1171");
		sb.Append("\x1178\x5\x248\x125\x2\x1172\x1173\a\x1C\x2\x2\x1173\x1174\x5");
		sb.Append("\x24A\x126\x2\x1174\x1175\a\f\x2\x2\x1175\x1176\x5\x24A\x126");
		sb.Append("\x2\x1176\x1179\x3\x2\x2\x2\x1177\x1179\x5\x24A\x126\x2\x1178");
		sb.Append("\x1172\x3\x2\x2\x2\x1178\x1177\x3\x2\x2\x2\x1179\x247\x3\x2");
		sb.Append("\x2\x2\x117A\x117B\t\x42\x2\x2\x117B\x249\x3\x2\x2\x2\x117C");
		sb.Append("\x117D\a\x18E\x2\x2\x117D\x1184\a\x124\x2\x2\x117E\x117F\aR");
		sb.Append("\x2\x2\x117F\x1184\a\x142\x2\x2\x1180\x1181\x5\x210\x109\x2");
		sb.Append("\x1181\x1182\t\x43\x2\x2\x1182\x1184\x3\x2\x2\x2\x1183\x117C");
		sb.Append("\x3\x2\x2\x2\x1183\x117E\x3\x2\x2\x2\x1183\x1180\x3\x2\x2\x2");
		sb.Append("\x1184\x24B\x3\x2\x2\x2\x1185\x118F\a\x19A\x2\x2\x1186\x1190");
		sb.Append("\a\x1EE\x2\x2\x1187\x118C\x5\x24E\x128\x2\x1188\x1189\a\x1F1");
		sb.Append("\x2\x2\x1189\x118B\x5\x24E\x128\x2\x118A\x1188\x3\x2\x2\x2\x118B");
		sb.Append("\x118E\x3\x2\x2\x2\x118C\x118A\x3\x2\x2\x2\x118C\x118D\x3\x2");
		sb.Append("\x2\x2\x118D\x1190\x3\x2\x2\x2\x118E\x118C\x3\x2\x2\x2\x118F");
		sb.Append("\x1186\x3\x2\x2\x2\x118F\x1187\x3\x2\x2\x2\x1190\x24D\x3\x2");
		sb.Append("\x2\x2\x1191\x1193\a\xA6\x2\x2\x1192\x1194\a\x110\x2\x2\x1193");
		sb.Append("\x1192\x3\x2\x2\x2\x1193\x1194\x3\x2\x2\x2\x1194\x1197\x3\x2");
		sb.Append("\x2\x2\x1195\x1197\a\x110\x2\x2\x1196\x1191\x3\x2\x2\x2\x1196");
		sb.Append("\x1195\x3\x2\x2\x2\x1196\x1197\x3\x2\x2\x2\x1197\x1198\x3\x2");
		sb.Append("\x2\x2\x1198\x119A\x5\x14C\xA7\x2\x1199\x119B\x5\x27A\x13E\x2");
		sb.Append("\x119A\x1199\x3\x2\x2\x2\x119A\x119B\x3\x2\x2\x2\x119B\x24F");
		sb.Append("\x3\x2\x2\x2\x119C\x119D\a\x10D\x2\x2\x119D\x119E\a(\x2\x2\x119E");
		sb.Append("\x119F\x5\x210\x109\x2\x119F\x251\x3\x2\x2\x2\x11A0\x11A1\a");
		sb.Append("\x1AD\x2\x2\x11A1\x11A2\a\x9D\x2\x2\x11A2\x11A3\a\x1EB\x2\x2");
		sb.Append("\x11A3\x11A4\x5\x1A0\xD1\x2\x11A4\x11A5\a\x1EC\x2\x2\x11A5\x11A8");
		sb.Append("\x3\x2\x2\x2\x11A6\x11A8\x5\x244\x123\x2\x11A7\x11A0\x3\x2\x2");
		sb.Append("\x2\x11A7\x11A6\x3\x2\x2\x2\x11A8\x253\x3\x2\x2\x2\x11A9\x11BB");
		sb.Append("\aM\x2\x2\x11AA\x11AC\a\xE2\x2\x2\x11AB\x11AD\a\x16\x2\x2\x11AC");
		sb.Append("\x11AB\x3\x2\x2\x2\x11AC\x11AD\x3\x2\x2\x2\x11AD\x11BC\x3\x2");
		sb.Append("\x2\x2\x11AE\x11AF\a\x1EB\x2\x2\x11AF\x11B4\x5\x288\x145\x2");
		sb.Append("\x11B0\x11B1\a\x1F1\x2\x2\x11B1\x11B3\x5\x288\x145\x2\x11B2");
		sb.Append("\x11B0\x3\x2\x2\x2\x11B3\x11B6\x3\x2\x2\x2\x11B4\x11B2\x3\x2");
		sb.Append("\x2\x2\x11B4\x11B5\x3\x2\x2\x2\x11B5\x11B7\x3\x2\x2\x2\x11B6");
		sb.Append("\x11B4\x3\x2\x2\x2\x11B7\x11B8\a\x1EC\x2\x2\x11B8\x11B9\a\x19D");
		sb.Append("\x2\x2\x11B9\x11BA\x5\x1EE\xF8\x2\x11BA\x11BC\x3\x2\x2\x2\x11BB");
		sb.Append("\x11AA\x3\x2\x2\x2\x11BB\x11AE\x3\x2\x2\x2\x11BC\x255\x3\x2");
		sb.Append("\x2\x2\x11BD\x11C0\a\x119\x2\x2\x11BE\x11BF\a(\x2\x2\x11BF\x11C1");
		sb.Append("\a\x19C\x2\x2\x11C0\x11BE\x3\x2\x2\x2\x11C0\x11C1\x3\x2\x2\x2");
		sb.Append("\x11C1\x11C2\x3\x2\x2\x2\x11C2\x11C4\x5\x1F6\xFC\x2\x11C3\x11C5");
		sb.Append("\x5\x27A\x13E\x2\x11C4\x11C3\x3\x2\x2\x2\x11C4\x11C5\x3\x2\x2");
		sb.Append("\x2\x11C5\x11C6\x3\x2\x2\x2\x11C6\x11C7\a\x1F1\x2\x2\x11C7\x11C9");
		sb.Append("\x5\x1F6\xFC\x2\x11C8\x11CA\x5\x27A\x13E\x2\x11C9\x11C8\x3\x2");
		sb.Append("\x2\x2\x11C9\x11CA\x3\x2\x2\x2\x11CA\x257\x3\x2\x2\x2\x11CB");
		sb.Append("\x11CC\a\x1B2\x2\x2\x11CC\x11CE\a\x1EB\x2\x2\x11CD\x11CF\t;");
		sb.Append("\x2\x2\x11CE\x11CD\x3\x2\x2\x2\x11CE\x11CF\x3\x2\x2\x2\x11CF");
		sb.Append("\x11D1\x3\x2\x2\x2\x11D0\x11D2\t\x44\x2\x2\x11D1\x11D0\x3\x2");
		sb.Append("\x2\x2\x11D1\x11D2\x3\x2\x2\x2\x11D2\x11D3\x3\x2\x2\x2\x11D3");
		sb.Append("\x11D8\x5\x260\x131\x2\x11D4\x11D5\a\x1F1\x2\x2\x11D5\x11D7");
		sb.Append("\x5\x260\x131\x2\x11D6\x11D4\x3\x2\x2\x2\x11D7\x11DA\x3\x2\x2");
		sb.Append("\x2\x11D8\x11D6\x3\x2\x2\x2\x11D8\x11D9\x3\x2\x2\x2\x11D9\x11DB");
		sb.Append("\x3\x2\x2\x2\x11DA\x11D8\x3\x2\x2\x2\x11DB\x11DC\a\x1EC\x2\x2");
		sb.Append("\x11DC\x259\x3\x2\x2\x2\x11DD\x11DE\a\x1B8\x2\x2\x11DE\x11E2");
		sb.Append("\a\x1EB\x2\x2\x11DF\x11E0\x5\x210\x109\x2\x11E0\x11E1\x5\x27A");
		sb.Append("\x13E\x2\x11E1\x11E3\x3\x2\x2\x2\x11E2\x11DF\x3\x2\x2\x2\x11E2");
		sb.Append("\x11E3\x3\x2\x2\x2\x11E3\x11EA\x3\x2\x2\x2\x11E4\x11E5\a\x1F1");
		sb.Append("\x2\x2\x11E5\x11E6\x5\x210\x109\x2\x11E6\x11E7\x5\x27A\x13E");
		sb.Append("\x2\x11E7\x11E9\x3\x2\x2\x2\x11E8\x11E4\x3\x2\x2\x2\x11E9\x11EC");
		sb.Append("\x3\x2\x2\x2\x11EA\x11E8\x3\x2\x2\x2\x11EA\x11EB\x3\x2\x2\x2");
		sb.Append("\x11EB\x11EE\x3\x2\x2\x2\x11EC\x11EA\x3\x2\x2\x2\x11ED\x11EF");
		sb.Append("\x5\x25E\x130\x2\x11EE\x11ED\x3\x2\x2\x2\x11EE\x11EF\x3\x2\x2");
		sb.Append("\x2\x11EF\x11F0\x3\x2\x2\x2\x11F0\x11F1\a\x1EC\x2\x2\x11F1\x25B");
		sb.Append("\x3\x2\x2\x2\x11F2\x11FD\x5\x286\x144\x2\x11F3\x11F4\a\x95\x2");
		sb.Append("\x2\x11F4\x11FE\a\x10E\x2\x2\x11F5\x11F8\x5\x2D2\x16A\x2\x11F6");
		sb.Append("\x11F7\a\x11A\x2\x2\x11F7\x11F9\x5\x210\x109\x2\x11F8\x11F6");
		sb.Append("\x3\x2\x2\x2\x11F8\x11F9\x3\x2\x2\x2\x11F9\x11FB\x3\x2\x2\x2");
		sb.Append("\x11FA\x11FC\x5\x25E\x130\x2\x11FB\x11FA\x3\x2\x2\x2\x11FB\x11FC");
		sb.Append("\x3\x2\x2\x2\x11FC\x11FE\x3\x2\x2\x2\x11FD\x11F3\x3\x2\x2\x2");
		sb.Append("\x11FD\x11F5\x3\x2\x2\x2\x11FE\x25D\x3\x2\x2\x2\x11FF\x1200");
		sb.Append("\a\x64\x2\x2\x1200\x1201\x5\x210\x109\x2\x1201\x25F\x3\x2\x2");
		sb.Append("\x2\x1202\x1209\x5\x1F4\xFB\x2\x1203\x1207\a\xF\x2\x2\x1204");
		sb.Append("\x1208\x5\x2EC\x177\x2\x1205\x1206\a\x80\x2\x2\x1206\x1208\x5");
		sb.Append("\x20E\x108\x2\x1207\x1204\x3\x2\x2\x2\x1207\x1205\x3\x2\x2\x2");
		sb.Append("\x1208\x120A\x3\x2\x2\x2\x1209\x1203\x3\x2\x2\x2\x1209\x120A");
		sb.Append("\x3\x2\x2\x2\x120A\x261\x3\x2\x2\x2\x120B\x120F\a\x1A3\x2\x2");
		sb.Append("\x120C\x120D\a\xF0\x2\x2\x120D\x1210\a\x19C\x2\x2\x120E\x1210");
		sb.Append("\x5\x1F6\xFC\x2\x120F\x120C\x3\x2\x2\x2\x120F\x120E\x3\x2\x2");
		sb.Append("\x2\x1210\x263\x3\x2\x2\x2\x1211\x1217\a\x16A\x2\x2\x1212\x1218");
		sb.Append("\a\x1C0\x2\x2\x1213\x1215\a\xF0\x2\x2\x1214\x1216\a\x19C\x2");
		sb.Append("\x2\x1215\x1214\x3\x2\x2\x2\x1215\x1216\x3\x2\x2\x2\x1216\x1218");
		sb.Append("\x3\x2\x2\x2\x1217\x1212\x3\x2\x2\x2\x1217\x1213\x3\x2\x2\x2");
		sb.Append("\x1218\x265\x3\x2\x2\x2\x1219\x121A\az\x2\x2\x121A\x121B\x5");
		sb.Append("\x210\x109\x2\x121B\x267\x3\x2\x2\x2\x121C\x121D\a\x1A3\x2\x2");
		sb.Append("\x121D\x121E\x5\x210\x109\x2\x121E\x269\x3\x2\x2\x2\x121F\x1220");
		sb.Append("\a\xF0\x2\x2\x1220\x1228\a\xAA\x2\x2\x1221\x1225\a\xAA\x2\x2");
		sb.Append("\x1222\x1223\a\x162\x2\x2\x1223\x1224\a\x202\x2\x2\x1224\x1226");
		sb.Append("\x5\x210\x109\x2\x1225\x1222\x3\x2\x2\x2\x1225\x1226\x3\x2\x2");
		sb.Append("\x2\x1226\x1228\x3\x2\x2\x2\x1227\x121F\x3\x2\x2\x2\x1227\x1221");
		sb.Append("\x3\x2\x2\x2\x1228\x26B\x3\x2\x2\x2\x1229\x1230\a\x1F2\x2\x2");
		sb.Append("\x122A\x1230\x5\x26E\x138\x2\x122B\x1230\x5\x272\x13A\x2\x122C");
		sb.Append("\x1230\x5\x274\x13B\x2\x122D\x1230\x5\x270\x139\x2\x122E\x1230");
		sb.Append("\x5\x276\x13C\x2\x122F\x1229\x3\x2\x2\x2\x122F\x122A\x3\x2\x2");
		sb.Append("\x2\x122F\x122B\x3\x2\x2\x2\x122F\x122C\x3\x2\x2\x2\x122F\x122D");
		sb.Append("\x3\x2\x2\x2\x122F\x122E\x3\x2\x2\x2\x1230\x1232\x3\x2\x2\x2");
		sb.Append("\x1231\x1233\a\x1F7\x2\x2\x1232\x1231\x3\x2\x2\x2\x1232\x1233");
		sb.Append("\x3\x2\x2\x2\x1233\x26D\x3\x2\x2\x2\x1234\x1235\a\x1A9\x2\x2");
		sb.Append("\x1235\x123B\t\x45\x2\x2\x1236\x1237\a\x88\x2\x2\x1237\x1238");
		sb.Append("\t\x46\x2\x2\x1238\x123C\tG\x2\x2\x1239\x123A\aI\x2\x2\x123A");
		sb.Append("\x123C\tH\x2\x2\x123B\x1236\x3\x2\x2\x2\x123B\x1239\x3\x2\x2");
		sb.Append("\x2\x123C\x26F\x3\x2\x2\x2\x123D\x123E\a\x158\x2\x2\x123E\x1244");
		sb.Append("\x5\x2F8\x17D\x2\x123F\x1245\a\x1E7\x2\x2\x1240\x1245\a\x107");
		sb.Append("\x2\x2\x1241\x1245\a\x104\x2\x2\x1242\x1245\x5\x2E4\x173\x2");
		sb.Append("\x1243\x1245\x5\x2F8\x17D\x2\x1244\x123F\x3\x2\x2\x2\x1244\x1240");
		sb.Append("\x3\x2\x2\x2\x1244\x1241\x3\x2\x2\x2\x1244\x1242\x3\x2\x2\x2");
		sb.Append("\x1244\x1243\x3\x2\x2\x2\x1245\x271\x3\x2\x2\x2\x1246\x1247");
		sb.Append("\a\x88\x2\x2\x1247\x273\x3\x2\x2\x2\x1248\x1249\a\x209\x2\x2");
		sb.Append("\x1249\x275\x3\x2\x2\x2\x124A\x124B\a\x15C\x2\x2\x124B\x124F");
		sb.Append("\a}\x2\x2\x124C\x124D\a\x15C\x2\x2\x124D\x124F\a~\x2\x2\x124E");
		sb.Append("\x124A\x3\x2\x2\x2\x124E\x124C\x3\x2\x2\x2\x124F\x277\x3\x2");
		sb.Append("\x2\x2\x1250\x1252\tI\x2\x2\x1251\x1253\a\x95\x2\x2\x1252\x1251");
		sb.Append("\x3\x2\x2\x2\x1252\x1253\x3\x2\x2\x2\x1253\x1254\x3\x2\x2\x2");
		sb.Append("\x1254\x1255\x5\x1EE\xF8\x2\x1255\x279\x3\x2\x2\x2\x1256\x1258");
		sb.Append("\a\xF\x2\x2\x1257\x1256\x3\x2\x2\x2\x1257\x1258\x3\x2\x2\x2");
		sb.Append("\x1258\x125B\x3\x2\x2\x2\x1259\x125C\x5\x2EA\x176\x2\x125A\x125C");
		sb.Append("\x5\x27E\x140\x2\x125B\x1259\x3\x2\x2\x2\x125B\x125A\x3\x2\x2");
		sb.Append("\x2\x125C\x125F\x3\x2\x2\x2\x125D\x125F\a\xF\x2\x2\x125E\x1257");
		sb.Append("\x3\x2\x2\x2\x125E\x125D\x3\x2\x2\x2\x125F\x27B\x3\x2\x2\x2");
		sb.Append("\x1260\x1263\x5\x2EA\x176\x2\x1261\x1263\x5\x27E\x140\x2\x1262");
		sb.Append("\x1260\x3\x2\x2\x2\x1262\x1261\x3\x2\x2\x2\x1263\x27D\x3\x2");
		sb.Append("\x2\x2\x1264\x1265\x5\x2E8\x175\x2\x1265\x27F\x3\x2\x2\x2\x1266");
		sb.Append("\x1269\a\x1AA\x2\x2\x1267\x126A\x5\x282\x142\x2\x1268\x126A");
		sb.Append("\x5\x1F2\xFA\x2\x1269\x1267\x3\x2\x2\x2\x1269\x1268\x3\x2\x2");
		sb.Append("\x2\x126A\x281\x3\x2\x2\x2\x126B\x126C\aR\x2\x2\x126C\x126D");
		sb.Append("\a\x103\x2\x2\x126D\x126E\x5\x2B8\x15D\x2\x126E\x283\x3\x2\x2");
		sb.Append("\x2\x126F\x1270\a\xBA\x2\x2\x1270\x1275\x5\x2B4\x15B\x2\x1271");
		sb.Append("\x1272\a\x1F1\x2\x2\x1272\x1274\x5\x2B4\x15B\x2\x1273\x1271");
		sb.Append("\x3\x2\x2\x2\x1274\x1277\x3\x2\x2\x2\x1275\x1273\x3\x2\x2\x2");
		sb.Append("\x1275\x1276\x3\x2\x2\x2\x1276\x1284\x3\x2\x2\x2\x1277\x1275");
		sb.Append("\x3\x2\x2\x2\x1278\x1279\a\'\x2\x2\x1279\x127A\a\x39\x2\x2\x127A");
		sb.Append("\x127B\a\xBA\x2\x2\x127B\x1280\x5\x2B4\x15B\x2\x127C\x127D\a");
		sb.Append("\x1F1\x2\x2\x127D\x127F\x5\x2B4\x15B\x2\x127E\x127C\x3\x2\x2");
		sb.Append("\x2\x127F\x1282\x3\x2\x2\x2\x1280\x127E\x3\x2\x2\x2\x1280\x1281");
		sb.Append("\x3\x2\x2\x2\x1281\x1284\x3\x2\x2\x2\x1282\x1280\x3\x2\x2\x2");
		sb.Append("\x1283\x126F\x3\x2\x2\x2\x1283\x1278\x3\x2\x2\x2\x1284\x285");
		sb.Append("\x3\x2\x2\x2\x1285\x1288\x5\x2EA\x176\x2\x1286\x1288\x5\x2E8");
		sb.Append("\x175\x2\x1287\x1285\x3\x2\x2\x2\x1287\x1286\x3\x2\x2\x2\x1288");
		sb.Append("\x287\x3\x2\x2\x2\x1289\x128A\x5\x2EA\x176\x2\x128A\x289\x3");
		sb.Append("\x2\x2\x2\x128B\x128C\x5\x2EA\x176\x2\x128C\x28B\x3\x2\x2\x2");
		sb.Append("\x128D\x128E\x5\x2EA\x176\x2\x128E\x28D\x3\x2\x2\x2\x128F\x1290");
		sb.Append("\x5\x2EA\x176\x2\x1290\x28F\x3\x2\x2\x2\x1291\x1292\x5\x2EA");
		sb.Append("\x176\x2\x1292\x291\x3\x2\x2\x2\x1293\x1294\x5\x2EA\x176\x2");
		sb.Append("\x1294\x293\x3\x2\x2\x2\x1295\x129A\x5\x2EA\x176\x2\x1296\x1297");
		sb.Append("\a\x1E4\x2\x2\x1297\x1299\x5\x2EC\x177\x2\x1298\x1296\x3\x2");
		sb.Append("\x2\x2\x1299\x129C\x3\x2\x2\x2\x129A\x1298\x3\x2\x2\x2\x129A");
		sb.Append("\x129B\x3\x2\x2\x2\x129B\x129F\x3\x2\x2\x2\x129C\x129A\x3\x2");
		sb.Append("\x2\x2\x129D\x129E\a\x1F3\x2\x2\x129E\x12A0\x5\x2BE\x160\x2");
		sb.Append("\x129F\x129D\x3\x2\x2\x2\x129F\x12A0\x3\x2\x2\x2\x12A0\x295");
		sb.Append("\x3\x2\x2\x2\x12A1\x12A2\x5\x2EA\x176\x2\x12A2\x297\x3\x2\x2");
		sb.Append("\x2\x12A3\x12A6\x5\x2EA\x176\x2\x12A4\x12A5\a\x1E4\x2\x2\x12A5");
		sb.Append("\x12A7\x5\x2EC\x177\x2\x12A6\x12A4\x3\x2\x2\x2\x12A6\x12A7\x3");
		sb.Append("\x2\x2\x2\x12A7\x299\x3\x2\x2\x2\x12A8\x12A9\x5\x2EA\x176\x2");
		sb.Append("\x12A9\x29B\x3\x2\x2\x2\x12AA\x12AB\x5\x2EA\x176\x2\x12AB\x29D");
		sb.Append("\x3\x2\x2\x2\x12AC\x12AD\x5\x2EA\x176\x2\x12AD\x29F\x3\x2\x2");
		sb.Append("\x2\x12AE\x12B3\x5\x2EA\x176\x2\x12AF\x12B0\a\x1E4\x2\x2\x12B0");
		sb.Append("\x12B2\x5\x2EC\x177\x2\x12B1\x12AF\x3\x2\x2\x2\x12B2\x12B5\x3");
		sb.Append("\x2\x2\x2\x12B3\x12B1\x3\x2\x2\x2\x12B3\x12B4\x3\x2\x2\x2\x12B4");
		sb.Append("\x2A1\x3\x2\x2\x2\x12B5\x12B3\x3\x2\x2\x2\x12B6\x12B7\x5\x2EA");
		sb.Append("\x176\x2\x12B7\x2A3\x3\x2\x2\x2\x12B8\x12BD\x5\x2EA\x176\x2");
		sb.Append("\x12B9\x12BA\a\x1E4\x2\x2\x12BA\x12BC\x5\x2EC\x177\x2\x12BB");
		sb.Append("\x12B9\x3\x2\x2\x2\x12BC\x12BF\x3\x2\x2\x2\x12BD\x12BB\x3\x2");
		sb.Append("\x2\x2\x12BD\x12BE\x3\x2\x2\x2\x12BE\x12C2\x3\x2\x2\x2\x12BF");
		sb.Append("\x12BD\x3\x2\x2\x2\x12C0\x12C1\a\x1F3\x2\x2\x12C1\x12C3\x5\x2BE");
		sb.Append("\x160\x2\x12C2\x12C0\x3\x2\x2\x2\x12C2\x12C3\x3\x2\x2\x2\x12C3");
		sb.Append("\x2A5\x3\x2\x2\x2\x12C4\x12C5\x5\x2EC\x177\x2\x12C5\x2A7\x3");
		sb.Append("\x2\x2\x2\x12C6\x12CB\x5\x2EC\x177\x2\x12C7\x12C8\a\x1E4\x2");
		sb.Append("\x2\x12C8\x12CA\x5\x2EC\x177\x2\x12C9\x12C7\x3\x2\x2\x2\x12CA");
		sb.Append("\x12CD\x3\x2\x2\x2\x12CB\x12C9\x3\x2\x2\x2\x12CB\x12CC\x3\x2");
		sb.Append("\x2\x2\x12CC\x2A9\x3\x2\x2\x2\x12CD\x12CB\x3\x2\x2\x2\x12CE");
		sb.Append("\x12D3\x5\x2EC\x177\x2\x12CF\x12D0\a\x1E4\x2\x2\x12D0\x12D2");
		sb.Append("\x5\x2EC\x177\x2\x12D1\x12CF\x3\x2\x2\x2\x12D2\x12D5\x3\x2\x2");
		sb.Append("\x2\x12D3\x12D1\x3\x2\x2\x2\x12D3\x12D4\x3\x2\x2\x2\x12D4\x2AB");
		sb.Append("\x3\x2\x2\x2\x12D5\x12D3\x3\x2\x2\x2\x12D6\x12DB\x5\x2EA\x176");
		sb.Append("\x2\x12D7\x12D8\a\x1E4\x2\x2\x12D8\x12DA\x5\x2EC\x177\x2\x12D9");
		sb.Append("\x12D7\x3\x2\x2\x2\x12DA\x12DD\x3\x2\x2\x2\x12DB\x12D9\x3\x2");
		sb.Append("\x2\x2\x12DB\x12DC\x3\x2\x2\x2\x12DC\x2AD\x3\x2\x2\x2\x12DD");
		sb.Append("\x12DB\x3\x2\x2\x2\x12DE\x12E1\x5\x2EA\x176\x2\x12DF\x12E0\a");
		sb.Append("\x1E4\x2\x2\x12E0\x12E2\x5\x2EC\x177\x2\x12E1\x12DF\x3\x2\x2");
		sb.Append("\x2\x12E1\x12E2\x3\x2\x2\x2\x12E2\x2AF\x3\x2\x2\x2\x12E3\x12E6");
		sb.Append("\x5\x2EA\x176\x2\x12E4\x12E5\a\x1E4\x2\x2\x12E5\x12E7\x5\x2EC");
		sb.Append("\x177\x2\x12E6\x12E4\x3\x2\x2\x2\x12E6\x12E7\x3\x2\x2\x2\x12E7");
		sb.Append("\x2B1\x3\x2\x2\x2\x12E8\x12EB\x5\x2EA\x176\x2\x12E9\x12EA\a");
		sb.Append("\x1E4\x2\x2\x12EA\x12EC\x5\x2EC\x177\x2\x12EB\x12E9\x3\x2\x2");
		sb.Append("\x2\x12EB\x12EC\x3\x2\x2\x2\x12EC\x2B3\x3\x2\x2\x2\x12ED\x12EE");
		sb.Append("\a\x205\x2\x2\x12EE\x12F0\x5\x2C4\x163\x2\x12EF\x12ED\x3\x2");
		sb.Append("\x2\x2\x12EF\x12F0\x3\x2\x2\x2\x12F0\x12F1\x3\x2\x2\x2\x12F1");
		sb.Append("\x12F4\x5\x2EC\x177\x2\x12F2\x12F3\a\x1E4\x2\x2\x12F3\x12F5");
		sb.Append("\x5\x2EC\x177\x2\x12F4\x12F2\x3\x2\x2\x2\x12F4\x12F5\x3\x2\x2");
		sb.Append("\x2\x12F5\x12F8\x3\x2\x2\x2\x12F6\x12F8\x5\x2DA\x16E\x2\x12F7");
		sb.Append("\x12EF\x3\x2\x2\x2\x12F7\x12F6\x3\x2\x2\x2\x12F8\x2B5\x3\x2");
		sb.Append("\x2\x2\x12F9\x12FA\x5\x2EA\x176\x2\x12FA\x2B7\x3\x2\x2\x2\x12FB");
		sb.Append("\x12FE\x5\x2EA\x176\x2\x12FC\x12FE\x5\x2DA\x16E\x2\x12FD\x12FB");
		sb.Append("\x3\x2\x2\x2\x12FD\x12FC\x3\x2\x2\x2\x12FE\x2B9\x3\x2\x2\x2");
		sb.Append("\x12FF\x1302\x5\x2EA\x176\x2\x1300\x1302\x5\x2DA\x16E\x2\x1301");
		sb.Append("\x12FF\x3\x2\x2\x2\x1301\x1300\x3\x2\x2\x2\x1302\x2BB\x3\x2");
		sb.Append("\x2\x2\x1303\x1306\x5\x2EA\x176\x2\x1304\x1305\a\x1E4\x2\x2");
		sb.Append("\x1305\x1307\x5\x2EC\x177\x2\x1306\x1304\x3\x2\x2\x2\x1306\x1307");
		sb.Append("\x3\x2\x2\x2\x1307\x2BD\x3\x2\x2\x2\x1308\x1309\x5\x2EA\x176");
		sb.Append("\x2\x1309\x2BF\x3\x2\x2\x2\x130A\x130F\x5\x2EA\x176\x2\x130B");
		sb.Append("\x130C\a\x1E4\x2\x2\x130C\x130E\x5\x2EC\x177\x2\x130D\x130B");
		sb.Append("\x3\x2\x2\x2\x130E\x1311\x3\x2\x2\x2\x130F\x130D\x3\x2\x2\x2");
		sb.Append("\x130F\x1310\x3\x2\x2\x2\x1310\x2C1\x3\x2\x2\x2\x1311\x130F");
		sb.Append("\x3\x2\x2\x2\x1312\x1315\x5\x2EA\x176\x2\x1313\x1314\a\x1E4");
		sb.Append("\x2\x2\x1314\x1316\x5\x2EC\x177\x2\x1315\x1313\x3\x2\x2\x2\x1315");
		sb.Append("\x1316\x3\x2\x2\x2\x1316\x131A\x3\x2\x2\x2\x1317\x1318\a\x1F3");
		sb.Append("\x2\x2\x1318\x131B\x5\x2BE\x160\x2\x1319\x131B\x5\x278\x13D");
		sb.Append("\x2\x131A\x1317\x3\x2\x2\x2\x131A\x1319\x3\x2\x2\x2\x131A\x131B");
		sb.Append("\x3\x2\x2\x2\x131B\x2C3\x3\x2\x2\x2\x131C\x1321\x5\x2EC\x177");
		sb.Append("\x2\x131D\x131E\a\x1E4\x2\x2\x131E\x1320\x5\x2EC\x177\x2\x131F");
		sb.Append("\x131D\x3\x2\x2\x2\x1320\x1323\x3\x2\x2\x2\x1321\x131F\x3\x2");
		sb.Append("\x2\x2\x1321\x1322\x3\x2\x2\x2\x1322\x2C5\x3\x2\x2\x2\x1323");
		sb.Append("\x1321\x3\x2\x2\x2\x1324\x1325\a\xC1\x2\x2\x1325\x1326\a\x1EB");
		sb.Append("\x2\x2\x1326\x1327\a\x1CA\x2\x2\x1327\x1328\t+\x2\x2\x1328\x1329");
		sb.Append("\x5\x1A0\xD1\x2\x1329\x132B\a\x1EC\x2\x2\x132A\x132C\x5\x244");
		sb.Append("\x123\x2\x132B\x132A\x3\x2\x2\x2\x132B\x132C\x3\x2\x2\x2\x132C");
		sb.Append("\x2C7\x3\x2\x2\x2\x132D\x132F\a\x1EB\x2\x2\x132E\x1330\x5\x2D0");
		sb.Append("\x169\x2\x132F\x132E\x3\x2\x2\x2\x132F\x1330\x3\x2\x2\x2\x1330");
		sb.Append("\x1335\x3\x2\x2\x2\x1331\x1332\a\x1F1\x2\x2\x1332\x1334\x5\x2D0");
		sb.Append("\x169\x2\x1333\x1331\x3\x2\x2\x2\x1334\x1337\x3\x2\x2\x2\x1335");
		sb.Append("\x1333\x3\x2\x2\x2\x1335\x1336\x3\x2\x2\x2\x1336\x1338\x3\x2");
		sb.Append("\x2\x2\x1337\x1335\x3\x2\x2\x2\x1338\x133A\a\x1EC\x2\x2\x1339");
		sb.Append("\x133B\x5\x2C6\x164\x2\x133A\x1339\x3\x2\x2\x2\x133A\x133B\x3");
		sb.Append("\x2\x2\x2\x133B\x2C9\x3\x2\x2\x2\x133C\x1341\a\x1EB\x2\x2\x133D");
		sb.Append("\x133F\x5\x2D0\x169\x2\x133E\x1340\x5\x2CE\x168\x2\x133F\x133E");
		sb.Append("\x3\x2\x2\x2\x133F\x1340\x3\x2\x2\x2\x1340\x1342\x3\x2\x2\x2");
		sb.Append("\x1341\x133D\x3\x2\x2\x2\x1341\x1342\x3\x2\x2\x2\x1342\x134A");
		sb.Append("\x3\x2\x2\x2\x1343\x1344\a\x1F1\x2\x2\x1344\x1346\x5\x2D0\x169");
		sb.Append("\x2\x1345\x1347\x5\x2CE\x168\x2\x1346\x1345\x3\x2\x2\x2\x1346");
		sb.Append("\x1347\x3\x2\x2\x2\x1347\x1349\x3\x2\x2\x2\x1348\x1343\x3\x2");
		sb.Append("\x2\x2\x1349\x134C\x3\x2\x2\x2\x134A\x1348\x3\x2\x2\x2\x134A");
		sb.Append("\x134B\x3\x2\x2\x2\x134B\x134D\x3\x2\x2\x2\x134C\x134A\x3\x2");
		sb.Append("\x2\x2\x134D\x134F\a\x1EC\x2\x2\x134E\x1350\x5\x2C6\x164\x2");
		sb.Append("\x134F\x134E\x3\x2\x2\x2\x134F\x1350\x3\x2\x2\x2\x1350\x2CB");
		sb.Append("\x3\x2\x2\x2\x1351\x1352\a\x1EB\x2\x2\x1352\x135F\x5\x2C0\x161");
		sb.Append("\x2\x1353\x1356\a\x1F1\x2\x2\x1354\x1357\x5\x2E4\x173\x2\x1355");
		sb.Append("\x1357\a\xFD\x2\x2\x1356\x1354\x3\x2\x2\x2\x1356\x1355\x3\x2");
		sb.Append("\x2\x2\x1357\x135D\x3\x2\x2\x2\x1358\x135B\a\x1F1\x2\x2\x1359");
		sb.Append("\x135C\x5\x2E4\x173\x2\x135A\x135C\a\xFD\x2\x2\x135B\x1359\x3");
		sb.Append("\x2\x2\x2\x135B\x135A\x3\x2\x2\x2\x135C\x135E\x3\x2\x2\x2\x135D");
		sb.Append("\x1358\x3\x2\x2\x2\x135D\x135E\x3\x2\x2\x2\x135E\x1360\x3\x2");
		sb.Append("\x2\x2\x135F\x1353\x3\x2\x2\x2\x135F\x1360\x3\x2\x2\x2\x1360");
		sb.Append("\x1361\x3\x2\x2\x2\x1361\x1375\a\x19A\x2\x2\x1362\x1363\x5\x2C2");
		sb.Append("\x162\x2\x1363\x1364\a\x1E4\x2\x2\x1364\x1365\a\x1EE\x2\x2\x1365");
		sb.Append("\x1376\x3\x2\x2\x2\x1366\x1376\a\x1EE\x2\x2\x1367\x1369\x5\x1F4");
		sb.Append("\xFB\x2\x1368\x136A\x5\x27A\x13E\x2\x1369\x1368\x3\x2\x2\x2");
		sb.Append("\x1369\x136A\x3\x2\x2\x2\x136A\x1372\x3\x2\x2\x2\x136B\x136C");
		sb.Append("\a\x1F1\x2\x2\x136C\x136E\x5\x1F4\xFB\x2\x136D\x136F\x5\x27A");
		sb.Append("\x13E\x2\x136E\x136D\x3\x2\x2\x2\x136E\x136F\x3\x2\x2\x2\x136F");
		sb.Append("\x1371\x3\x2\x2\x2\x1370\x136B\x3\x2\x2\x2\x1371\x1374\x3\x2");
		sb.Append("\x2\x2\x1372\x1370\x3\x2\x2\x2\x1372\x1373\x3\x2\x2\x2\x1373");
		sb.Append("\x1376\x3\x2\x2\x2\x1374\x1372\x3\x2\x2\x2\x1375\x1362\x3\x2");
		sb.Append("\x2\x2\x1375\x1366\x3\x2\x2\x2\x1375\x1367\x3\x2\x2\x2\x1376");
		sb.Append("\x1377\x3\x2\x2\x2\x1377\x1379\a\x1EC\x2\x2\x1378\x137A\x5\x2C6");
		sb.Append("\x164\x2\x1379\x1378\x3\x2\x2\x2\x1379\x137A\x3\x2\x2\x2\x137A");
		sb.Append("\x2CD\x3\x2\x2\x2\x137B\x137C\tJ\x2\x2\x137C\x137D\a\xFE\x2");
		sb.Append("\x2\x137D\x2CF\x3\x2\x2\x2\x137E\x137F\x5\x2EA\x176\x2\x137F");
		sb.Append("\x1380\a\x202\x2\x2\x1380\x1381\a\x1FF\x2\x2\x1381\x1383\x3");
		sb.Append("\x2\x2\x2\x1382\x137E\x3\x2\x2\x2\x1382\x1383\x3\x2\x2\x2\x1383");
		sb.Append("\x1384\x3\x2\x2\x2\x1384\x1385\x5\x1F6\xFC\x2\x1385\x2D1\x3");
		sb.Append("\x2\x2\x2\x1386\x138F\x5\x2D4\x16B\x2\x1387\x1389\a\x12F\x2");
		sb.Append("\x2\x1388\x1387\x3\x2\x2\x2\x1388\x1389\x3\x2\x2\x2\x1389\x138A");
		sb.Append("\x3\x2\x2\x2\x138A\x138C\x5\x2A8\x155\x2\x138B\x138D\t\x17\x2");
		sb.Append("\x2\x138C\x138B\x3\x2\x2\x2\x138C\x138D\x3\x2\x2\x2\x138D\x138F");
		sb.Append("\x3\x2\x2\x2\x138E\x1386\x3\x2\x2\x2\x138E\x1388\x3\x2\x2\x2");
		sb.Append("\x138F\x2D3\x3\x2\x2\x2\x1390\x1392\x5\x2D8\x16D\x2\x1391\x1393");
		sb.Append("\x5\x2D6\x16C\x2\x1392\x1391\x3\x2\x2\x2\x1392\x1393\x3\x2\x2");
		sb.Append("\x2\x1393\x139A\x3\x2\x2\x2\x1394\x1396\a\x1AC\x2\x2\x1395\x1397");
		sb.Append("\a\xCE\x2\x2\x1396\x1395\x3\x2\x2\x2\x1396\x1397\x3\x2\x2\x2");
		sb.Append("\x1397\x1398\x3\x2\x2\x2\x1398\x1399\a\x17B\x2\x2\x1399\x139B");
		sb.Append("\a\x1C2\x2\x2\x139A\x1394\x3\x2\x2\x2\x139A\x139B\x3\x2\x2\x2");
		sb.Append("\x139B\x13AD\x3\x2\x2\x2\x139C\x139D\a\xB9\x2\x2\x139D\x13A2");
		sb.Append("\tK\x2\x2\x139E\x139F\a\x1EB\x2\x2\x139F\x13A0\x5\x1F6\xFC\x2");
		sb.Append("\x13A0\x13A1\a\x1EC\x2\x2\x13A1\x13A3\x3\x2\x2\x2\x13A2\x139E");
		sb.Append("\x3\x2\x2\x2\x13A2\x13A3\x3\x2\x2\x2\x13A3\x13A4\x3\x2\x2\x2");
		sb.Append("\x13A4\x13A5\a\x184\x2\x2\x13A5\x13AA\tL\x2\x2\x13A6\x13A7\a");
		sb.Append("\x1EB\x2\x2\x13A7\x13A8\x5\x1F6\xFC\x2\x13A8\x13A9\a\x1EC\x2");
		sb.Append("\x2\x13A9\x13AB\x3\x2\x2\x2\x13AA\x13A6\x3\x2\x2\x2\x13AA\x13AB");
		sb.Append("\x3\x2\x2\x2\x13AB\x13AD\x3\x2\x2\x2\x13AC\x1390\x3\x2\x2\x2");
		sb.Append("\x13AC\x139C\x3\x2\x2\x2\x13AD\x2D5\x3\x2\x2\x2\x13AE\x13AF");
		sb.Append("\a\x1EB\x2\x2\x13AF\x13B2\x5\x2E4\x173\x2\x13B0\x13B1\a\x1F1");
		sb.Append("\x2\x2\x13B1\x13B3\x5\x2E4\x173\x2\x13B2\x13B0\x3\x2\x2\x2\x13B2");
		sb.Append("\x13B3\x3\x2\x2\x2\x13B3\x13B5\x3\x2\x2\x2\x13B4\x13B6\tM\x2");
		sb.Append("\x2\x13B5\x13B4\x3\x2\x2\x2\x13B5\x13B6\x3\x2\x2\x2\x13B6\x13B7");
		sb.Append("\x3\x2\x2\x2\x13B7\x13B8\a\x1EC\x2\x2\x13B8\x2D7\x3\x2\x2\x2");
		sb.Append("\x13B9\x13F6\a \x2\x2\x13BA\x13F6\a\x120\x2\x2\x13BB\x13F6\a");
		sb.Append("\xE8\x2\x2\x13BC\x13F6\a\x1F\x2\x2\x13BD\x13F6\a\x1E\x2\x2\x13BE");
		sb.Append("\x13F6\a\xE9\x2\x2\x13BF\x13F6\a\x121\x2\x2\x13C0\x13F6\a\x122");
		sb.Append("\x2\x2\x13C1\x13F6\a\x15F\x2\x2\x13C2\x13F6\a\x160\x2\x2\x13C3");
		sb.Append("\x13F6\a\x101\x2\x2\x13C4\x13F6\a_\x2\x2\x13C5\x13F6\a\xB7\x2");
		sb.Append("\x2\x13C6\x13F6\a\xB6\x2\x2\x13C7\x13F6\a\x100\x2\x2\x13C8\x13F6");
		sb.Append("\a\x164\x2\x2\x13C9\x13F6\a\xFF\x2\x2\x13CA\x13F6\a`\x2\x2\x13CB");
		sb.Append("\x13CD\aq\x2\x2\x13CC\x13CE\a\x125\x2\x2\x13CD\x13CC\x3\x2\x2");
		sb.Append("\x2\x13CD\x13CE\x3\x2\x2\x2\x13CE\x13F6\x3\x2\x2\x2\x13CF\x13F6");
		sb.Append("\a\x92\x2\x2\x13D0\x13F6\a\x12D\x2\x2\x13D1\x13F6\a\xEB\x2\x2");
		sb.Append("\x13D2\x13D4\a\xD4\x2\x2\x13D3\x13D5\a\x12B\x2\x2\x13D4\x13D3");
		sb.Append("\x3\x2\x2\x2\x13D4\x13D5\x3\x2\x2\x2\x13D5\x13F6\x3\x2\x2\x2");
		sb.Append("\x13D6\x13F6\a\x31\x2\x2\x13D7\x13F6\a\x33\x2\x2\x13D8\x13F6");
		sb.Append("\a\x19F\x2\x2\x13D9\x13F6\a\x19E\x2\x2\x13DA\x13F6\a\x171\x2");
		sb.Append("\x2\x13DB\x13F6\a\x12B\x2\x2\x13DC\x13F6\a$\x2\x2\x13DD\x13F6");
		sb.Append("\aY\x2\x2\x13DE\x13F6\a\x143\x2\x2\x13DF\x13F6\a\x198\x2\x2");
		sb.Append("\x13E0\x13F6\a\x1BF\x2\x2\x13E1\x13F6\a\xE4\x2\x2\x13E2\x13F6");
		sb.Append("\aZ\x2\x2\x13E3\x13F6\a\xA2\x2\x2\x13E4\x13F6\a\xDE\x2\x2\x13E5");
		sb.Append("\x13F6\a\x14D\x2\x2\x13E6\x13F6\a\x181\x2\x2\x13E7\x13F6\a\x182");
		sb.Append("\x2\x2\x13E8\x13F6\a\x183\x2\x2\x13E9\x13F6\a\x180\x2\x2\x13EA");
		sb.Append("\x13F6\a\x17C\x2\x2\x13EB\x13F6\a\x17F\x2\x2\x13EC\x13F6\a\x17E");
		sb.Append("\x2\x2\x13ED\x13F6\a\x17D\x2\x2\x13EE\x13F6\a\x1C1\x2\x2\x13EF");
		sb.Append("\x13F6\as\x2\x2\x13F0\x13F6\a\x1D\x2\x2\x13F1\x13F6\a!\x2\x2");
		sb.Append("\x13F2\x13F6\a\x36\x2\x2\x13F3\x13F6\a\xED\x2\x2\x13F4\x13F6");
		sb.Append("\a\xE0\x2\x2\x13F5\x13B9\x3\x2\x2\x2\x13F5\x13BA\x3\x2\x2\x2");
		sb.Append("\x13F5\x13BB\x3\x2\x2\x2\x13F5\x13BC\x3\x2\x2\x2\x13F5\x13BD");
		sb.Append("\x3\x2\x2\x2\x13F5\x13BE\x3\x2\x2\x2\x13F5\x13BF\x3\x2\x2\x2");
		sb.Append("\x13F5\x13C0\x3\x2\x2\x2\x13F5\x13C1\x3\x2\x2\x2\x13F5\x13C2");
		sb.Append("\x3\x2\x2\x2\x13F5\x13C3\x3\x2\x2\x2\x13F5\x13C4\x3\x2\x2\x2");
		sb.Append("\x13F5\x13C5\x3\x2\x2\x2\x13F5\x13C6\x3\x2\x2\x2\x13F5\x13C7");
		sb.Append("\x3\x2\x2\x2\x13F5\x13C8\x3\x2\x2\x2\x13F5\x13C9\x3\x2\x2\x2");
		sb.Append("\x13F5\x13CA\x3\x2\x2\x2\x13F5\x13CB\x3\x2\x2\x2\x13F5\x13CF");
		sb.Append("\x3\x2\x2\x2\x13F5\x13D0\x3\x2\x2\x2\x13F5\x13D1\x3\x2\x2\x2");
		sb.Append("\x13F5\x13D2\x3\x2\x2\x2\x13F5\x13D6\x3\x2\x2\x2\x13F5\x13D7");
		sb.Append("\x3\x2\x2\x2\x13F5\x13D8\x3\x2\x2\x2\x13F5\x13D9\x3\x2\x2\x2");
		sb.Append("\x13F5\x13DA\x3\x2\x2\x2\x13F5\x13DB\x3\x2\x2\x2\x13F5\x13DC");
		sb.Append("\x3\x2\x2\x2\x13F5\x13DD\x3\x2\x2\x2\x13F5\x13DE\x3\x2\x2\x2");
		sb.Append("\x13F5\x13DF\x3\x2\x2\x2\x13F5\x13E0\x3\x2\x2\x2\x13F5\x13E1");
		sb.Append("\x3\x2\x2\x2\x13F5\x13E2\x3\x2\x2\x2\x13F5\x13E3\x3\x2\x2\x2");
		sb.Append("\x13F5\x13E4\x3\x2\x2\x2\x13F5\x13E5\x3\x2\x2\x2\x13F5\x13E6");
		sb.Append("\x3\x2\x2\x2\x13F5\x13E7\x3\x2\x2\x2\x13F5\x13E8\x3\x2\x2\x2");
		sb.Append("\x13F5\x13E9\x3\x2\x2\x2\x13F5\x13EA\x3\x2\x2\x2\x13F5\x13EB");
		sb.Append("\x3\x2\x2\x2\x13F5\x13EC\x3\x2\x2\x2\x13F5\x13ED\x3\x2\x2\x2");
		sb.Append("\x13F5\x13EE\x3\x2\x2\x2\x13F5\x13EF\x3\x2\x2\x2\x13F5\x13F0");
		sb.Append("\x3\x2\x2\x2\x13F5\x13F1\x3\x2\x2\x2\x13F5\x13F2\x3\x2\x2\x2");
		sb.Append("\x13F5\x13F3\x3\x2\x2\x2\x13F5\x13F4\x3\x2\x2\x2\x13F6\x2D9");
		sb.Append("\x3\x2\x2\x2\x13F7\x13FB\a\x1F5\x2\x2\x13F8\x13F9\a\x1F6\x2");
		sb.Append("\x2\x13F9\x13FB\a\x1E5\x2\x2\x13FA\x13F7\x3\x2\x2\x2\x13FA\x13F8");
		sb.Append("\x3\x2\x2\x2\x13FB\x1404\x3\x2\x2\x2\x13FC\x13FE\a\xAD\x2\x2");
		sb.Append("\x13FD\x13FC\x3\x2\x2\x2\x13FD\x13FE\x3\x2\x2\x2\x13FE\x1402");
		sb.Append("\x3\x2\x2\x2\x13FF\x1403\a\x1F5\x2\x2\x1400\x1401\a\x1F6\x2");
		sb.Append("\x2\x1401\x1403\a\x1E5\x2\x2\x1402\x13FF\x3\x2\x2\x2\x1402\x1400");
		sb.Append("\x3\x2\x2\x2\x1403\x1405\x3\x2\x2\x2\x1404\x13FD\x3\x2\x2\x2");
		sb.Append("\x1404\x1405\x3\x2\x2\x2\x1405\x140A\x3\x2\x2\x2\x1406\x1407");
		sb.Append("\a\x1E4\x2\x2\x1407\x1409\x5\x2DE\x170\x2\x1408\x1406\x3\x2");
		sb.Append("\x2\x2\x1409\x140C\x3\x2\x2\x2\x140A\x1408\x3\x2\x2\x2\x140A");
		sb.Append("\x140B\x3\x2\x2\x2\x140B\x2DB\x3\x2\x2\x2\x140C\x140A\x3\x2");
		sb.Append("\x2\x2\x140D\x1412\x5\x2DE\x170\x2\x140E\x140F\a\x1E4\x2\x2");
		sb.Append("\x140F\x1411\x5\x2DE\x170\x2\x1410\x140E\x3\x2\x2\x2\x1411\x1414");
		sb.Append("\x3\x2\x2\x2\x1412\x1410\x3\x2\x2\x2\x1412\x1413\x3\x2\x2\x2");
		sb.Append("\x1413\x2DD\x3\x2\x2\x2\x1414\x1412\x3\x2\x2\x2\x1415\x1416");
		sb.Append("\a\x205\x2\x2\x1416\x1418\x5\x2C4\x163\x2\x1417\x1415\x3\x2");
		sb.Append("\x2\x2\x1417\x1418\x3\x2\x2\x2\x1418\x1419\x3\x2\x2\x2\x1419");
		sb.Append("\x141E\x5\x2EC\x177\x2\x141A\x141B\a\x1E4\x2\x2\x141B\x141D");
		sb.Append("\x5\x2EC\x177\x2\x141C\x141A\x3\x2\x2\x2\x141D\x1420\x3\x2\x2");
		sb.Append("\x2\x141E\x141C\x3\x2\x2\x2\x141E\x141F\x3\x2\x2\x2\x141F\x1422");
		sb.Append("\x3\x2\x2\x2\x1420\x141E\x3\x2\x2\x2\x1421\x1423\x5\x2C8\x165");
		sb.Append("\x2\x1422\x1421\x3\x2\x2\x2\x1422\x1423\x3\x2\x2\x2\x1423\x2DF");
		sb.Append("\x3\x2\x2\x2\x1424\x1425\a\x205\x2\x2\x1425\x1427\x5\x2C4\x163");
		sb.Append("\x2\x1426\x1424\x3\x2\x2\x2\x1426\x1427\x3\x2\x2\x2\x1427\x1428");
		sb.Append("\x3\x2\x2\x2\x1428\x142D\x5\x2EC\x177\x2\x1429\x142A\a\x1E4");
		sb.Append("\x2\x2\x142A\x142C\x5\x2EC\x177\x2\x142B\x1429\x3\x2\x2\x2\x142C");
		sb.Append("\x142F\x3\x2\x2\x2\x142D\x142B\x3\x2\x2\x2\x142D\x142E\x3\x2");
		sb.Append("\x2\x2\x142E\x2E1\x3\x2\x2\x2\x142F\x142D\x3\x2\x2\x2\x1430");
		sb.Append("\x1433\a\x17C\x2\x2\x1431\x1434\x5\x2E8\x175\x2\x1432\x1434");
		sb.Append("\x5\x2DA\x16E\x2\x1433\x1431\x3\x2\x2\x2\x1433\x1432\x3\x2\x2");
		sb.Append("\x2\x1434\x1439\x3\x2\x2\x2\x1435\x1436\a\x12\x2\x2\x1436\x1437");
		sb.Append("\a\x17B\x2\x2\x1437\x1438\a\x1C2\x2\x2\x1438\x143A\x5\x2E8\x175");
		sb.Append("\x2\x1439\x1435\x3\x2\x2\x2\x1439\x143A\x3\x2\x2\x2\x143A\x146F");
		sb.Append("\x3\x2\x2\x2\x143B\x143F\a\xB9\x2\x2\x143C\x1440\x5\x2E8\x175");
		sb.Append("\x2\x143D\x1440\x5\x2DA\x16E\x2\x143E\x1440\x5\x2DE\x170\x2");
		sb.Append("\x143F\x143C\x3\x2\x2\x2\x143F\x143D\x3\x2\x2\x2\x143F\x143E");
		sb.Append("\x3\x2\x2\x2\x1440\x1441\x3\x2\x2\x2\x1441\x144F\tN\x2\x2\x1442");
		sb.Append("\x1445\a\x1EB\x2\x2\x1443\x1446\a\x1E5\x2\x2\x1444\x1446\x5");
		sb.Append("\x2DA\x16E\x2\x1445\x1443\x3\x2\x2\x2\x1445\x1444\x3\x2\x2\x2");
		sb.Append("\x1446\x144C\x3\x2\x2\x2\x1447\x144A\a\x1F1\x2\x2\x1448\x144B");
		sb.Append("\a\x1E5\x2\x2\x1449\x144B\x5\x2DA\x16E\x2\x144A\x1448\x3\x2");
		sb.Append("\x2\x2\x144A\x1449\x3\x2\x2\x2\x144B\x144D\x3\x2\x2\x2\x144C");
		sb.Append("\x1447\x3\x2\x2\x2\x144C\x144D\x3\x2\x2\x2\x144D\x144E\x3\x2");
		sb.Append("\x2\x2\x144E\x1450\a\x1EC\x2\x2\x144F\x1442\x3\x2\x2\x2\x144F");
		sb.Append("\x1450\x3\x2\x2\x2\x1450\x1460\x3\x2\x2\x2\x1451\x145E\a\x184");
		sb.Append("\x2\x2\x1452\x145F\aZ\x2\x2\x1453\x145F\a\xA2\x2\x2\x1454\x145F");
		sb.Append("\a\xDE\x2\x2\x1455\x145C\a\x14D\x2\x2\x1456\x1459\a\x1EB\x2");
		sb.Append("\x2\x1457\x145A\a\x1E5\x2\x2\x1458\x145A\x5\x2DA\x16E\x2\x1459");
		sb.Append("\x1457\x3\x2\x2\x2\x1459\x1458\x3\x2\x2\x2\x145A\x145B\x3\x2");
		sb.Append("\x2\x2\x145B\x145D\a\x1EC\x2\x2\x145C\x1456\x3\x2\x2\x2\x145C");
		sb.Append("\x145D\x3\x2\x2\x2\x145D\x145F\x3\x2\x2\x2\x145E\x1452\x3\x2");
		sb.Append("\x2\x2\x145E\x1453\x3\x2\x2\x2\x145E\x1454\x3\x2\x2\x2\x145E");
		sb.Append("\x1455\x3\x2\x2\x2\x145F\x1461\x3\x2\x2\x2\x1460\x1451\x3\x2");
		sb.Append("\x2\x2\x1460\x1461\x3\x2\x2\x2\x1461\x146F\x3\x2\x2\x2\x1462");
		sb.Append("\x146F\x5\x2E4\x173\x2\x1463\x1464\aY\x2\x2\x1464\x146F\x5\x2E8");
		sb.Append("\x175\x2\x1465\x146F\x5\x2E8\x175\x2\x1466\x146F\a\xFD\x2\x2");
		sb.Append("\x1467\x146F\a\x18B\x2\x2\x1468\x146F\a\x8D\x2\x2\x1469\x146F");
		sb.Append("\a\\\x2\x2\x146A\x146F\a\x157\x2\x2\x146B\x146F\a\xDF\x2\x2");
		sb.Append("\x146C\x146F\a\xD9\x2\x2\x146D\x146F\a\x64\x2\x2\x146E\x1430");
		sb.Append("\x3\x2\x2\x2\x146E\x143B\x3\x2\x2\x2\x146E\x1462\x3\x2\x2\x2");
		sb.Append("\x146E\x1463\x3\x2\x2\x2\x146E\x1465\x3\x2\x2\x2\x146E\x1466");
		sb.Append("\x3\x2\x2\x2\x146E\x1467\x3\x2\x2\x2\x146E\x1468\x3\x2\x2\x2");
		sb.Append("\x146E\x1469\x3\x2\x2\x2\x146E\x146A\x3\x2\x2\x2\x146E\x146B");
		sb.Append("\x3\x2\x2\x2\x146E\x146C\x3\x2\x2\x2\x146E\x146D\x3\x2\x2\x2");
		sb.Append("\x146F\x2E3\x3\x2\x2\x2\x1470\x1471\tO\x2\x2\x1471\x2E5\x3\x2");
		sb.Append("\x2\x2\x1472\x1473\a\x1F0\x2\x2\x1473\x1474\x5\x2E4\x173\x2");
		sb.Append("\x1474\x2E7\x3\x2\x2\x2\x1475\x1476\tP\x2\x2\x1476\x2E9\x3\x2");
		sb.Append("\x2\x2\x1477\x1478\a\x205\x2\x2\x1478\x147A\x5\x2C4\x163\x2");
		sb.Append("\x1479\x1477\x3\x2\x2\x2\x1479\x147A\x3\x2\x2\x2\x147A\x147B");
		sb.Append("\x3\x2\x2\x2\x147B\x147C\x5\x2EC\x177\x2\x147C\x2EB\x3\x2\x2");
		sb.Append("\x2\x147D\x1480\x5\x2F8\x17D\x2\x147E\x1480\a\x1E8\x2\x2\x147F");
		sb.Append("\x147D\x3\x2\x2\x2\x147F\x147E\x3\x2\x2\x2\x1480\x2ED\x3\x2");
		sb.Append("\x2\x2\x1481\x1489\a\x1FB\x2\x2\x1482\x1483\a\x1F9\x2\x2\x1483");
		sb.Append("\x1489\a\x1FF\x2\x2\x1484\x1485\a\x1FE\x2\x2\x1485\x1489\a\x202");
		sb.Append("\x2\x2\x1486\x1487\a\x1FC\x2\x2\x1487\x1489\a\x202\x2\x2\x1488");
		sb.Append("\x1481\x3\x2\x2\x2\x1488\x1482\x3\x2\x2\x2\x1488\x1484\x3\x2");
		sb.Append("\x2\x2\x1488\x1486\x3\x2\x2\x2\x1489\x2EF\x3\x2\x2\x2\x148A");
		sb.Append("\x148E\a\x1FA\x2\x2\x148B\x148C\a\x1FF\x2\x2\x148C\x148E\a\x202");
		sb.Append("\x2\x2\x148D\x148A\x3\x2\x2\x2\x148D\x148B\x3\x2\x2\x2\x148E");
		sb.Append("\x2F1\x3\x2\x2\x2\x148F\x1493\a\x1F8\x2\x2\x1490\x1491\a\x1F9");
		sb.Append("\x2\x2\x1491\x1493\a\x202\x2\x2\x1492\x148F\x3\x2\x2\x2\x1492");
		sb.Append("\x1490\x3\x2\x2\x2\x1493\x2F3\x3\x2\x2\x2\x1494\x1498\a\x200");
		sb.Append("\x2\x2\x1495\x1496\a\x201\x2\x2\x1496\x1498\a\x201\x2\x2\x1497");
		sb.Append("\x1494\x3\x2\x2\x2\x1497\x1495\x3\x2\x2\x2\x1498\x2F5\x3\x2");
		sb.Append("\x2\x2\x1499\x149A\a\x1EB\x2\x2\x149A\x149B\a\x1EF\x2\x2\x149B");
		sb.Append("\x149C\a\x1EC\x2\x2\x149C\x2F7\x3\x2\x2\x2\x149D\x149E\tQ\x2");
		sb.Append("\x2\x149E\x2F9\x3\x2\x2\x2\x2B8\x2FD\x302\x309\x30B\x323\x32F");
		sb.Append("\x334\x339\x340\x342\x34C\x351\x359\x35B\x35F\x363\x368\x36D");
		sb.Append("\x372\x378\x386\x38B\x38E\x394\x39D\x3AB\x3B3\x3BD\x3C0\x3C5");
		sb.Append("\x3CA\x3D1\x3D6\x3E0\x3E7\x3E9\x3ED\x3F3\x3F8\x403\x40D\x412");
		sb.Append("\x41E\x423\x428\x42B\x439\x445\x44A\x44F\x456\x458\x462\x467");
		sb.Append("\x46A\x46E\x473\x479\x48B\x490\x495\x497\x49E\x4A5\x4A8\x4AB");
		sb.Append("\x4AE\x4B9\x4C5\x4C9\x4CC\x4D5\x4DD\x4E5\x4E8\x4EF\x4F3\x4FA");
		sb.Append("\x500\x529\x545\x54C\x551\x55C\x55F\x56A\x572\x576\x582\x585");
		sb.Append("\x58B\x58E\x593\x598\x59C\x5A6\x5B0\x5B6\x5C1\x5C6\x5CA\x5D2");
		sb.Append("\x5DA\x5DF\x5E2\x5E4\x5E7\x5F0\x5F5\x5FC\x5FF\x602\x606\x609");
		sb.Append("\x611\x616\x61B\x622\x62C\x63C\x642\x64C\x656\x65D\x662\x668");
		sb.Append("\x672\x677\x67E\x683\x689\x68C\x68F\x6A0\x6A5\x6AE\x6B3\x6B9");
		sb.Append("\x6BC\x6C3\x6C6\x6CD\x6D2\x6D6\x6DB\x6E0\x6EA\x6F0\x6FA\x6FF");
		sb.Append("\x706\x70C\x710\x713\x716\x727\x72C\x734\x742\x749\x759\x762");
		sb.Append("\x764\x779\x789\x792\x797\x79B\x79E\x7A8\x7B4\x7BA\x7C2\x7C6");
		sb.Append("\x7C9\x7D7\x7DB\x7E0\x7E3\x7F0\x7F4\x800\x805\x809\x80D\x813");
		sb.Append("\x816\x819\x834\x83A\x83E\x844\x850\x859\x85B\x861\x865\x868");
		sb.Append("\x871\x87C\x880\x883\x887\x88F\x898\x8A1\x8A3\x8C2\x8C6\x8CD");
		sb.Append("\x8D1\x8D5\x8D9\x8E5\x8E9\x8F7\x8FD\x904\x909\x913\x919\x91B");
		sb.Append("\x924\x92E\x933\x942\x946\x949\x94D\x952\x956\x95C\x964\x96B");
		sb.Append("\x970\x972\x977\x97C\x984\x98B\x98F\x992\x99E\x9A4\x9AC\x9B6");
		sb.Append("\x9C1\x9C4\x9CB\x9CE\x9D5\x9E0\x9E6\x9EA\x9F4\x9F7\x9FD\xA08");
		sb.Append("\xA0A\xA0C\xA0F\xA13\xA16\xA1A\xA1E\xA23\xA2E\xA32\xA3A\xA3D");
		sb.Append("\xA42\xA44\xA4D\xA57\xA5C\xA62\xA66\xA69\xA71\xA74\xA78\xA7C");
		sb.Append("\xA81\xA84\xA88\xA8C\xA90\xA9C\xAAA\xAAF\xAB3\xABC\xAC0\xAC8");
		sb.Append("\xACB\xACE\xAD2\xAD5\xAD8\xADB\xADF\xAE9\xAF0\xAF7\xAFC\xB01");
		sb.Append("\xB08\xB0E\xB18\xB1A\xB1F\xB23\xB26\xB29\xB2D\xB32\xB36\xB38");
		sb.Append("\xB45\xB4C\xB5A\xB5D\xB67\xB6B\xB73\xB7F\xB89\xB8E\xB98\xBA0");
		sb.Append("\xBA3\xBA9\xBAD\xBB2\xBBC\xBC1\xBCE\xBDA\xBDF\xBE9\xBEE\xBF0");
		sb.Append("\xBF5\xBF9\xBFF\xC03\xC10\xC14\xC1E\xC21\xC23\xC28\xC31\xC3E");
		sb.Append("\xC46\xC4F\xC53\xC58\xC63\xC65\xC75\xC7A\xC80\xC86\xC98\xC9F");
		sb.Append("\xCA2\xCAA\xCB3\xCB5\xCB9\xCBC\xCC1\xCC3\xCC7\xCD3\xCDC\xCE4");
		sb.Append("\xCE9\xCED\xCF2\xCF5\xCFD\xD05\xD0B\xD0E\xD11\xD19\xD23\xD2F");
		sb.Append("\xD36\xD3A\xD3E\xD41\xD44\xD49\xD4E\xD51\xD54\xD5A\xD5D\xD63");
		sb.Append("\xD66\xD69\xD6E\xD71\xD79\xD7F\xD89\xD8E\xD97\xDA1\xDA5\xDA7");
		sb.Append("\xDAA\xDB6\xDBA\xDBD\xDD1\xDD6\xDDB\xDE2\xDE5\xDEE\xDF5\xDFA");
		sb.Append("\xDFE\xE06\xE0C\xE14\xE17\xE1F\xE27\xE2A\xE2D\xE36\xE3C\xE42");
		sb.Append("\xE44\xE51\xE53\xE5C\xE5E\xE62\xE68\xE6C\xE7A\xE80\xE8F\xE92");
		sb.Append("\xE9B\xEA1\xEA6\xEB1\xEB5\xEBC\xEC1\xEC5\xECB\xECF\xEDA\xEDF");
		sb.Append("\xEE4\xEED\xEEF\xEF1\xF02\xF0A\xF16\xF20\xF28\xF31\xF34\xF3B");
		sb.Append("\xF43\xF4A\xF4E\xF55\xF59\xF5E\xF62\xF6A\xF6E\xF75\xF7E\xF8C");
		sb.Append("\xF99\xF9E\xFB4\xFB8\xFBB\xFC2\xFC5\xFC9\xFCC\xFD3\xFD6\xFDC");
		sb.Append("\xFDF\xFE3\xFE6\xFED\xFF2\x1000\x1006\x1008\x100C\x1014\x1020");
		sb.Append("\x1025\x102A\x1030\x1033\x1037\x1041\x1051\x1055\x105E\x1064");
		sb.Append("\x1072\x107D\x1081\x1084\x108D\x1093\x109D\x10A5\x10A8\x10AB");
		sb.Append("\x10B4\x10B9\x10C2\x10C8\x10CD\x10D0\x10D5\x10DA\x10DE\x10E4");
		sb.Append("\x10EA\x10F3\x10F8\x1100\x1104\x1109\x110F\x1116\x111B\x1122");
		sb.Append("\x1126\x112B\x1133\x1136\x1139\x113C\x1140\x1145\x114A\x114E");
		sb.Append("\x1155\x115A\x115C\x1167\x116B\x116D\x1178\x1183\x118C\x118F");
		sb.Append("\x1193\x1196\x119A\x11A7\x11AC\x11B4\x11BB\x11C0\x11C4\x11C9");
		sb.Append("\x11CE\x11D1\x11D8\x11E2\x11EA\x11EE\x11F8\x11FB\x11FD\x1207");
		sb.Append("\x1209\x120F\x1215\x1217\x1225\x1227\x122F\x1232\x123B\x1244");
		sb.Append("\x124E\x1252\x1257\x125B\x125E\x1262\x1269\x1275\x1280\x1283");
		sb.Append("\x1287\x129A\x129F\x12A6\x12B3\x12BD\x12C2\x12CB\x12D3\x12DB");
		sb.Append("\x12E1\x12E6\x12EB\x12EF\x12F4\x12F7\x12FD\x1301\x1306\x130F");
		sb.Append("\x1315\x131A\x1321\x132B\x132F\x1335\x133A\x133F\x1341\x1346");
		sb.Append("\x134A\x134F\x1356\x135B\x135D\x135F\x1369\x136E\x1372\x1375");
		sb.Append("\x1379\x1382\x1388\x138C\x138E\x1392\x1396\x139A\x13A2\x13AA");
		sb.Append("\x13AC\x13B2\x13B5\x13CD\x13D4\x13F5\x13FA\x13FD\x1402\x1404");
		sb.Append("\x140A\x1412\x1417\x141E\x1422\x1426\x142D\x1433\x1439\x143F");
		sb.Append("\x1445\x144A\x144C\x144F\x1459\x145C\x145E\x1460\x146E\x1479");
		sb.Append("\x147F\x1488\x148D\x1492\x1497");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
